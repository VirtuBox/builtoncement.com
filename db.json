{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"src/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/vue/source/browserconfig.xml","path":"browserconfig.xml","modified":0,"renderable":1},{"_id":"themes/vue/source/manifest.json","path":"manifest.json","modified":0,"renderable":1},{"_id":"themes/vue/source/css/benchmark.styl","path":"css/benchmark.styl","modified":0,"renderable":1},{"_id":"themes/vue/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/vue/source/css/page.styl","path":"css/page.styl","modified":0,"renderable":1},{"_id":"themes/vue/source/images/check.png","path":"images/check.png","modified":0,"renderable":1},{"_id":"themes/vue/source/css/search.styl","path":"css/search.styl","modified":0,"renderable":1},{"_id":"themes/vue/source/images/down.png","path":"images/down.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/feed.png","path":"images/feed.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons.png","path":"images/icons.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/logo.png","path":"images/logo.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/menu.png","path":"images/menu.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/patreon.png","path":"images/patreon.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/search.png","path":"images/search.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/vue-logo.png","path":"images/vue-logo.png","modified":0,"renderable":1},{"_id":"themes/vue/source/js/css.escape.js","path":"js/css.escape.js","modified":0,"renderable":1},{"_id":"themes/vue/source/js/common.js","path":"js/common.js","modified":0,"renderable":1},{"_id":"themes/vue/source/js/smooth-scroll.min.js","path":"js/smooth-scroll.min.js","modified":0,"renderable":1},{"_id":"themes/vue/source/images/hero-logo.png","path":"images/hero-logo.png","modified":0,"renderable":1},{"_id":"themes/vue/source/js/vue.min.js","path":"js/vue.min.js","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-144x144.png","path":"images/icons/android-icon-144x144.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-192x192.png","path":"images/icons/android-icon-192x192.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-36x36.png","path":"images/icons/android-icon-36x36.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-48x48.png","path":"images/icons/android-icon-48x48.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-72x72.png","path":"images/icons/android-icon-72x72.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-114x114.png","path":"images/icons/apple-icon-114x114.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/android-icon-96x96.png","path":"images/icons/android-icon-96x96.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-120x120.png","path":"images/icons/apple-icon-120x120.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-144x144.png","path":"images/icons/apple-icon-144x144.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-180x180.png","path":"images/icons/apple-icon-180x180.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-152x152.png","path":"images/icons/apple-icon-152x152.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-60x60.png","path":"images/icons/apple-icon-60x60.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-72x72.png","path":"images/icons/apple-icon-72x72.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-76x76.png","path":"images/icons/apple-icon-76x76.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-57x57.png","path":"images/icons/apple-icon-57x57.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/favicon-20x20.png","path":"images/icons/favicon-20x20.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon.png","path":"images/icons/apple-icon.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/apple-icon-precomposed.png","path":"images/icons/apple-icon-precomposed.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/favicon-29x29.png","path":"images/icons/favicon-29x29.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/favicon-87x87.png","path":"images/icons/favicon-87x87.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/ms-icon-144x144.png","path":"images/icons/ms-icon-144x144.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/favicon.png","path":"images/icons/favicon.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/ms-icon-150x150.png","path":"images/icons/ms-icon-150x150.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/ms-icon-70x70.png","path":"images/icons/ms-icon-70x70.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/icons/ms-icon-310x310.png","path":"images/icons/ms-icon-310x310.png","modified":0,"renderable":1},{"_id":"themes/vue/source/js/vue.js","path":"js/vue.js","modified":0,"renderable":1},{"_id":"themes/vue/source/images/trueability.png","path":"images/trueability.png","modified":0,"renderable":1},{"_id":"themes/vue/source/images/datafolklabs.png","path":"images/datafolklabs.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/vue/LICENSE","hash":"792307477535610520eb9898f9b4be1735470a8b","modified":1498333939000},{"_id":"themes/vue/_config.yml","hash":"f23bc3d3b0237b59b199c5e58a207ba9ac84d326","modified":1497211252000},{"_id":"src/CNAME","hash":"2f28b155ccc571395dcacec7ae31a24a7fd7983e","modified":1497211020000},{"_id":"src/index.md","hash":"fd945de1e31344f0d8be59bcc87e3f5fda468e11","modified":1497209290000},{"_id":"themes/vue/layout/index.ejs","hash":"7637f3d6da6463e01cc9b2f958279e1714cd9399","modified":1519811578406},{"_id":"themes/vue/layout/layout.ejs","hash":"4b0cf0f138e1f149158c1a0b50675e527d60ba46","modified":1502128801000},{"_id":"themes/vue/layout/page.ejs","hash":"566fd8bf96c0e22609f8b01c7bfa3a68048b77d1","modified":1498348065000},{"_id":"themes/vue/layout/post.ejs","hash":"206faa4e4944eb092c9b9706c81131a46be6d2be","modified":1497415609000},{"_id":"themes/vue/source/browserconfig.xml","hash":"115f1a6d4b6a6ca0661f12b3d9a6123f213d78b7","modified":1497209290000},{"_id":"themes/vue/source/manifest.json","hash":"8176d00b74329f73a1b737f87d09a38a09323bd9","modified":1497213241000},{"_id":"src/2.10/whats_new.md","hash":"59b929186968be20e3919dd0d676d182db893248","modified":1498349486000},{"_id":"src/backers/index.md","hash":"3eec60f92923597bd615b3fada1386aff78def2c","modified":1498341623000},{"_id":"src/_posts/portland-development.md","hash":"f29dd49bdbc8f864aa3de8de2d6009ef47a75b46","modified":1497415609000},{"_id":"src/mailing-list/index.md","hash":"bf9f1482319ee8ea8dc18e8750498f9464474cfd","modified":1498443009000},{"_id":"src/menu/index.md","hash":"189f0685b3420069e60d21599ace0e653ed99ecb","modified":1497209290000},{"_id":"themes/vue/layout/partials/header.ejs","hash":"c4f44c4a31d593d96cb694eec7ffb7ae899ba567","modified":1497212934000},{"_id":"themes/vue/layout/partials/main_menu.ejs","hash":"659d7d485016fe02f8d57bff5a65dd6730c18cea","modified":1511051251187},{"_id":"themes/vue/layout/partials/resources_dropdown.ejs","hash":"0bfe6b042d828f01a4698bbeda50023ee2c300cd","modified":1524761005170},{"_id":"themes/vue/layout/partials/sidebar.ejs","hash":"9a766d1cd73be4538a8a0e86f6e3bce3db4cd88f","modified":1501873241000},{"_id":"themes/vue/layout/partials/toc.ejs","hash":"737c7ec04ac258d7a27d7eefdc1a4b72204b87e0","modified":1498625522000},{"_id":"themes/vue/layout/partials/sponsors.ejs","hash":"832ed066b15377e0c49c96d793c393ab78339682","modified":1501872915000},{"_id":"themes/vue/source/css/_common.styl","hash":"2aa214754d126deb86cbc00a12303f5666133f72","modified":1497209290000},{"_id":"themes/vue/source/css/_demo.styl","hash":"21a1a05638723cd8554562fb35f910418d3515bc","modified":1497209290000},{"_id":"themes/vue/source/css/_header.styl","hash":"d69290ef394a0f4eeaea8f8f2ac367c6d034ae72","modified":1497213205000},{"_id":"themes/vue/source/css/_migration.styl","hash":"6957759d62791edf2e6e2e8a9e026bb25492d159","modified":1497209290000},{"_id":"themes/vue/source/css/_settings.styl","hash":"68aa521523364ada8db4ecb4284f36bc34bd888d","modified":1497226657000},{"_id":"themes/vue/source/css/_offline-menu.styl","hash":"5c6c95cb886d61130a39122de6de3393fe3d416d","modified":1497209290000},{"_id":"themes/vue/source/css/_sponsor.styl","hash":"6a4e1503b1e4f0e98e1e008ba846036fee3199aa","modified":1497209290000},{"_id":"themes/vue/source/css/_syntax.styl","hash":"bf565891b976c57ef522cf72a44a1e28ebcca224","modified":1497243253000},{"_id":"themes/vue/source/css/benchmark.styl","hash":"95d4607b2b59623a673e131e1a267d0311fe89e6","modified":1497209290000},{"_id":"themes/vue/source/css/_sidebar.styl","hash":"040ff325cd13c74e8f9038ae31836eabbed5ce9d","modified":1497209290000},{"_id":"themes/vue/source/css/index.styl","hash":"35ae5aa7fad82fa1bc54a1ff8edab5c631d8bea9","modified":1501872500000},{"_id":"themes/vue/source/css/page.styl","hash":"d1a9c45fbda169e44a3052cefab035e033460a1a","modified":1497226875000},{"_id":"themes/vue/source/images/check.png","hash":"63c871d2b373b77c72349170f5ef426e0d1cd09b","modified":1497209290000},{"_id":"themes/vue/source/css/search.styl","hash":"5117f05598154cfc84da04ec1a257bd186653ba2","modified":1497209290000},{"_id":"themes/vue/source/images/down.png","hash":"199cae4696850c6f7420c2706c6f4786e03c396c","modified":1497209290000},{"_id":"themes/vue/source/images/feed.png","hash":"40639090cfeac0a5ac5d92c5c1b3702c95a50a9e","modified":1497209290000},{"_id":"themes/vue/source/images/icons.png","hash":"f37248aa22ed3dc4bddefbd9499e5e68ce41a3a1","modified":1497209290000},{"_id":"themes/vue/source/images/logo.png","hash":"e495e6f5c05bf7243206a79a3ec3ea4764193231","modified":1497210498000},{"_id":"themes/vue/source/images/menu.png","hash":"3e2ba61af1ab5350ffbf0fecaf882f3bfa364ca3","modified":1497209290000},{"_id":"themes/vue/source/images/patreon.png","hash":"c36749e54c07f680b15c88dadc7b1475f4d83afa","modified":1497209290000},{"_id":"themes/vue/source/images/search.png","hash":"4546e84b0067609c3fa3c59358c68bf82ebc03a4","modified":1497209290000},{"_id":"themes/vue/source/images/tde.png","hash":"de6fa834455ebf829416cc73ec80d26e19b09fbe","modified":1497209290000},{"_id":"themes/vue/source/images/vue-logo.png","hash":"718c6e48956249121cf3cca1a22a99f8372a3f0d","modified":1497209290000},{"_id":"themes/vue/source/js/css.escape.js","hash":"1d0e28a08261de3955b0ee18432e304c1f468441","modified":1497209290000},{"_id":"themes/vue/source/js/common.js","hash":"9ad4e1f2e06a8f73829b27eadeec6b05850b3dbe","modified":1511046600635},{"_id":"themes/vue/source/js/smooth-scroll.min.js","hash":"48d800d2b3be86c704e002502999413504bbd04d","modified":1497209290000},{"_id":"src/2.10/api/index.md","hash":"9d36a37d89dccb23105d1a269095d7576b38d1f9","modified":1498625571000},{"_id":"src/2.10/dev/arguments.md","hash":"16da914c1dec49953ca73464d0e6e4cc1628b471","modified":1498447120000},{"_id":"src/2.10/dev/configuration.md","hash":"a09889beea657bb63abbab132a5862bc9a4a340d","modified":1498446573000},{"_id":"src/2.10/dev/interfaces_and_handlers.md","hash":"6a7dfd14cf38f62a165b7c4e45d1b99e82468d5d","modified":1498350343000},{"_id":"src/2.10/dev/index.md","hash":"df5229d2f7595ba2452b06e730dec385d608c0ff","modified":1516160275080},{"_id":"src/2.10/dev/logging.md","hash":"b0382f251e6fa1901bcbc11ceb7f38831ad570cf","modified":1501816723000},{"_id":"src/2.10/dev/quickstart.md","hash":"25f46c3e8ea7f1166d6aa58c6d9982709dfcb765","modified":1516160353626},{"_id":"src/portland/cookbook/adding-instance-properties.md","hash":"e83d2ceee8fd3935dbd8093f3f1707f166f14082","modified":1497209290000},{"_id":"src/portland/cookbook/index.md","hash":"feaa6cea9fe7d45f60098f35009ae8d7187d430d","modified":1497209290000},{"_id":"src/portland/dev/index.md","hash":"bf069038c55a0d1d9dc44cd94f866aa14e93a328","modified":1498349773000},{"_id":"src/portland/dev/interfaces_and_handlers.md","hash":"7dda94430d1065e526b7e8aa24020d39f1146030","modified":1498345707000},{"_id":"src/portland/examples/example-1.md","hash":"f592e403a1f3455d069c3005f718c5ec14d3811c","modified":1498334144000},{"_id":"src/portland/dev/overview.md","hash":"cb79ebd4cf3c103f7e8f433b4da84cf48a8c7463","modified":1498345682000},{"_id":"themes/vue/source/images/hero-logo.png","hash":"95dc45fe069394897ae89b7ece9774fde4da3200","modified":1497210537000},{"_id":"themes/vue/source/js/vue.min.js","hash":"4e7761d6f9f23ba54b529e048d20f93b04ce1af0","modified":1497209290000},{"_id":"src/portland/api/index.md","hash":"dc709fa97cdad16e6c4161200f9d21615cb469c6","modified":1511037968006},{"_id":"themes/vue/source/images/icons/android-icon-144x144.png","hash":"92e055a07a4d1a8fbe5f0e9c5cadd70bf05633e2","modified":1497229356000},{"_id":"themes/vue/source/images/icons/android-icon-192x192.png","hash":"1ae73b61702f0738ae71255879010f49fd2edeea","modified":1497229356000},{"_id":"themes/vue/source/images/icons/android-icon-36x36.png","hash":"fdbc3a251c79af8f539ac2b4f13d6b0d331c8646","modified":1497229356000},{"_id":"themes/vue/source/images/icons/android-icon-48x48.png","hash":"c3d10414ede4b9dbe76b488d727bb6bda68e3e18","modified":1497229356000},{"_id":"themes/vue/source/images/icons/android-icon-72x72.png","hash":"c05475c34a9cd2749406dfa840a438c71cf7f3f7","modified":1497229356000},{"_id":"themes/vue/source/images/icons/apple-icon-114x114.png","hash":"c4870aa1cf8977d65476a664cefc752a806f5ca7","modified":1497229356000},{"_id":"themes/vue/source/images/icons/android-icon-96x96.png","hash":"a2ac2fa5aa304a77fc4825c5b3f989ab974eba17","modified":1497229356000},{"_id":"themes/vue/source/images/icons/apple-icon-120x120.png","hash":"e63b4941226794516ae38a0907283b8f41766d01","modified":1497229356000},{"_id":"themes/vue/source/images/icons/apple-icon-144x144.png","hash":"92e055a07a4d1a8fbe5f0e9c5cadd70bf05633e2","modified":1497229356000},{"_id":"themes/vue/source/images/icons/apple-icon-180x180.png","hash":"aea1f2bfc355416d383d7d70b81746b989ab8e72","modified":1497229356000},{"_id":"themes/vue/source/images/icons/apple-icon-152x152.png","hash":"3e5e7a009e8d3ee7d9f2b0c19aa7cbf53e55a056","modified":1497229354000},{"_id":"themes/vue/source/images/icons/apple-icon-60x60.png","hash":"ce637bb0770a1f8844f65a4388d218b9ea90f7d3","modified":1497229356000},{"_id":"themes/vue/source/images/icons/apple-icon-72x72.png","hash":"c05475c34a9cd2749406dfa840a438c71cf7f3f7","modified":1497229356000},{"_id":"themes/vue/source/images/icons/apple-icon-76x76.png","hash":"66941cea0ef9ab20600674a6191e636d36d27a7a","modified":1497229356000},{"_id":"themes/vue/source/images/icons/apple-icon-57x57.png","hash":"8fb89fe4db0c98f07246540a2a278c587d4e489f","modified":1497229356000},{"_id":"themes/vue/source/images/icons/favicon-20x20.png","hash":"e7d4305815b6a71d89ebba10de091b5c95c203e5","modified":1497229356000},{"_id":"themes/vue/source/images/icons/apple-icon.png","hash":"917d2446777005ee46a7eece1b8fde0a93b4b716","modified":1497229354000},{"_id":"themes/vue/source/images/icons/apple-icon-precomposed.png","hash":"917d2446777005ee46a7eece1b8fde0a93b4b716","modified":1497229354000},{"_id":"themes/vue/source/images/icons/favicon-29x29.png","hash":"dec7cc0ed907bb386873ffc52c841b55c27c0689","modified":1497229356000},{"_id":"themes/vue/source/images/icons/favicon-87x87.png","hash":"dec7cc0ed907bb386873ffc52c841b55c27c0689","modified":1497229356000},{"_id":"themes/vue/source/images/icons/ms-icon-144x144.png","hash":"92e055a07a4d1a8fbe5f0e9c5cadd70bf05633e2","modified":1497229356000},{"_id":"themes/vue/source/images/icons/favicon.png","hash":"e7d4305815b6a71d89ebba10de091b5c95c203e5","modified":1497229356000},{"_id":"themes/vue/source/images/icons/ms-icon-150x150.png","hash":"3e5e7a009e8d3ee7d9f2b0c19aa7cbf53e55a056","modified":1497229354000},{"_id":"themes/vue/source/images/icons/ms-icon-70x70.png","hash":"c05475c34a9cd2749406dfa840a438c71cf7f3f7","modified":1497229356000},{"_id":"themes/vue/source/images/icons/ms-icon-310x310.png","hash":"57719fdbcbb8ed3f1b6312b960068d2ad4384a17","modified":1497229356000},{"_id":"themes/vue/source/js/vue.js","hash":"8e482e1719c0ece3864b45d772d42dc203c6d999","modified":1497209290000},{"_id":"src/2.10/dev/output.md","hash":"3bb341c5b72fbd1bda5c730aa584437752f2a9f6","modified":1501817941000},{"_id":"src/2.10/dev/controllers.md","hash":"1332a96ee9bad0a7f18a3e46a2282baef2b1d84a","modified":1501820276000},{"_id":"src/2.10/dev/extensions.md","hash":"ec6bf83af27977209fb40b67918fcaf3a81eb3b2","modified":1501823151000},{"_id":"themes/vue/source/.DS_Store","hash":"495dc0d217dbc3e7cb0c015a4aa9af3e7011d37f","modified":1501872731000},{"_id":"src/2.10/dev/plugins.md","hash":"b43fed85f386d5bdf71f2ece1871605c29d0d1de","modified":1502128532000},{"_id":"themes/vue/source/images/datafolklabs.png","hash":"0a93e6060a2389792de47e6d4cab7c538cab194e","modified":1405184178000},{"_id":"themes/vue/source/images/trueability.png","hash":"5f5a3976d8aa6cb891faacebfda41125275b81b2","modified":1389294646000},{"_id":"src/2.10/dev/application_design.md","hash":"3fbe89de18ee74f9d6c1b4bb460d5a1add9414a3","modified":1502259808000},{"_id":"src/2.10/dev/caching.md","hash":"7d041574fd9121fda62b2cac7c36906fc21ad1d2","modified":1502257680000},{"_id":"src/2.10/dev/boss_templates.md","hash":"cc87d26d634d5b05239a5f6cb7c31e35a9986541","modified":1502260040000},{"_id":"src/2.10/dev/cleanup.md","hash":"3479f80b5ebe4e05edcf5f0fe48a57314d434f5c","modified":1502257326000},{"_id":"src/2.10/dev/contributing.md","hash":"b5d3082995d8f40b898854dc94cbdd377c2ef666","modified":1516158356474},{"_id":"src/2.10/dev/hooks.md","hash":"0457c8c114013ef8a5ee8eb12bb24b5a787bc239","modified":1502253723000},{"_id":"src/2.10/dev/mail.md","hash":"212312b0d5eb1ab5bfde10b06451c2f372afaa4b","modified":1502258198000},{"_id":"src/2.10/dev/extending_cementapp.md","hash":"da9cfb8f2a8cd45de9be5f092b4ed432b304fe74","modified":1502255312000},{"_id":"src/2.10/dev/signal_handling.md","hash":"a5894ae4ef41289662c2668ea055d50daa0f9b9e","modified":1502256890000},{"_id":"src/2.10/dev/testing.md","hash":"3d7b534ae57eddaeb09ff3b3585ff1adbe3f05e1","modified":1502258745000},{"_id":"src/2.10/release_info.md","hash":"6f572af1bd8d8ece3f78741cebd94f13d97ca6dd","modified":1509337203000},{"_id":"src/2.10/examples/app_version.md","hash":"f6cb29ddcb61366439f8a0397e0e990b9045bfe6","modified":1509329252000},{"_id":"src/2.10/examples/abstract_base_controllers.md","hash":"abd1befbdae95958e39944335a6c771b27c0c2aa","modified":1509329649000},{"_id":"src/2.10/examples/arbitrary_extra_arguments.md","hash":"2cd14d8bab93681f12d488ad15e70acbee963eea","modified":1509330338000},{"_id":"src/2.10/examples/bash_auto_completion.md","hash":"3380064dd0a69a8e1c4a0a57bdc370eeb3049a68","modified":1509330171000},{"_id":"src/2.10/examples/index.md","hash":"ecc4f0993a9fbceaaa12a91eec6ab66d61b03616","modified":1509338829000},{"_id":"src/2.10/examples/managing_multiple_environments.md","hash":"2d247dd326dddb2f932993eabddecfe64ceb6668","modified":1509331061000},{"_id":"src/2.10/examples/controllers_with_same_label.md","hash":"42511a50603b1aa2ea4e8c146a4889391f07ee40","modified":1509329863000},{"_id":"src/2.10/examples/multiple_stacked_controllers.md","hash":"e99dcedf86eb407a66aa8a2e96bd03eac68327aa","modified":1509329426000},{"_id":"src/2.10/examples/reload_config.md","hash":"7af4afb0d972c19563f083ee665e8fe3eff8787a","modified":1509330561000},{"_id":"src/2.10/examples/sighup_reload.md","hash":"a7f1675f8fb1a56448e148507af979ae07db399c","modified":1509330922000},{"_id":"src/2.10/examples/tabularized_output.md","hash":"55f67d215d73b7b7f7db88ec20c30c680cb5423a","modified":1509330628000},{"_id":"public/atom.xml","hash":"1bc22e8775c407af7841127fe0c2ab3c4aad3224","modified":1511120592891},{"_id":"public/index.html","hash":"60d8930b5c49ec37e834c7f7fa87cb2ee36de8d5","modified":1511120593020},{"_id":"public/menu/index.html","hash":"91c12056ff4fa483ddc0ad87659b978e8fb586e2","modified":1511120593021},{"_id":"public/portland/cookbook/index.html","hash":"b08e8faaa241ba65891fb34745580b4983b4db82","modified":1509338392899},{"_id":"public/2017/06/13/portland-development/index.html","hash":"e7caa5743d1d0731235ba85180082d96a7de1860","modified":1511120593022},{"_id":"public/archives/index.html","hash":"fc56a7c1514c17964f3100ce2cd0d23d12f2cf31","modified":1511120593022},{"_id":"public/archives/2017/index.html","hash":"fc56a7c1514c17964f3100ce2cd0d23d12f2cf31","modified":1511120593023},{"_id":"public/archives/2017/06/index.html","hash":"fc56a7c1514c17964f3100ce2cd0d23d12f2cf31","modified":1511120593023},{"_id":"public/portland/cookbook/adding-instance-properties.html","hash":"7f6b25ed09a706f9ae66550de64678f4f7db8a97","modified":1509338392900},{"_id":"public/portland/dev/index.html","hash":"20a9876206c161c981a24a9f90214b086066338c","modified":1511120593024},{"_id":"public/portland/dev/overview.html","hash":"cdcd5a2457c8ecc1c5c36a5dfd75d3b48c35e720","modified":1511120593025},{"_id":"public/portland/api/index.html","hash":"32e1c3327f9ba7087d17a96e744fece7dbcc258a","modified":1509338392900},{"_id":"public/backers/index.html","hash":"6d3c2df7e5a1855c59f6a5626bf62f5822bcf9d8","modified":1511120593020},{"_id":"public/mailing-list/index.html","hash":"6cf984a29659bca91cf3e8baa83e3c3eccb3a024","modified":1511120593021},{"_id":"public/portland/examples/example-1.html","hash":"4583db51a736ca5be799d825fdfd491a3b921775","modified":1509338392905},{"_id":"public/2.10/dev/caching.html","hash":"a9e246ea91f0f34c056cb6d6f0809978f010aa02","modified":1511120593021},{"_id":"public/2.10/examples/app_version.html","hash":"742b483d00808622224cb7ed6c0aadbcfc068b10","modified":1511120593021},{"_id":"public/2.10/examples/tabularized_output.html","hash":"abd86f3e7ca95422652cef768039756c72d747eb","modified":1511120593021},{"_id":"public/2.10/examples/index.html","hash":"b00fde0c3c23cea42d3c18d1f45afebd705b5391","modified":1511120593021},{"_id":"public/2.10/dev/configuration.html","hash":"d6789cec54bbc302778e8ed7bb302f0dcd10c6c8","modified":1511120593024},{"_id":"public/2.10/dev/arguments.html","hash":"6bb4e0aeaed51d51eab7ef44f9b9b835fd1bbced","modified":1511120593024},{"_id":"public/2.10/dev/index.html","hash":"ab00c4a10c2371164d06ef2da777d7ea0920d2b0","modified":1511120593024},{"_id":"public/2.10/dev/logging.html","hash":"471ed1a78e5800b4fef8c5f2f8e204e5a97cd487","modified":1511120593024},{"_id":"public/2.10/dev/interfaces_and_handlers.html","hash":"9ccf7a654948aa6185405e3ce73e91d3cda208bd","modified":1511120593024},{"_id":"public/2.10/dev/quickstart.html","hash":"c707063ef3b036413761b10ce83ed23dcecce3c3","modified":1511120593024},{"_id":"public/portland/dev/interfaces_and_handlers.html","hash":"a4609499b9ec5b4a9b0ee48b0f2103f799c85fd5","modified":1511120593024},{"_id":"public/2.10/dev/output.html","hash":"10c685d64146b39d197813011d10d5a56c5f1246","modified":1511120593025},{"_id":"public/2.10/dev/controllers.html","hash":"f4d0d434fb56700c00486c8ae3ef81207ca26b9f","modified":1511120593025},{"_id":"public/2.10/dev/extensions.html","hash":"ad69e496e5df05069b2624f2a2a24ec5e7484fbe","modified":1511120593025},{"_id":"public/2.10/dev/plugins.html","hash":"c23557cb7cd3c75c71eefa89f3465247097ec839","modified":1511120593025},{"_id":"public/2.10/dev/hooks.html","hash":"bbcce3f3fe3ffde4485928464477bfa465025ca9","modified":1511120593025},{"_id":"public/2.10/dev/extending_cementapp.html","hash":"b965e06a1d318d20bc34c6fe61c165abc3bce374","modified":1511120593026},{"_id":"public/2.10/dev/signal_handling.html","hash":"ca55c35c8633a9e077e7e4ee47721e0da5cceeb3","modified":1511120593026},{"_id":"public/2.10/dev/cleanup.html","hash":"910512ad18ab0bca4b93d54aee35448decf90863","modified":1511120593027},{"_id":"public/2.10/dev/mail.html","hash":"414e6fc25ef5424586d5742f9cd9640eb50aaee3","modified":1511120593027},{"_id":"public/2.10/dev/testing.html","hash":"acb954679f1b5c692a45660c47cc592c9c8f77d0","modified":1511120593027},{"_id":"public/2.10/dev/application_design.html","hash":"0902f2287c943a6c5633431ee8e59e2843fff3f3","modified":1511120593027},{"_id":"public/2.10/dev/boss_templates.html","hash":"19567f9da81e2b8b1c7d4d7ff5235fefc32e758f","modified":1511120593027},{"_id":"public/2.10/dev/contributing.html","hash":"41131d19513b49a8a9a2f786cae21052d46be753","modified":1511120593027},{"_id":"public/2.10/examples/multiple_stacked_controllers.html","hash":"9441dce8b4af8523b7dc2825a80a628cdbc5df03","modified":1511120593027},{"_id":"public/2.10/examples/abstract_base_controllers.html","hash":"3cbb8d53e547bf90c3fb8f1c19c238889ba2173a","modified":1511120593027},{"_id":"public/2.10/examples/controllers_with_same_label.html","hash":"d6a45dadcf11200b88295612c169c74089c791d8","modified":1511120593027},{"_id":"public/2.10/examples/bash_auto_completion.html","hash":"85d95d27b10e1e38dece14932896e5c512a8e71b","modified":1511120593027},{"_id":"public/2.10/examples/arbitrary_extra_arguments.html","hash":"a33ce5bdfcc2b6ea89f26499f5048f43dc28a9b7","modified":1511120593027},{"_id":"public/2.10/examples/reload_config.html","hash":"c8d51cba64191f65f949551c0469cff620aa24de","modified":1511120593028},{"_id":"public/2.10/examples/sighup_reload.html","hash":"9ac0f441c0f584495e2bba5b742de9fa6a5aa3d9","modified":1511120593028},{"_id":"public/2.10/examples/managing_multiple_environments.html","hash":"fea22034683e00fdcba9b619e4509d3abaf35490","modified":1511120593028},{"_id":"public/2.10/release_info.html","hash":"f314f9e30322ee5076910f6b0c9c0c95368b4fdc","modified":1511120593028},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"9d1b45b47c0bc926e1c541f35225cffb1ce0048d","modified":1511120593041},{"_id":"public/images/trueability.png","hash":"5f5a3976d8aa6cb891faacebfda41125275b81b2","modified":1511120593041},{"_id":"public/images/datafolklabs.png","hash":"0a93e6060a2389792de47e6d4cab7c538cab194e","modified":1511120593041},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"de560936d3b893014b12dc0f87d74c5e59545b51","modified":1511120593042},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"2dd468bd234fbb9553508a0bd30643bb1a63cccc","modified":1511120593341},{"_id":"public/assets/algolia/algoliasearch.js","hash":"750c3ec801fad23cf295df7cc5d5370cb42dd29a","modified":1511120593347},{"_id":"src/2.10/api-reference/index.md","hash":"25e1084923e0ff9826f9eafc10035174a07380be","modified":1511047386269},{"_id":"src/portland/examples/index.md","hash":"99badb02721c10782c07e7c05b648667c773e9ea","modified":1511046481061},{"_id":"public/portland/examples/index.html","hash":"9bb9525e441d188f9036d0f51e0fa6283bbda024","modified":1511120593021},{"_id":"public/2.10/api-reference/index.html","hash":"3297a1afb04755e771051f908510ba47cbbc7759","modified":1511120593022},{"_id":"public/CNAME","hash":"2f28b155ccc571395dcacec7ae31a24a7fd7983e","modified":1511120593037},{"_id":"public/browserconfig.xml","hash":"115f1a6d4b6a6ca0661f12b3d9a6123f213d78b7","modified":1511120593038},{"_id":"public/images/check.png","hash":"63c871d2b373b77c72349170f5ef426e0d1cd09b","modified":1511120593038},{"_id":"public/images/down.png","hash":"199cae4696850c6f7420c2706c6f4786e03c396c","modified":1511120593038},{"_id":"public/images/feed.png","hash":"40639090cfeac0a5ac5d92c5c1b3702c95a50a9e","modified":1511120593038},{"_id":"public/images/icons.png","hash":"f37248aa22ed3dc4bddefbd9499e5e68ce41a3a1","modified":1511120593038},{"_id":"public/images/logo.png","hash":"e495e6f5c05bf7243206a79a3ec3ea4764193231","modified":1511120593038},{"_id":"public/images/menu.png","hash":"3e2ba61af1ab5350ffbf0fecaf882f3bfa364ca3","modified":1511120593038},{"_id":"public/images/patreon.png","hash":"c36749e54c07f680b15c88dadc7b1475f4d83afa","modified":1511120593038},{"_id":"public/images/search.png","hash":"4546e84b0067609c3fa3c59358c68bf82ebc03a4","modified":1511120593038},{"_id":"public/images/vue-logo.png","hash":"718c6e48956249121cf3cca1a22a99f8372a3f0d","modified":1511120593039},{"_id":"public/images/icons/android-icon-144x144.png","hash":"92e055a07a4d1a8fbe5f0e9c5cadd70bf05633e2","modified":1511120593039},{"_id":"public/images/icons/android-icon-192x192.png","hash":"1ae73b61702f0738ae71255879010f49fd2edeea","modified":1511120593039},{"_id":"public/images/icons/android-icon-36x36.png","hash":"fdbc3a251c79af8f539ac2b4f13d6b0d331c8646","modified":1511120593039},{"_id":"public/images/icons/android-icon-48x48.png","hash":"c3d10414ede4b9dbe76b488d727bb6bda68e3e18","modified":1511120593039},{"_id":"public/images/icons/android-icon-72x72.png","hash":"c05475c34a9cd2749406dfa840a438c71cf7f3f7","modified":1511120593039},{"_id":"public/images/icons/apple-icon-114x114.png","hash":"c4870aa1cf8977d65476a664cefc752a806f5ca7","modified":1511120593039},{"_id":"public/images/icons/android-icon-96x96.png","hash":"a2ac2fa5aa304a77fc4825c5b3f989ab974eba17","modified":1511120593039},{"_id":"public/images/icons/apple-icon-120x120.png","hash":"e63b4941226794516ae38a0907283b8f41766d01","modified":1511120593039},{"_id":"public/images/icons/apple-icon-144x144.png","hash":"92e055a07a4d1a8fbe5f0e9c5cadd70bf05633e2","modified":1511120593039},{"_id":"public/images/icons/apple-icon-180x180.png","hash":"aea1f2bfc355416d383d7d70b81746b989ab8e72","modified":1511120593039},{"_id":"public/images/icons/apple-icon-152x152.png","hash":"3e5e7a009e8d3ee7d9f2b0c19aa7cbf53e55a056","modified":1511120593039},{"_id":"public/images/icons/apple-icon-60x60.png","hash":"ce637bb0770a1f8844f65a4388d218b9ea90f7d3","modified":1511120593040},{"_id":"public/images/icons/apple-icon-72x72.png","hash":"c05475c34a9cd2749406dfa840a438c71cf7f3f7","modified":1511120593040},{"_id":"public/images/icons/apple-icon-76x76.png","hash":"66941cea0ef9ab20600674a6191e636d36d27a7a","modified":1511120593040},{"_id":"public/images/icons/apple-icon-57x57.png","hash":"8fb89fe4db0c98f07246540a2a278c587d4e489f","modified":1511120593040},{"_id":"public/images/icons/favicon-20x20.png","hash":"e7d4305815b6a71d89ebba10de091b5c95c203e5","modified":1511120593040},{"_id":"public/images/icons/apple-icon.png","hash":"917d2446777005ee46a7eece1b8fde0a93b4b716","modified":1511120593040},{"_id":"public/images/icons/apple-icon-precomposed.png","hash":"917d2446777005ee46a7eece1b8fde0a93b4b716","modified":1511120593040},{"_id":"public/images/icons/favicon-29x29.png","hash":"dec7cc0ed907bb386873ffc52c841b55c27c0689","modified":1511120593040},{"_id":"public/images/icons/favicon-87x87.png","hash":"dec7cc0ed907bb386873ffc52c841b55c27c0689","modified":1511120593040},{"_id":"public/images/icons/ms-icon-144x144.png","hash":"92e055a07a4d1a8fbe5f0e9c5cadd70bf05633e2","modified":1511120593041},{"_id":"public/images/icons/favicon.png","hash":"e7d4305815b6a71d89ebba10de091b5c95c203e5","modified":1511120593041},{"_id":"public/images/icons/ms-icon-150x150.png","hash":"3e5e7a009e8d3ee7d9f2b0c19aa7cbf53e55a056","modified":1511120593041},{"_id":"public/images/icons/ms-icon-70x70.png","hash":"c05475c34a9cd2749406dfa840a438c71cf7f3f7","modified":1511120593041},{"_id":"public/images/icons/ms-icon-310x310.png","hash":"57719fdbcbb8ed3f1b6312b960068d2ad4384a17","modified":1511120593041},{"_id":"public/images/hero-logo.png","hash":"95dc45fe069394897ae89b7ece9774fde4da3200","modified":1511120593339},{"_id":"public/css/benchmark.css","hash":"3424ee8c27052da2ab9f544027f49e1550385e9d","modified":1511120593346},{"_id":"public/manifest.json","hash":"c19a0c28fdc9a730ca10604ee4080cc105ddd8bb","modified":1511120593346},{"_id":"public/css/index.css","hash":"4659419ffed5a9e7a85b8621b8b18c5f12c2bd99","modified":1511120593346},{"_id":"public/css/search.css","hash":"ac9a0e8c8da7919174caea15d9704c192ea3a2c4","modified":1511120593346},{"_id":"public/js/css.escape.js","hash":"1d0e28a08261de3955b0ee18432e304c1f468441","modified":1511120593346},{"_id":"public/js/common.js","hash":"9ad4e1f2e06a8f73829b27eadeec6b05850b3dbe","modified":1511120593346},{"_id":"public/js/smooth-scroll.min.js","hash":"48d800d2b3be86c704e002502999413504bbd04d","modified":1511120593347},{"_id":"public/css/page.css","hash":"9176a7d644860a17477924d4484b4b0bf20281e4","modified":1511120593347},{"_id":"public/js/vue.min.js","hash":"4e7761d6f9f23ba54b529e048d20f93b04ce1af0","modified":1511120593347},{"_id":"public/js/vue.js","hash":"8e482e1719c0ece3864b45d772d42dc203c6d999","modified":1511120593347}],"Category":[],"Data":[],"Page":[{"index":true,"_content":"","source":"index.md","raw":"index: true\n---\n","date":"2017-06-11T19:37:11.000Z","updated":"2017-06-11T19:28:10.000Z","path":"index.html","title":"","comments":1,"layout":"page","_id":"cj5dg8qq60000h6pwi16gdzbg","content":"","excerpt":"","more":""},{"_content":"# Support Cement Development\n\nThe Cement Framework is Open Source and released under the <a href=\"https://opensource.org/licenses/BSD-3-Clause\" target=\"_blank\">3-Clause BSD License</a>, making it completely free to use.  As with any open source project, a tremendous amount of time and effort is required in order to properly maintain current versions, and to make future versions and features possible.\n\nAny contribution is greatly appreciated, whether it be a simple email to say \"thank you\", a nice bottle of liquor, or by a financial commitment.  You can support the development of Cement by way of a one-time gift through [PayPal](https://paypal.me/datafolklabs), or a monthly sponsorship via [Patreon](https://www.patreon.com/datafolklabs).  \n","source":"backers/index.md","raw":"# Support Cement Development\n\nThe Cement Framework is Open Source and released under the <a href=\"https://opensource.org/licenses/BSD-3-Clause\" target=\"_blank\">3-Clause BSD License</a>, making it completely free to use.  As with any open source project, a tremendous amount of time and effort is required in order to properly maintain current versions, and to make future versions and features possible.\n\nAny contribution is greatly appreciated, whether it be a simple email to say \"thank you\", a nice bottle of liquor, or by a financial commitment.  You can support the development of Cement by way of a one-time gift through [PayPal](https://paypal.me/datafolklabs), or a monthly sponsorship via [Patreon](https://www.patreon.com/datafolklabs).  \n","date":"2017-06-24T22:00:23.000Z","updated":"2017-06-24T22:00:23.000Z","path":"backers/index.html","title":"","comments":1,"layout":"page","_id":"cj5dg8qqx0002h6pwzu0fxrax","content":"<h1 id=\"Support-Cement-Development\"><a href=\"#Support-Cement-Development\" class=\"headerlink\" title=\"Support Cement Development\"></a>Support Cement Development</h1><p>The Cement Framework is Open Source and released under the <a href=\"https://opensource.org/licenses/BSD-3-Clause\" target=\"_blank\">3-Clause BSD License</a>, making it completely free to use.  As with any open source project, a tremendous amount of time and effort is required in order to properly maintain current versions, and to make future versions and features possible.</p>\n<p>Any contribution is greatly appreciated, whether it be a simple email to say “thank you”, a nice bottle of liquor, or by a financial commitment.  You can support the development of Cement by way of a one-time gift through <a href=\"https://paypal.me/datafolklabs\" target=\"_blank\" rel=\"external\">PayPal</a>, or a monthly sponsorship via <a href=\"https://www.patreon.com/datafolklabs\" target=\"_blank\" rel=\"external\">Patreon</a>.  </p>\n","excerpt":"","more":"<h1 id=\"Support-Cement-Development\"><a href=\"#Support-Cement-Development\" class=\"headerlink\" title=\"Support Cement Development\"></a>Support Cement Development</h1><p>The Cement Framework is Open Source and released under the <a href=\"https://opensource.org/licenses/BSD-3-Clause\" target=\"_blank\">3-Clause BSD License</a>, making it completely free to use.  As with any open source project, a tremendous amount of time and effort is required in order to properly maintain current versions, and to make future versions and features possible.</p>\n<p>Any contribution is greatly appreciated, whether it be a simple email to say “thank you”, a nice bottle of liquor, or by a financial commitment.  You can support the development of Cement by way of a one-time gift through <a href=\"https://paypal.me/datafolklabs\">PayPal</a>, or a monthly sponsorship via <a href=\"https://www.patreon.com/datafolklabs\">Patreon</a>.  </p>\n"},{"type":"menu","_content":"","source":"menu/index.md","raw":"---\ntype: menu\n---\n","date":"2017-06-11T19:37:11.000Z","updated":"2017-06-11T19:28:10.000Z","path":"menu/index.html","title":"","comments":1,"layout":"page","_id":"cj5dg8qrj0004h6pwbosf61tw","content":"","excerpt":"","more":""},{"_content":"# Subscribe for Email Updates\n\nSign up for the Cement Framework mailing list to recieve updates regarding new releases, important features, and other related news.  This not an open email thread, but rather an extremely minimal, low noise announcement only list.  You can unsubscribe at any time.\n\n<!-- Begin MailChimp Signup Form -->\n  <link href=\"http://cdn-images.mailchimp.com/embedcode/slim-081711.css\" rel=\"stylesheet\" type=\"text/css\">\n  <style type=\"text/css\">\n    #mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; }\n    /* Add your own MailChimp form style overrides in your site stylesheet or in this style block.\n       We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */\n  </style>\n  <div id=\"mc_embed_signup\">\n  <form action=\"http://datafolklabs.us7.list-manage.com/subscribe/post?u=444ce23fdf1c30e830f893b57&amp;id=7be3a6a31e\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\n      <div id=\"mc_embed_signup_scroll\">\n        <input type=\"email\" value=\"\" name=\"EMAIL\" class=\"email\" id=\"mce-EMAIL\" placeholder=\"email address\" required>\n        <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\n        <div style=\"position: absolute; left: -5000px;\"><input type=\"text\" name=\"b_444ce23fdf1c30e830f893b57_7be3a6a31e\" tabindex=\"-1\" value=\"\"></div>\n        <div class=\"clear\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\n      </div>\n  </form>\n  </div>\n<!-- End MailChimp Signup Form -->\n","source":"mailing-list/index.md","raw":"# Subscribe for Email Updates\n\nSign up for the Cement Framework mailing list to recieve updates regarding new releases, important features, and other related news.  This not an open email thread, but rather an extremely minimal, low noise announcement only list.  You can unsubscribe at any time.\n\n<!-- Begin MailChimp Signup Form -->\n  <link href=\"http://cdn-images.mailchimp.com/embedcode/slim-081711.css\" rel=\"stylesheet\" type=\"text/css\">\n  <style type=\"text/css\">\n    #mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; }\n    /* Add your own MailChimp form style overrides in your site stylesheet or in this style block.\n       We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */\n  </style>\n  <div id=\"mc_embed_signup\">\n  <form action=\"http://datafolklabs.us7.list-manage.com/subscribe/post?u=444ce23fdf1c30e830f893b57&amp;id=7be3a6a31e\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate>\n      <div id=\"mc_embed_signup_scroll\">\n        <input type=\"email\" value=\"\" name=\"EMAIL\" class=\"email\" id=\"mce-EMAIL\" placeholder=\"email address\" required>\n        <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\n        <div style=\"position: absolute; left: -5000px;\"><input type=\"text\" name=\"b_444ce23fdf1c30e830f893b57_7be3a6a31e\" tabindex=\"-1\" value=\"\"></div>\n        <div class=\"clear\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div>\n      </div>\n  </form>\n  </div>\n<!-- End MailChimp Signup Form -->\n","date":"2017-06-26T02:10:09.000Z","updated":"2017-06-26T02:10:09.000Z","path":"mailing-list/index.html","title":"","comments":1,"layout":"page","_id":"cj5dg8qrn0005h6pw713h77z6","content":"<h1 id=\"Subscribe-for-Email-Updates\"><a href=\"#Subscribe-for-Email-Updates\" class=\"headerlink\" title=\"Subscribe for Email Updates\"></a>Subscribe for Email Updates</h1><p>Sign up for the Cement Framework mailing list to recieve updates regarding new releases, important features, and other related news.  This not an open email thread, but rather an extremely minimal, low noise announcement only list.  You can unsubscribe at any time.</p>\n<!-- Begin MailChimp Signup Form -->\n<p>  <link href=\"http://cdn-images.mailchimp.com/embedcode/slim-081711.css\" rel=\"stylesheet\" type=\"text/css\"><br>  <style type=\"text/css\"></p>\n<pre><code>#mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; }\n/* Add your own MailChimp form style overrides in your site stylesheet or in this style block.\n   We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */\n</code></pre><p>  </style><br>  <div id=\"mc_embed_signup\"><br>  <form action=\"http://datafolklabs.us7.list-manage.com/subscribe/post?u=444ce23fdf1c30e830f893b57&amp;id=7be3a6a31e\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate=\"\"><br>      <div id=\"mc_embed_signup_scroll\"><br>        <input type=\"email\" value=\"\" name=\"EMAIL\" class=\"email\" id=\"mce-EMAIL\" placeholder=\"email address\" required><br>        <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups--><br>        <div style=\"position: absolute; left: -5000px;\"><input type=\"text\" name=\"b_444ce23fdf1c30e830f893b57_7be3a6a31e\" tabindex=\"-1\" value=\"\"></div><br>        <div class=\"clear\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div><br>      </div><br>  </form><br>  </div><br><!-- End MailChimp Signup Form --></p>\n","excerpt":"","more":"<h1 id=\"Subscribe-for-Email-Updates\"><a href=\"#Subscribe-for-Email-Updates\" class=\"headerlink\" title=\"Subscribe for Email Updates\"></a>Subscribe for Email Updates</h1><p>Sign up for the Cement Framework mailing list to recieve updates regarding new releases, important features, and other related news.  This not an open email thread, but rather an extremely minimal, low noise announcement only list.  You can unsubscribe at any time.</p>\n<!-- Begin MailChimp Signup Form -->\n<p>  <link href=\"http://cdn-images.mailchimp.com/embedcode/slim-081711.css\" rel=\"stylesheet\" type=\"text/css\"><br>  <style type=\"text/css\"></p>\n<pre><code>#mc_embed_signup{background:#fff; clear:left; font:14px Helvetica,Arial,sans-serif; }\n/* Add your own MailChimp form style overrides in your site stylesheet or in this style block.\n   We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */\n</code></pre><p>  </style><br>  <div id=\"mc_embed_signup\"><br>  <form action=\"http://datafolklabs.us7.list-manage.com/subscribe/post?u=444ce23fdf1c30e830f893b57&amp;id=7be3a6a31e\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate><br>      <div id=\"mc_embed_signup_scroll\"><br>        <input type=\"email\" value=\"\" name=\"EMAIL\" class=\"email\" id=\"mce-EMAIL\" placeholder=\"email address\" required><br>        <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups--><br>        <div style=\"position: absolute; left: -5000px;\"><input type=\"text\" name=\"b_444ce23fdf1c30e830f893b57_7be3a6a31e\" tabindex=\"-1\" value=\"\"></div><br>        <div class=\"clear\"><input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\"></div><br>      </div><br>  </form><br>  </div><br><!-- End MailChimp Signup Form --></p>\n"},{"title":"Configuration Files and Settings","type":"guide","version":"2.10","order":5,"_content":"\nCement defines a configuration interface called [IConfig](/2.10/api/core/config.html), as well as the default [ConfigParserConfigHandler](/2.10/api/ext/ext_configparser) that implements the interface.  This handler is built on top of [ConfigParser](http://docs.python.org/library/configparser.html) which is included in the Python standard library.  Therefor, this class will work much like ConfigParser but with any added functions necessary to meet the requirements of the `IConfig` interface.\n\nPlease note that there are other handlers that implement the `IConfig` interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.\n\nThe following config handlers are included and maintained with Cement:\n\n- [ConfigParserConfigHandler](/2.10/api/ext/ext_configparser.html) *(default)*\n- [ConfigObjConfigHandler](/2.10/api/ext/ext_configobj.html)\n- [JsonConfigHandler](/2.10/api/ext/ext_json.html)\n- [JsonConfigObjConfigHandler](/2.10/api/ext/ext_json_configobj.html)\n- [YamlConfigHandler](/2.10/api/ext/ext_yaml.html)\n- [YamlConfigObjHandler](/2.10/api/ext/ext_yaml_configobj.html)\n\n\nPlease reference the [IConfig](/2.10/api/core/config) interface documentation for writing your own config handler.\n\n\n## Configuration Load Order\n\nAn applications configuration is made up of a number of things, including default settings, handler defaults, config file settings, etc.  The following is the order in which configurations are discovered and loaded:\n\n- Defaults defined in `CementApp.Meta.config_defaults` or passed as `config_defaults` keyword to `CementApp`\n- Extended by `CementBaseHandler.Meta.config_defaults` (not overridden)\n- Overridden by configuration files defined in `CementApp.Meta.config_files` in the order they are listed/loaded (last has precedence)\n- Overridden by command line options that match the same key name (only if `CementApp.Meta.arguments_override_config == True` or if the argument name is listed in `CementApp.Meta.override_arguments`)\n\n\n## Application Default Settings\n\nCement does not require default config settings in order to operate.  That said, these settings are found under the `app_label` application section of the configuration, and overridden by a `[<app_label>]` block from a configuration file.\n\nA default dictionary is used if no other defaults are passed when creating an application.  For example, the following:\n\n```python\nfrom cement.core import foundation\napp = foundation.CementApp('myapp')\n```\n\nIs equivalent to:\n\n```python\nfrom cement.core import foundation\nfrom cement.utils.misc import init_defaults\n\ndefaults = init_defaults('myapp')\napp = foundation.CementApp('myapp', config_defaults=defaults)\n```\n\nThat said, you can override default settings or add your own defaults like so:\n\n```python\nfrom cement.core import foundation\nfrom cement.utils.misc import init_defaults\n\ndefaults = init_defaults('myapp', 'section1','section2')\ndefaults['section1']['foo'] = 'bar'\ndefaults['section2']['foo2'] = 'bar2'\n\napp = foundation.CementApp('myapp', config_defaults=defaults)\n```\n\nIt is important to note that the default settings, which is a dict, is parsed by the config handler and loaded into it's own configuration mechanism. Meaning, though some config handlers (i.e. `ConfigObjConfigHandler`) might also be accessible like a dict, not all do (i.e. `ConfigParserConfigHandler`).  Please see the documentation for the config handler you use for their full usage when accessing the `app.config` object.\n\n### Built-in Defaults\n\nThe following are not required to exist in the config defaults, however if they do, Cement will honor them (overriding or appending to built-in defaults).\n\n- **debug = `False`** - Toggles debug output.  By default, this setting is also overridden by the `[<app_label>] -> debug` config setting parsed in any of the application configuration files.\n- **ignore_deprecation_warnings = `False`** - Disable deprecation warnings from being logged by Cement.\n- **extensions = `None`** - List of additional framework extensions to load.  Any extensions defined here will be appended to the application's defined extensions.\n- **plugin_config_dir = `None`** - A directory path where plugin config files can be found.  Files must end in `.conf`.  By default, this setting is also overridden by the `[<app_label>] -> plugin_config_dir` config setting parsed in any of the application configuration files.\n  - If set, this item will be **appended** to `CementApp.Meta.plugin_config_dirs` so that it's settings will have presedence over other config files.\n  - In general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a `plugin_config_dir` without completely trumping the hard-coded list of default `plugin_config_dirs` defined by the app/developer.\n- **plugin_dir = `None`** - A directory path where plugin code (modules) can be loaded from. By default, this setting is also overridden by the `[<app_label>] -> plugin_dir` config setting parsed in any of the application configuration files.\n  - If set, this item will be **prepended** to `CementApp.Meta.plugin_dirs` so that a user's defined `plugin_dir` has precedence over other `plugin_dirs`.\n  - In general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a `plugin_dir` without completely trumping the hard-coded list of default `plugin_dirs` defined by the app/developer.\n- **template_dir = `None`** - A directory path where template files can be loaded from.  By default, this setting is also overridden by the `[<app_label>] -> template_dir` config setting parsed in any of the application configuration files.\n  - If set, this item will be appended to `CementApp.Meta.template_dirs`.\n  - In general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a `template_dir` without completely trumping the hard-coded list of default `template_dirs` defined by the app/developer.\n\n\n## Application Defaults vs Handler Defaults\n\nThere may be slight confusion between the `CementApp.Meta.config_defaults` and the `CementBaseHandler.Meta.config_defaults` options.  They both are very similar, however the application level configuration defaults are intended to be used to set defaults for multiple sections.  Therefore, the `CementApp.Meta.config_defaults` option is a `dict` with nested `dict`'s under it.  Each key of the top level `dict` relates to a config `[section]` and the nested `dict` are the settings for that `[section]`.\n\nThe `CementBaseHandler.Meta.config_defaults` only partain to a single `[section]` and therefor is only a single level `dict`, whose settings are applied to the `CementBaseHandler.Meta.config_section` of the application's configuration.\n\n\n## Accessing Configuration Settings\n\nAfter application creation and setup, you can access the config handler via the `app.config` object.  For example:\n\n```python\nfrom cement.core import foundation\napp = foundation.CementApp('myapp')\n\n# First setup the application\napp.setup()\n\n# Get settings\napp.config.get('myapp', 'debug')\n\n# Set settings\napp.config.set('myapp', 'debug', True)\n\n# Get sections (configuration [blocks])\napp.config.get_sections()\n\n# Add a section\napp.config.add_section('my_config_section')\n\n# Test if a section exists\napp.config.has_section('my_config_section')\n\n# Get configuration keys for the 'myapp' section\napp.config.keys('myapp')\n\n# Test if a key exist\nif 'debug' in app.config.keys('myapp')\n\n# Merge a dict of settings into the config\nother_config = dict()\nother_config['myapp'] = dict()\nother_config['myapp']['foo'] = 'not bar'\napp.config.merge(other_config)\n```\n\n\n## Parsing Config Files\n\nMost applications benefit from allowing their users to customize runtime via a configuration file.  This can be done by:\n\n```python\nfrom cement.core import foundation\napp = foundation.CementApp('myapp')\n\n# First setup the application\napp.setup()\n\n# Parse a configuration file\napp.config.parse_file('/path/to/some/file.conf')\n```\n\nNote that Cement automatically parses any config files listed in the `CementApp.Meta.config_files` list.  For example:\n\n```python\nfrom cement.core import foundation, backend\n\napp = foundation.CementApp('myapp',\n        config_files = [\n            '/path/to/config1',\n            '/path/to/config2'\n            ],\n        )\n```\n\nIf no `config_files` meta is provided, Cement will set the defaults to the following common and sane defaults:\n\n- `/etc/<app_label>/<app_label>.conf`\n- `~/.<app_label>.conf`\n- `~/.<app_label>/config`\n\n\n## Overriding Configurations with Command Line Options\n\nConfig settings can **optionally** overridden by a passed command line option if the option name matches a configuration key.  Note that this will happen in *all* config sections if enabled:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.utils.misc import init_defaults\n\ndefaults = init_defaults('myapp')\ndefaults['myapp']['foo'] = 'bar'\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        config_defaults = defaults\n        arguments_override_config = True\n\nwith MyApp() as app:\n    app.args.add_argument('--foo', action='store', dest='foo')\n    app.run()\n```\n\n\nWith `arguments_override_config` enabled, running the above application and passing the `--foo=some_value` option will override the `foo` setting under a `[myapp]` configuration section as well as any other section that has a matching `foo` key.\n\n\n## Configuration Options Versus Meta Options\n\nAs you will see extensively throughout the Cement code is the use of Meta options.  There can be some confusion between the use of Meta options, and application configuration options.  The following explains the two:\n\n\n**Configuration Options**\n\nConfiguration options are application specific.  There are config defaults defined by the application developer, that can be (and are intended to be) overridden by user defined settings in a configuration file.\n\nCement does not rely on the application configuration, though it can honor configuration settings.  For example, `CementApp` honors the `debug` config option which is documented, but it doesn't rely on it existing either.\n\nThe key things to note about configuration options are:\n\n- They give the end user flexibility in how the application operates.\n- Anything that you want users to be able to customize via a config file. For example, the path to a log file or the location of a database server. These are things that you do not want hard-coded into your app, but rather might want sane defaults for.\n\n\n**Meta Options**\n\nMeta options are used on the backend by developers to alter how classes operate.  For example, the `CementApp` class has a meta option of `log_handler`.  The default log handler is `LoggingLogHandler`, however because this is built on an interface definition, Cement can use any other log handler the same way without issue as long as that log handler abides by the interface definition.  Meta options make this change seamless and allows the handler to alter functionality, rather than having to change code in the top level class itself.\n\nThe key thing to note about Meta options are:\n\n- They give the developer flexibility in how the code operates.\n- End users should not have access to modify Meta options via a config file or similar 'dynamic' configuration (unless those specific options are listed in `CementApp.Meta.core_meta_override` or `CementApp.Meta.meta_override` (for example, the `debug` setting under `[<app_label>]` overrides `CementApp.Meta.debug` by default.\n- Meta options are used to alter how classes work, however are considered 'hard-coded' settings.  If the developer chooses to alter a Meta option, it is for the life of that release.\n- Meta options should have a sane default, and be clearly documented.\n","source":"2.10/dev/configuration.md","raw":"---\ntitle: Configuration Files and Settings\ntype: guide\nversion: \"2.10\"\norder: 5\n---\n\nCement defines a configuration interface called [IConfig](/2.10/api/core/config.html), as well as the default [ConfigParserConfigHandler](/2.10/api/ext/ext_configparser) that implements the interface.  This handler is built on top of [ConfigParser](http://docs.python.org/library/configparser.html) which is included in the Python standard library.  Therefor, this class will work much like ConfigParser but with any added functions necessary to meet the requirements of the `IConfig` interface.\n\nPlease note that there are other handlers that implement the `IConfig` interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.\n\nThe following config handlers are included and maintained with Cement:\n\n- [ConfigParserConfigHandler](/2.10/api/ext/ext_configparser.html) *(default)*\n- [ConfigObjConfigHandler](/2.10/api/ext/ext_configobj.html)\n- [JsonConfigHandler](/2.10/api/ext/ext_json.html)\n- [JsonConfigObjConfigHandler](/2.10/api/ext/ext_json_configobj.html)\n- [YamlConfigHandler](/2.10/api/ext/ext_yaml.html)\n- [YamlConfigObjHandler](/2.10/api/ext/ext_yaml_configobj.html)\n\n\nPlease reference the [IConfig](/2.10/api/core/config) interface documentation for writing your own config handler.\n\n\n## Configuration Load Order\n\nAn applications configuration is made up of a number of things, including default settings, handler defaults, config file settings, etc.  The following is the order in which configurations are discovered and loaded:\n\n- Defaults defined in `CementApp.Meta.config_defaults` or passed as `config_defaults` keyword to `CementApp`\n- Extended by `CementBaseHandler.Meta.config_defaults` (not overridden)\n- Overridden by configuration files defined in `CementApp.Meta.config_files` in the order they are listed/loaded (last has precedence)\n- Overridden by command line options that match the same key name (only if `CementApp.Meta.arguments_override_config == True` or if the argument name is listed in `CementApp.Meta.override_arguments`)\n\n\n## Application Default Settings\n\nCement does not require default config settings in order to operate.  That said, these settings are found under the `app_label` application section of the configuration, and overridden by a `[<app_label>]` block from a configuration file.\n\nA default dictionary is used if no other defaults are passed when creating an application.  For example, the following:\n\n```python\nfrom cement.core import foundation\napp = foundation.CementApp('myapp')\n```\n\nIs equivalent to:\n\n```python\nfrom cement.core import foundation\nfrom cement.utils.misc import init_defaults\n\ndefaults = init_defaults('myapp')\napp = foundation.CementApp('myapp', config_defaults=defaults)\n```\n\nThat said, you can override default settings or add your own defaults like so:\n\n```python\nfrom cement.core import foundation\nfrom cement.utils.misc import init_defaults\n\ndefaults = init_defaults('myapp', 'section1','section2')\ndefaults['section1']['foo'] = 'bar'\ndefaults['section2']['foo2'] = 'bar2'\n\napp = foundation.CementApp('myapp', config_defaults=defaults)\n```\n\nIt is important to note that the default settings, which is a dict, is parsed by the config handler and loaded into it's own configuration mechanism. Meaning, though some config handlers (i.e. `ConfigObjConfigHandler`) might also be accessible like a dict, not all do (i.e. `ConfigParserConfigHandler`).  Please see the documentation for the config handler you use for their full usage when accessing the `app.config` object.\n\n### Built-in Defaults\n\nThe following are not required to exist in the config defaults, however if they do, Cement will honor them (overriding or appending to built-in defaults).\n\n- **debug = `False`** - Toggles debug output.  By default, this setting is also overridden by the `[<app_label>] -> debug` config setting parsed in any of the application configuration files.\n- **ignore_deprecation_warnings = `False`** - Disable deprecation warnings from being logged by Cement.\n- **extensions = `None`** - List of additional framework extensions to load.  Any extensions defined here will be appended to the application's defined extensions.\n- **plugin_config_dir = `None`** - A directory path where plugin config files can be found.  Files must end in `.conf`.  By default, this setting is also overridden by the `[<app_label>] -> plugin_config_dir` config setting parsed in any of the application configuration files.\n  - If set, this item will be **appended** to `CementApp.Meta.plugin_config_dirs` so that it's settings will have presedence over other config files.\n  - In general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a `plugin_config_dir` without completely trumping the hard-coded list of default `plugin_config_dirs` defined by the app/developer.\n- **plugin_dir = `None`** - A directory path where plugin code (modules) can be loaded from. By default, this setting is also overridden by the `[<app_label>] -> plugin_dir` config setting parsed in any of the application configuration files.\n  - If set, this item will be **prepended** to `CementApp.Meta.plugin_dirs` so that a user's defined `plugin_dir` has precedence over other `plugin_dirs`.\n  - In general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a `plugin_dir` without completely trumping the hard-coded list of default `plugin_dirs` defined by the app/developer.\n- **template_dir = `None`** - A directory path where template files can be loaded from.  By default, this setting is also overridden by the `[<app_label>] -> template_dir` config setting parsed in any of the application configuration files.\n  - If set, this item will be appended to `CementApp.Meta.template_dirs`.\n  - In general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a `template_dir` without completely trumping the hard-coded list of default `template_dirs` defined by the app/developer.\n\n\n## Application Defaults vs Handler Defaults\n\nThere may be slight confusion between the `CementApp.Meta.config_defaults` and the `CementBaseHandler.Meta.config_defaults` options.  They both are very similar, however the application level configuration defaults are intended to be used to set defaults for multiple sections.  Therefore, the `CementApp.Meta.config_defaults` option is a `dict` with nested `dict`'s under it.  Each key of the top level `dict` relates to a config `[section]` and the nested `dict` are the settings for that `[section]`.\n\nThe `CementBaseHandler.Meta.config_defaults` only partain to a single `[section]` and therefor is only a single level `dict`, whose settings are applied to the `CementBaseHandler.Meta.config_section` of the application's configuration.\n\n\n## Accessing Configuration Settings\n\nAfter application creation and setup, you can access the config handler via the `app.config` object.  For example:\n\n```python\nfrom cement.core import foundation\napp = foundation.CementApp('myapp')\n\n# First setup the application\napp.setup()\n\n# Get settings\napp.config.get('myapp', 'debug')\n\n# Set settings\napp.config.set('myapp', 'debug', True)\n\n# Get sections (configuration [blocks])\napp.config.get_sections()\n\n# Add a section\napp.config.add_section('my_config_section')\n\n# Test if a section exists\napp.config.has_section('my_config_section')\n\n# Get configuration keys for the 'myapp' section\napp.config.keys('myapp')\n\n# Test if a key exist\nif 'debug' in app.config.keys('myapp')\n\n# Merge a dict of settings into the config\nother_config = dict()\nother_config['myapp'] = dict()\nother_config['myapp']['foo'] = 'not bar'\napp.config.merge(other_config)\n```\n\n\n## Parsing Config Files\n\nMost applications benefit from allowing their users to customize runtime via a configuration file.  This can be done by:\n\n```python\nfrom cement.core import foundation\napp = foundation.CementApp('myapp')\n\n# First setup the application\napp.setup()\n\n# Parse a configuration file\napp.config.parse_file('/path/to/some/file.conf')\n```\n\nNote that Cement automatically parses any config files listed in the `CementApp.Meta.config_files` list.  For example:\n\n```python\nfrom cement.core import foundation, backend\n\napp = foundation.CementApp('myapp',\n        config_files = [\n            '/path/to/config1',\n            '/path/to/config2'\n            ],\n        )\n```\n\nIf no `config_files` meta is provided, Cement will set the defaults to the following common and sane defaults:\n\n- `/etc/<app_label>/<app_label>.conf`\n- `~/.<app_label>.conf`\n- `~/.<app_label>/config`\n\n\n## Overriding Configurations with Command Line Options\n\nConfig settings can **optionally** overridden by a passed command line option if the option name matches a configuration key.  Note that this will happen in *all* config sections if enabled:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.utils.misc import init_defaults\n\ndefaults = init_defaults('myapp')\ndefaults['myapp']['foo'] = 'bar'\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        config_defaults = defaults\n        arguments_override_config = True\n\nwith MyApp() as app:\n    app.args.add_argument('--foo', action='store', dest='foo')\n    app.run()\n```\n\n\nWith `arguments_override_config` enabled, running the above application and passing the `--foo=some_value` option will override the `foo` setting under a `[myapp]` configuration section as well as any other section that has a matching `foo` key.\n\n\n## Configuration Options Versus Meta Options\n\nAs you will see extensively throughout the Cement code is the use of Meta options.  There can be some confusion between the use of Meta options, and application configuration options.  The following explains the two:\n\n\n**Configuration Options**\n\nConfiguration options are application specific.  There are config defaults defined by the application developer, that can be (and are intended to be) overridden by user defined settings in a configuration file.\n\nCement does not rely on the application configuration, though it can honor configuration settings.  For example, `CementApp` honors the `debug` config option which is documented, but it doesn't rely on it existing either.\n\nThe key things to note about configuration options are:\n\n- They give the end user flexibility in how the application operates.\n- Anything that you want users to be able to customize via a config file. For example, the path to a log file or the location of a database server. These are things that you do not want hard-coded into your app, but rather might want sane defaults for.\n\n\n**Meta Options**\n\nMeta options are used on the backend by developers to alter how classes operate.  For example, the `CementApp` class has a meta option of `log_handler`.  The default log handler is `LoggingLogHandler`, however because this is built on an interface definition, Cement can use any other log handler the same way without issue as long as that log handler abides by the interface definition.  Meta options make this change seamless and allows the handler to alter functionality, rather than having to change code in the top level class itself.\n\nThe key thing to note about Meta options are:\n\n- They give the developer flexibility in how the code operates.\n- End users should not have access to modify Meta options via a config file or similar 'dynamic' configuration (unless those specific options are listed in `CementApp.Meta.core_meta_override` or `CementApp.Meta.meta_override` (for example, the `debug` setting under `[<app_label>]` overrides `CementApp.Meta.debug` by default.\n- Meta options are used to alter how classes work, however are considered 'hard-coded' settings.  If the developer chooses to alter a Meta option, it is for the life of that release.\n- Meta options should have a sane default, and be clearly documented.\n","date":"2017-06-26T03:09:33.000Z","updated":"2017-06-26T03:09:33.000Z","path":"2.10/dev/configuration.html","comments":1,"layout":"page","_id":"cj5dg8qru0006h6pwr9u27596","content":"<p>Cement defines a configuration interface called <a href=\"/2.10/api/core/config.html\">IConfig</a>, as well as the default <a href=\"/2.10/api/ext/ext_configparser\">ConfigParserConfigHandler</a> that implements the interface.  This handler is built on top of <a href=\"http://docs.python.org/library/configparser.html\" target=\"_blank\" rel=\"external\">ConfigParser</a> which is included in the Python standard library.  Therefor, this class will work much like ConfigParser but with any added functions necessary to meet the requirements of the <code>IConfig</code> interface.</p>\n<p>Please note that there are other handlers that implement the <code>IConfig</code> interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.</p>\n<p>The following config handlers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/ext/ext_configparser.html\">ConfigParserConfigHandler</a> <em>(default)</em></li>\n<li><a href=\"/2.10/api/ext/ext_configobj.html\">ConfigObjConfigHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_json.html\">JsonConfigHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_json_configobj.html\">JsonConfigObjConfigHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_yaml.html\">YamlConfigHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_yaml_configobj.html\">YamlConfigObjHandler</a></li>\n</ul>\n<p>Please reference the <a href=\"/2.10/api/core/config\">IConfig</a> interface documentation for writing your own config handler.</p>\n<h2 id=\"Configuration-Load-Order\"><a href=\"#Configuration-Load-Order\" class=\"headerlink\" title=\"Configuration Load Order\"></a>Configuration Load Order</h2><p>An applications configuration is made up of a number of things, including default settings, handler defaults, config file settings, etc.  The following is the order in which configurations are discovered and loaded:</p>\n<ul>\n<li>Defaults defined in <code>CementApp.Meta.config_defaults</code> or passed as <code>config_defaults</code> keyword to <code>CementApp</code></li>\n<li>Extended by <code>CementBaseHandler.Meta.config_defaults</code> (not overridden)</li>\n<li>Overridden by configuration files defined in <code>CementApp.Meta.config_files</code> in the order they are listed/loaded (last has precedence)</li>\n<li>Overridden by command line options that match the same key name (only if <code>CementApp.Meta.arguments_override_config == True</code> or if the argument name is listed in <code>CementApp.Meta.override_arguments</code>)</li>\n</ul>\n<h2 id=\"Application-Default-Settings\"><a href=\"#Application-Default-Settings\" class=\"headerlink\" title=\"Application Default Settings\"></a>Application Default Settings</h2><p>Cement does not require default config settings in order to operate.  That said, these settings are found under the <code>app_label</code> application section of the configuration, and overridden by a <code>[&lt;app_label&gt;]</code> block from a configuration file.</p>\n<p>A default dictionary is used if no other defaults are passed when creating an application.  For example, the following:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>)</div></pre></td></tr></table></figure>\n<p>Is equivalent to:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>)</div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>, config_defaults=defaults)</div></pre></td></tr></table></figure>\n<p>That said, you can override default settings or add your own defaults like so:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>, <span class=\"string\">'section1'</span>,<span class=\"string\">'section2'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'section1'</span>][<span class=\"string\">'foo'</span>] = <span class=\"string\">'bar'</span></div><div class=\"line\">defaults[<span class=\"string\">'section2'</span>][<span class=\"string\">'foo2'</span>] = <span class=\"string\">'bar2'</span></div><div class=\"line\"></div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>, config_defaults=defaults)</div></pre></td></tr></table></figure>\n<p>It is important to note that the default settings, which is a dict, is parsed by the config handler and loaded into it’s own configuration mechanism. Meaning, though some config handlers (i.e. <code>ConfigObjConfigHandler</code>) might also be accessible like a dict, not all do (i.e. <code>ConfigParserConfigHandler</code>).  Please see the documentation for the config handler you use for their full usage when accessing the <code>app.config</code> object.</p>\n<h3 id=\"Built-in-Defaults\"><a href=\"#Built-in-Defaults\" class=\"headerlink\" title=\"Built-in Defaults\"></a>Built-in Defaults</h3><p>The following are not required to exist in the config defaults, however if they do, Cement will honor them (overriding or appending to built-in defaults).</p>\n<ul>\n<li><strong>debug = <code>False</code></strong> - Toggles debug output.  By default, this setting is also overridden by the <code>[&lt;app_label&gt;] -&gt; debug</code> config setting parsed in any of the application configuration files.</li>\n<li><strong>ignore_deprecation_warnings = <code>False</code></strong> - Disable deprecation warnings from being logged by Cement.</li>\n<li><strong>extensions = <code>None</code></strong> - List of additional framework extensions to load.  Any extensions defined here will be appended to the application’s defined extensions.</li>\n<li><strong>plugin_config_dir = <code>None</code></strong> - A directory path where plugin config files can be found.  Files must end in <code>.conf</code>.  By default, this setting is also overridden by the <code>[&lt;app_label&gt;] -&gt; plugin_config_dir</code> config setting parsed in any of the application configuration files.<ul>\n<li>If set, this item will be <strong>appended</strong> to <code>CementApp.Meta.plugin_config_dirs</code> so that it’s settings will have presedence over other config files.</li>\n<li>In general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a <code>plugin_config_dir</code> without completely trumping the hard-coded list of default <code>plugin_config_dirs</code> defined by the app/developer.</li>\n</ul>\n</li>\n<li><strong>plugin_dir = <code>None</code></strong> - A directory path where plugin code (modules) can be loaded from. By default, this setting is also overridden by the <code>[&lt;app_label&gt;] -&gt; plugin_dir</code> config setting parsed in any of the application configuration files.<ul>\n<li>If set, this item will be <strong>prepended</strong> to <code>CementApp.Meta.plugin_dirs</code> so that a user’s defined <code>plugin_dir</code> has precedence over other <code>plugin_dirs</code>.</li>\n<li>In general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a <code>plugin_dir</code> without completely trumping the hard-coded list of default <code>plugin_dirs</code> defined by the app/developer.</li>\n</ul>\n</li>\n<li><strong>template_dir = <code>None</code></strong> - A directory path where template files can be loaded from.  By default, this setting is also overridden by the <code>[&lt;app_label&gt;] -&gt; template_dir</code> config setting parsed in any of the application configuration files.<ul>\n<li>If set, this item will be appended to <code>CementApp.Meta.template_dirs</code>.</li>\n<li>In general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a <code>template_dir</code> without completely trumping the hard-coded list of default <code>template_dirs</code> defined by the app/developer.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Application-Defaults-vs-Handler-Defaults\"><a href=\"#Application-Defaults-vs-Handler-Defaults\" class=\"headerlink\" title=\"Application Defaults vs Handler Defaults\"></a>Application Defaults vs Handler Defaults</h2><p>There may be slight confusion between the <code>CementApp.Meta.config_defaults</code> and the <code>CementBaseHandler.Meta.config_defaults</code> options.  They both are very similar, however the application level configuration defaults are intended to be used to set defaults for multiple sections.  Therefore, the <code>CementApp.Meta.config_defaults</code> option is a <code>dict</code> with nested <code>dict</code>‘s under it.  Each key of the top level <code>dict</code> relates to a config <code>[section]</code> and the nested <code>dict</code> are the settings for that <code>[section]</code>.</p>\n<p>The <code>CementBaseHandler.Meta.config_defaults</code> only partain to a single <code>[section]</code> and therefor is only a single level <code>dict</code>, whose settings are applied to the <code>CementBaseHandler.Meta.config_section</code> of the application’s configuration.</p>\n<h2 id=\"Accessing-Configuration-Settings\"><a href=\"#Accessing-Configuration-Settings\" class=\"headerlink\" title=\"Accessing Configuration Settings\"></a>Accessing Configuration Settings</h2><p>After application creation and setup, you can access the config handler via the <code>app.config</code> object.  For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># First setup the application</span></div><div class=\"line\">app.setup()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Get settings</span></div><div class=\"line\">app.config.get(<span class=\"string\">'myapp'</span>, <span class=\"string\">'debug'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Set settings</span></div><div class=\"line\">app.config.set(<span class=\"string\">'myapp'</span>, <span class=\"string\">'debug'</span>, <span class=\"keyword\">True</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Get sections (configuration [blocks])</span></div><div class=\"line\">app.config.get_sections()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Add a section</span></div><div class=\"line\">app.config.add_section(<span class=\"string\">'my_config_section'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Test if a section exists</span></div><div class=\"line\">app.config.has_section(<span class=\"string\">'my_config_section'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Get configuration keys for the 'myapp' section</span></div><div class=\"line\">app.config.keys(<span class=\"string\">'myapp'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Test if a key exist</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"string\">'debug'</span> <span class=\"keyword\">in</span> app.config.keys(<span class=\"string\">'myapp'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Merge a dict of settings into the config</span></div><div class=\"line\">other_config = dict()</div><div class=\"line\">other_config[<span class=\"string\">'myapp'</span>] = dict()</div><div class=\"line\">other_config[<span class=\"string\">'myapp'</span>][<span class=\"string\">'foo'</span>] = <span class=\"string\">'not bar'</span></div><div class=\"line\">app.config.merge(other_config)</div></pre></td></tr></table></figure>\n<h2 id=\"Parsing-Config-Files\"><a href=\"#Parsing-Config-Files\" class=\"headerlink\" title=\"Parsing Config Files\"></a>Parsing Config Files</h2><p>Most applications benefit from allowing their users to customize runtime via a configuration file.  This can be done by:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># First setup the application</span></div><div class=\"line\">app.setup()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Parse a configuration file</span></div><div class=\"line\">app.config.parse_file(<span class=\"string\">'/path/to/some/file.conf'</span>)</div></pre></td></tr></table></figure>\n<p>Note that Cement automatically parses any config files listed in the <code>CementApp.Meta.config_files</code> list.  For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation, backend</div><div class=\"line\"></div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>,</div><div class=\"line\">        config_files = [</div><div class=\"line\">            <span class=\"string\">'/path/to/config1'</span>,</div><div class=\"line\">            <span class=\"string\">'/path/to/config2'</span></div><div class=\"line\">            ],</div><div class=\"line\">        )</div></pre></td></tr></table></figure>\n<p>If no <code>config_files</code> meta is provided, Cement will set the defaults to the following common and sane defaults:</p>\n<ul>\n<li><code>/etc/&lt;app_label&gt;/&lt;app_label&gt;.conf</code></li>\n<li><code>~/.&lt;app_label&gt;.conf</code></li>\n<li><code>~/.&lt;app_label&gt;/config</code></li>\n</ul>\n<h2 id=\"Overriding-Configurations-with-Command-Line-Options\"><a href=\"#Overriding-Configurations-with-Command-Line-Options\" class=\"headerlink\" title=\"Overriding Configurations with Command Line Options\"></a>Overriding Configurations with Command Line Options</h2><p>Config settings can <strong>optionally</strong> overridden by a passed command line option if the option name matches a configuration key.  Note that this will happen in <em>all</em> config sections if enabled:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'myapp'</span>][<span class=\"string\">'foo'</span>] = <span class=\"string\">'bar'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        config_defaults = defaults</div><div class=\"line\">        arguments_override_config = <span class=\"keyword\">True</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.args.add_argument(<span class=\"string\">'--foo'</span>, action=<span class=\"string\">'store'</span>, dest=<span class=\"string\">'foo'</span>)</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>With <code>arguments_override_config</code> enabled, running the above application and passing the <code>--foo=some_value</code> option will override the <code>foo</code> setting under a <code>[myapp]</code> configuration section as well as any other section that has a matching <code>foo</code> key.</p>\n<h2 id=\"Configuration-Options-Versus-Meta-Options\"><a href=\"#Configuration-Options-Versus-Meta-Options\" class=\"headerlink\" title=\"Configuration Options Versus Meta Options\"></a>Configuration Options Versus Meta Options</h2><p>As you will see extensively throughout the Cement code is the use of Meta options.  There can be some confusion between the use of Meta options, and application configuration options.  The following explains the two:</p>\n<p><strong>Configuration Options</strong></p>\n<p>Configuration options are application specific.  There are config defaults defined by the application developer, that can be (and are intended to be) overridden by user defined settings in a configuration file.</p>\n<p>Cement does not rely on the application configuration, though it can honor configuration settings.  For example, <code>CementApp</code> honors the <code>debug</code> config option which is documented, but it doesn’t rely on it existing either.</p>\n<p>The key things to note about configuration options are:</p>\n<ul>\n<li>They give the end user flexibility in how the application operates.</li>\n<li>Anything that you want users to be able to customize via a config file. For example, the path to a log file or the location of a database server. These are things that you do not want hard-coded into your app, but rather might want sane defaults for.</li>\n</ul>\n<p><strong>Meta Options</strong></p>\n<p>Meta options are used on the backend by developers to alter how classes operate.  For example, the <code>CementApp</code> class has a meta option of <code>log_handler</code>.  The default log handler is <code>LoggingLogHandler</code>, however because this is built on an interface definition, Cement can use any other log handler the same way without issue as long as that log handler abides by the interface definition.  Meta options make this change seamless and allows the handler to alter functionality, rather than having to change code in the top level class itself.</p>\n<p>The key thing to note about Meta options are:</p>\n<ul>\n<li>They give the developer flexibility in how the code operates.</li>\n<li>End users should not have access to modify Meta options via a config file or similar ‘dynamic’ configuration (unless those specific options are listed in <code>CementApp.Meta.core_meta_override</code> or <code>CementApp.Meta.meta_override</code> (for example, the <code>debug</code> setting under <code>[&lt;app_label&gt;]</code> overrides <code>CementApp.Meta.debug</code> by default.</li>\n<li>Meta options are used to alter how classes work, however are considered ‘hard-coded’ settings.  If the developer chooses to alter a Meta option, it is for the life of that release.</li>\n<li>Meta options should have a sane default, and be clearly documented.</li>\n</ul>\n","excerpt":"","more":"<p>Cement defines a configuration interface called <a href=\"/2.10/api/core/config.html\">IConfig</a>, as well as the default <a href=\"/2.10/api/ext/ext_configparser\">ConfigParserConfigHandler</a> that implements the interface.  This handler is built on top of <a href=\"http://docs.python.org/library/configparser.html\">ConfigParser</a> which is included in the Python standard library.  Therefor, this class will work much like ConfigParser but with any added functions necessary to meet the requirements of the <code>IConfig</code> interface.</p>\n<p>Please note that there are other handlers that implement the <code>IConfig</code> interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.</p>\n<p>The following config handlers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/ext/ext_configparser.html\">ConfigParserConfigHandler</a> <em>(default)</em></li>\n<li><a href=\"/2.10/api/ext/ext_configobj.html\">ConfigObjConfigHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_json.html\">JsonConfigHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_json_configobj.html\">JsonConfigObjConfigHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_yaml.html\">YamlConfigHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_yaml_configobj.html\">YamlConfigObjHandler</a></li>\n</ul>\n<p>Please reference the <a href=\"/2.10/api/core/config\">IConfig</a> interface documentation for writing your own config handler.</p>\n<h2 id=\"Configuration-Load-Order\"><a href=\"#Configuration-Load-Order\" class=\"headerlink\" title=\"Configuration Load Order\"></a>Configuration Load Order</h2><p>An applications configuration is made up of a number of things, including default settings, handler defaults, config file settings, etc.  The following is the order in which configurations are discovered and loaded:</p>\n<ul>\n<li>Defaults defined in <code>CementApp.Meta.config_defaults</code> or passed as <code>config_defaults</code> keyword to <code>CementApp</code></li>\n<li>Extended by <code>CementBaseHandler.Meta.config_defaults</code> (not overridden)</li>\n<li>Overridden by configuration files defined in <code>CementApp.Meta.config_files</code> in the order they are listed/loaded (last has precedence)</li>\n<li>Overridden by command line options that match the same key name (only if <code>CementApp.Meta.arguments_override_config == True</code> or if the argument name is listed in <code>CementApp.Meta.override_arguments</code>)</li>\n</ul>\n<h2 id=\"Application-Default-Settings\"><a href=\"#Application-Default-Settings\" class=\"headerlink\" title=\"Application Default Settings\"></a>Application Default Settings</h2><p>Cement does not require default config settings in order to operate.  That said, these settings are found under the <code>app_label</code> application section of the configuration, and overridden by a <code>[&lt;app_label&gt;]</code> block from a configuration file.</p>\n<p>A default dictionary is used if no other defaults are passed when creating an application.  For example, the following:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>)</div></pre></td></tr></table></figure>\n<p>Is equivalent to:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>)</div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>, config_defaults=defaults)</div></pre></td></tr></table></figure>\n<p>That said, you can override default settings or add your own defaults like so:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>, <span class=\"string\">'section1'</span>,<span class=\"string\">'section2'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'section1'</span>][<span class=\"string\">'foo'</span>] = <span class=\"string\">'bar'</span></div><div class=\"line\">defaults[<span class=\"string\">'section2'</span>][<span class=\"string\">'foo2'</span>] = <span class=\"string\">'bar2'</span></div><div class=\"line\"></div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>, config_defaults=defaults)</div></pre></td></tr></table></figure>\n<p>It is important to note that the default settings, which is a dict, is parsed by the config handler and loaded into it’s own configuration mechanism. Meaning, though some config handlers (i.e. <code>ConfigObjConfigHandler</code>) might also be accessible like a dict, not all do (i.e. <code>ConfigParserConfigHandler</code>).  Please see the documentation for the config handler you use for their full usage when accessing the <code>app.config</code> object.</p>\n<h3 id=\"Built-in-Defaults\"><a href=\"#Built-in-Defaults\" class=\"headerlink\" title=\"Built-in Defaults\"></a>Built-in Defaults</h3><p>The following are not required to exist in the config defaults, however if they do, Cement will honor them (overriding or appending to built-in defaults).</p>\n<ul>\n<li><strong>debug = <code>False</code></strong> - Toggles debug output.  By default, this setting is also overridden by the <code>[&lt;app_label&gt;] -&gt; debug</code> config setting parsed in any of the application configuration files.</li>\n<li><strong>ignore_deprecation_warnings = <code>False</code></strong> - Disable deprecation warnings from being logged by Cement.</li>\n<li><strong>extensions = <code>None</code></strong> - List of additional framework extensions to load.  Any extensions defined here will be appended to the application’s defined extensions.</li>\n<li><strong>plugin_config_dir = <code>None</code></strong> - A directory path where plugin config files can be found.  Files must end in <code>.conf</code>.  By default, this setting is also overridden by the <code>[&lt;app_label&gt;] -&gt; plugin_config_dir</code> config setting parsed in any of the application configuration files.<ul>\n<li>If set, this item will be <strong>appended</strong> to <code>CementApp.Meta.plugin_config_dirs</code> so that it’s settings will have presedence over other config files.</li>\n<li>In general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a <code>plugin_config_dir</code> without completely trumping the hard-coded list of default <code>plugin_config_dirs</code> defined by the app/developer.</li>\n</ul>\n</li>\n<li><strong>plugin_dir = <code>None</code></strong> - A directory path where plugin code (modules) can be loaded from. By default, this setting is also overridden by the <code>[&lt;app_label&gt;] -&gt; plugin_dir</code> config setting parsed in any of the application configuration files.<ul>\n<li>If set, this item will be <strong>prepended</strong> to <code>CementApp.Meta.plugin_dirs</code> so that a user’s defined <code>plugin_dir</code> has precedence over other <code>plugin_dirs</code>.</li>\n<li>In general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a <code>plugin_dir</code> without completely trumping the hard-coded list of default <code>plugin_dirs</code> defined by the app/developer.</li>\n</ul>\n</li>\n<li><strong>template_dir = <code>None</code></strong> - A directory path where template files can be loaded from.  By default, this setting is also overridden by the <code>[&lt;app_label&gt;] -&gt; template_dir</code> config setting parsed in any of the application configuration files.<ul>\n<li>If set, this item will be appended to <code>CementApp.Meta.template_dirs</code>.</li>\n<li>In general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a <code>template_dir</code> without completely trumping the hard-coded list of default <code>template_dirs</code> defined by the app/developer.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Application-Defaults-vs-Handler-Defaults\"><a href=\"#Application-Defaults-vs-Handler-Defaults\" class=\"headerlink\" title=\"Application Defaults vs Handler Defaults\"></a>Application Defaults vs Handler Defaults</h2><p>There may be slight confusion between the <code>CementApp.Meta.config_defaults</code> and the <code>CementBaseHandler.Meta.config_defaults</code> options.  They both are very similar, however the application level configuration defaults are intended to be used to set defaults for multiple sections.  Therefore, the <code>CementApp.Meta.config_defaults</code> option is a <code>dict</code> with nested <code>dict</code>‘s under it.  Each key of the top level <code>dict</code> relates to a config <code>[section]</code> and the nested <code>dict</code> are the settings for that <code>[section]</code>.</p>\n<p>The <code>CementBaseHandler.Meta.config_defaults</code> only partain to a single <code>[section]</code> and therefor is only a single level <code>dict</code>, whose settings are applied to the <code>CementBaseHandler.Meta.config_section</code> of the application’s configuration.</p>\n<h2 id=\"Accessing-Configuration-Settings\"><a href=\"#Accessing-Configuration-Settings\" class=\"headerlink\" title=\"Accessing Configuration Settings\"></a>Accessing Configuration Settings</h2><p>After application creation and setup, you can access the config handler via the <code>app.config</code> object.  For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># First setup the application</span></div><div class=\"line\">app.setup()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Get settings</span></div><div class=\"line\">app.config.get(<span class=\"string\">'myapp'</span>, <span class=\"string\">'debug'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Set settings</span></div><div class=\"line\">app.config.set(<span class=\"string\">'myapp'</span>, <span class=\"string\">'debug'</span>, <span class=\"keyword\">True</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Get sections (configuration [blocks])</span></div><div class=\"line\">app.config.get_sections()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Add a section</span></div><div class=\"line\">app.config.add_section(<span class=\"string\">'my_config_section'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Test if a section exists</span></div><div class=\"line\">app.config.has_section(<span class=\"string\">'my_config_section'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Get configuration keys for the 'myapp' section</span></div><div class=\"line\">app.config.keys(<span class=\"string\">'myapp'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Test if a key exist</span></div><div class=\"line\"><span class=\"keyword\">if</span> <span class=\"string\">'debug'</span> <span class=\"keyword\">in</span> app.config.keys(<span class=\"string\">'myapp'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Merge a dict of settings into the config</span></div><div class=\"line\">other_config = dict()</div><div class=\"line\">other_config[<span class=\"string\">'myapp'</span>] = dict()</div><div class=\"line\">other_config[<span class=\"string\">'myapp'</span>][<span class=\"string\">'foo'</span>] = <span class=\"string\">'not bar'</span></div><div class=\"line\">app.config.merge(other_config)</div></pre></td></tr></table></figure>\n<h2 id=\"Parsing-Config-Files\"><a href=\"#Parsing-Config-Files\" class=\"headerlink\" title=\"Parsing Config Files\"></a>Parsing Config Files</h2><p>Most applications benefit from allowing their users to customize runtime via a configuration file.  This can be done by:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># First setup the application</span></div><div class=\"line\">app.setup()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Parse a configuration file</span></div><div class=\"line\">app.config.parse_file(<span class=\"string\">'/path/to/some/file.conf'</span>)</div></pre></td></tr></table></figure>\n<p>Note that Cement automatically parses any config files listed in the <code>CementApp.Meta.config_files</code> list.  For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation, backend</div><div class=\"line\"></div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>,</div><div class=\"line\">        config_files = [</div><div class=\"line\">            <span class=\"string\">'/path/to/config1'</span>,</div><div class=\"line\">            <span class=\"string\">'/path/to/config2'</span></div><div class=\"line\">            ],</div><div class=\"line\">        )</div></pre></td></tr></table></figure>\n<p>If no <code>config_files</code> meta is provided, Cement will set the defaults to the following common and sane defaults:</p>\n<ul>\n<li><code>/etc/&lt;app_label&gt;/&lt;app_label&gt;.conf</code></li>\n<li><code>~/.&lt;app_label&gt;.conf</code></li>\n<li><code>~/.&lt;app_label&gt;/config</code></li>\n</ul>\n<h2 id=\"Overriding-Configurations-with-Command-Line-Options\"><a href=\"#Overriding-Configurations-with-Command-Line-Options\" class=\"headerlink\" title=\"Overriding Configurations with Command Line Options\"></a>Overriding Configurations with Command Line Options</h2><p>Config settings can <strong>optionally</strong> overridden by a passed command line option if the option name matches a configuration key.  Note that this will happen in <em>all</em> config sections if enabled:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'myapp'</span>][<span class=\"string\">'foo'</span>] = <span class=\"string\">'bar'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        config_defaults = defaults</div><div class=\"line\">        arguments_override_config = <span class=\"keyword\">True</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.args.add_argument(<span class=\"string\">'--foo'</span>, action=<span class=\"string\">'store'</span>, dest=<span class=\"string\">'foo'</span>)</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>With <code>arguments_override_config</code> enabled, running the above application and passing the <code>--foo=some_value</code> option will override the <code>foo</code> setting under a <code>[myapp]</code> configuration section as well as any other section that has a matching <code>foo</code> key.</p>\n<h2 id=\"Configuration-Options-Versus-Meta-Options\"><a href=\"#Configuration-Options-Versus-Meta-Options\" class=\"headerlink\" title=\"Configuration Options Versus Meta Options\"></a>Configuration Options Versus Meta Options</h2><p>As you will see extensively throughout the Cement code is the use of Meta options.  There can be some confusion between the use of Meta options, and application configuration options.  The following explains the two:</p>\n<p><strong>Configuration Options</strong></p>\n<p>Configuration options are application specific.  There are config defaults defined by the application developer, that can be (and are intended to be) overridden by user defined settings in a configuration file.</p>\n<p>Cement does not rely on the application configuration, though it can honor configuration settings.  For example, <code>CementApp</code> honors the <code>debug</code> config option which is documented, but it doesn’t rely on it existing either.</p>\n<p>The key things to note about configuration options are:</p>\n<ul>\n<li>They give the end user flexibility in how the application operates.</li>\n<li>Anything that you want users to be able to customize via a config file. For example, the path to a log file or the location of a database server. These are things that you do not want hard-coded into your app, but rather might want sane defaults for.</li>\n</ul>\n<p><strong>Meta Options</strong></p>\n<p>Meta options are used on the backend by developers to alter how classes operate.  For example, the <code>CementApp</code> class has a meta option of <code>log_handler</code>.  The default log handler is <code>LoggingLogHandler</code>, however because this is built on an interface definition, Cement can use any other log handler the same way without issue as long as that log handler abides by the interface definition.  Meta options make this change seamless and allows the handler to alter functionality, rather than having to change code in the top level class itself.</p>\n<p>The key thing to note about Meta options are:</p>\n<ul>\n<li>They give the developer flexibility in how the code operates.</li>\n<li>End users should not have access to modify Meta options via a config file or similar ‘dynamic’ configuration (unless those specific options are listed in <code>CementApp.Meta.core_meta_override</code> or <code>CementApp.Meta.meta_override</code> (for example, the <code>debug</code> setting under <code>[&lt;app_label&gt;]</code> overrides <code>CementApp.Meta.debug</code> by default.</li>\n<li>Meta options are used to alter how classes work, however are considered ‘hard-coded’ settings.  If the developer chooses to alter a Meta option, it is for the life of that release.</li>\n<li>Meta options should have a sane default, and be clearly documented.</li>\n</ul>\n"},{"title":"Command Line Arguments","type":"guide","version":"2.10","order":6,"_content":"\nCement defines an argument interface called [IArgument](/2.10/api/core/arg.html), as well as the default [ArgParseArgumentHandler](/2.10/api/ext/ext_argparse.html) that implements the interface.  This handler is built on top of the [ArgParse](http://docs.python.org/library/argparse.html) module which is included in the Python standard library.\n\nPlease note that there may be other handler's that implement the `IArgument` interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.\n\nThe following argument handlers are included and maintained with Cement:\n\n- [ArgParseArgumentHandler](/2.10/api/ext/ext_argparse)\n\n\nPlease reference [IArgument](/2.10/api/core/arg.html) interface documentation for writing your own argument handler.\n\n\n## Adding Arguments\n\nThe `IArgument` interface is loosely based on `ArgParse` directly.  That said, it only defines a minimal set of params that must be honored by the handler implementation, even though the handler itself may except more than that.  The following shows some basic examples of adding arguments based on the interface (meaning, these examples should work regardless of what the handler is):\n\n```python\nfrom cement.core import foundation\n\n# create the application\napp = foundation.CementApp('myapp')\n\n# then setup the application... which will use our 'mylog' handler\napp.setup()\n\n# add any arguments after setup(), and before run()\napp.args.add_argument('-f', '--foo', action='store', dest='foo',\n                      help='the notorious foo option')\napp.args.add_argument('-V', action='store_true', dest='vendetta',\n                      help='v for vendetta')\napp.args.add_argument('-A', action='store_const', const=12345,\n                      help='the big a option')\n\n# then run the application\napp.run()\n\n# access the parsed args from the app.pargs shortcut\nif app.pargs.foo:\n    print \"Received foo option with value %s\" % app.pargs.foo\nif app.pargs.vendetta:\n    print \"Received V for Vendetta!\"\nif app.pargs.A:\n    print \"Received the A option with value %s\" % app.pargs.A\n\n# close the application\napp.close()\n```\n\nHere we have setup a basic application, and then add a few arguments to the parser.\n\n```\n$ python test.py --help\nusage: test.py [-h] [--debug] [--quiet] [-f FOO] [-V] [-A]\n\noptional arguments:\n  -h, --help         show this help message and exit\n  --debug            toggle debug output\n  --quiet            suppress all output\n  -f FOO, --foo FOO  the notorious foo option\n  -V                 v for vendetta\n  -A                 the big a option\n\n$ python test.py --foo=bar\nReceived foo option with value bar\n\n$ python test.py -V\nReceived V for Vendetta!\n```\n\n## Accessing Parsed Arguments\n\nThe `IArgument` interface defines that the `parse()` function return any type of object that stores the name of the argument as a class member. Meaning, when adding the `foo` option with `action='store'` and the value is stored as the `foo` destination... that would be accessible as `app.pargs.foo`.  In the case of the `ArgParseArgumentHandler` the return object is exactly what you would expect by calling `parser.parse_args()`, but may be different with other argument handler implementations. The parsed arguments are actually stored as `app._parsed_args`, but are exposed as `app.pargs`.  Accessing `app.pargs` can be seen in the examples above.\n","source":"2.10/dev/arguments.md","raw":"---\ntitle: Command Line Arguments\ntype: guide\nversion: \"2.10\"\norder: 6\n---\n\nCement defines an argument interface called [IArgument](/2.10/api/core/arg.html), as well as the default [ArgParseArgumentHandler](/2.10/api/ext/ext_argparse.html) that implements the interface.  This handler is built on top of the [ArgParse](http://docs.python.org/library/argparse.html) module which is included in the Python standard library.\n\nPlease note that there may be other handler's that implement the `IArgument` interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.\n\nThe following argument handlers are included and maintained with Cement:\n\n- [ArgParseArgumentHandler](/2.10/api/ext/ext_argparse)\n\n\nPlease reference [IArgument](/2.10/api/core/arg.html) interface documentation for writing your own argument handler.\n\n\n## Adding Arguments\n\nThe `IArgument` interface is loosely based on `ArgParse` directly.  That said, it only defines a minimal set of params that must be honored by the handler implementation, even though the handler itself may except more than that.  The following shows some basic examples of adding arguments based on the interface (meaning, these examples should work regardless of what the handler is):\n\n```python\nfrom cement.core import foundation\n\n# create the application\napp = foundation.CementApp('myapp')\n\n# then setup the application... which will use our 'mylog' handler\napp.setup()\n\n# add any arguments after setup(), and before run()\napp.args.add_argument('-f', '--foo', action='store', dest='foo',\n                      help='the notorious foo option')\napp.args.add_argument('-V', action='store_true', dest='vendetta',\n                      help='v for vendetta')\napp.args.add_argument('-A', action='store_const', const=12345,\n                      help='the big a option')\n\n# then run the application\napp.run()\n\n# access the parsed args from the app.pargs shortcut\nif app.pargs.foo:\n    print \"Received foo option with value %s\" % app.pargs.foo\nif app.pargs.vendetta:\n    print \"Received V for Vendetta!\"\nif app.pargs.A:\n    print \"Received the A option with value %s\" % app.pargs.A\n\n# close the application\napp.close()\n```\n\nHere we have setup a basic application, and then add a few arguments to the parser.\n\n```\n$ python test.py --help\nusage: test.py [-h] [--debug] [--quiet] [-f FOO] [-V] [-A]\n\noptional arguments:\n  -h, --help         show this help message and exit\n  --debug            toggle debug output\n  --quiet            suppress all output\n  -f FOO, --foo FOO  the notorious foo option\n  -V                 v for vendetta\n  -A                 the big a option\n\n$ python test.py --foo=bar\nReceived foo option with value bar\n\n$ python test.py -V\nReceived V for Vendetta!\n```\n\n## Accessing Parsed Arguments\n\nThe `IArgument` interface defines that the `parse()` function return any type of object that stores the name of the argument as a class member. Meaning, when adding the `foo` option with `action='store'` and the value is stored as the `foo` destination... that would be accessible as `app.pargs.foo`.  In the case of the `ArgParseArgumentHandler` the return object is exactly what you would expect by calling `parser.parse_args()`, but may be different with other argument handler implementations. The parsed arguments are actually stored as `app._parsed_args`, but are exposed as `app.pargs`.  Accessing `app.pargs` can be seen in the examples above.\n","date":"2017-06-26T03:18:40.000Z","updated":"2017-06-26T03:18:40.000Z","path":"2.10/dev/arguments.html","comments":1,"layout":"page","_id":"cj5dg8qrv0008h6pwi4hjuq0p","content":"<p>Cement defines an argument interface called <a href=\"/2.10/api/core/arg.html\">IArgument</a>, as well as the default <a href=\"/2.10/api/ext/ext_argparse.html\">ArgParseArgumentHandler</a> that implements the interface.  This handler is built on top of the <a href=\"http://docs.python.org/library/argparse.html\" target=\"_blank\" rel=\"external\">ArgParse</a> module which is included in the Python standard library.</p>\n<p>Please note that there may be other handler’s that implement the <code>IArgument</code> interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.</p>\n<p>The following argument handlers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/ext/ext_argparse\">ArgParseArgumentHandler</a></li>\n</ul>\n<p>Please reference <a href=\"/2.10/api/core/arg.html\">IArgument</a> interface documentation for writing your own argument handler.</p>\n<h2 id=\"Adding-Arguments\"><a href=\"#Adding-Arguments\" class=\"headerlink\" title=\"Adding Arguments\"></a>Adding Arguments</h2><p>The <code>IArgument</code> interface is loosely based on <code>ArgParse</code> directly.  That said, it only defines a minimal set of params that must be honored by the handler implementation, even though the handler itself may except more than that.  The following shows some basic examples of adding arguments based on the interface (meaning, these examples should work regardless of what the handler is):</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># create the application</span></div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># then setup the application... which will use our 'mylog' handler</span></div><div class=\"line\">app.setup()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># add any arguments after setup(), and before run()</span></div><div class=\"line\">app.args.add_argument(<span class=\"string\">'-f'</span>, <span class=\"string\">'--foo'</span>, action=<span class=\"string\">'store'</span>, dest=<span class=\"string\">'foo'</span>,</div><div class=\"line\">                      help=<span class=\"string\">'the notorious foo option'</span>)</div><div class=\"line\">app.args.add_argument(<span class=\"string\">'-V'</span>, action=<span class=\"string\">'store_true'</span>, dest=<span class=\"string\">'vendetta'</span>,</div><div class=\"line\">                      help=<span class=\"string\">'v for vendetta'</span>)</div><div class=\"line\">app.args.add_argument(<span class=\"string\">'-A'</span>, action=<span class=\"string\">'store_const'</span>, const=<span class=\"number\">12345</span>,</div><div class=\"line\">                      help=<span class=\"string\">'the big a option'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># then run the application</span></div><div class=\"line\">app.run()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># access the parsed args from the app.pargs shortcut</span></div><div class=\"line\"><span class=\"keyword\">if</span> app.pargs.foo:</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"Received foo option with value %s\"</span> % app.pargs.foo</div><div class=\"line\"><span class=\"keyword\">if</span> app.pargs.vendetta:</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"Received V for Vendetta!\"</span></div><div class=\"line\"><span class=\"keyword\">if</span> app.pargs.A:</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"Received the A option with value %s\"</span> % app.pargs.A</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># close the application</span></div><div class=\"line\">app.close()</div></pre></td></tr></table></figure>\n<p>Here we have setup a basic application, and then add a few arguments to the parser.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python test.py --help</div><div class=\"line\">usage: test.py [-h] [--debug] [--quiet] [-f FOO] [-V] [-A]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help         show this help message and exit</div><div class=\"line\">  --debug            toggle debug output</div><div class=\"line\">  --quiet            suppress all output</div><div class=\"line\">  -f FOO, --foo FOO  the notorious foo option</div><div class=\"line\">  -V                 v for vendetta</div><div class=\"line\">  -A                 the big a option</div><div class=\"line\"></div><div class=\"line\">$ python test.py --foo=bar</div><div class=\"line\">Received foo option with value bar</div><div class=\"line\"></div><div class=\"line\">$ python test.py -V</div><div class=\"line\">Received V for Vendetta!</div></pre></td></tr></table></figure>\n<h2 id=\"Accessing-Parsed-Arguments\"><a href=\"#Accessing-Parsed-Arguments\" class=\"headerlink\" title=\"Accessing Parsed Arguments\"></a>Accessing Parsed Arguments</h2><p>The <code>IArgument</code> interface defines that the <code>parse()</code> function return any type of object that stores the name of the argument as a class member. Meaning, when adding the <code>foo</code> option with <code>action=&#39;store&#39;</code> and the value is stored as the <code>foo</code> destination… that would be accessible as <code>app.pargs.foo</code>.  In the case of the <code>ArgParseArgumentHandler</code> the return object is exactly what you would expect by calling <code>parser.parse_args()</code>, but may be different with other argument handler implementations. The parsed arguments are actually stored as <code>app._parsed_args</code>, but are exposed as <code>app.pargs</code>.  Accessing <code>app.pargs</code> can be seen in the examples above.</p>\n","excerpt":"","more":"<p>Cement defines an argument interface called <a href=\"/2.10/api/core/arg.html\">IArgument</a>, as well as the default <a href=\"/2.10/api/ext/ext_argparse.html\">ArgParseArgumentHandler</a> that implements the interface.  This handler is built on top of the <a href=\"http://docs.python.org/library/argparse.html\">ArgParse</a> module which is included in the Python standard library.</p>\n<p>Please note that there may be other handler’s that implement the <code>IArgument</code> interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.</p>\n<p>The following argument handlers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/ext/ext_argparse\">ArgParseArgumentHandler</a></li>\n</ul>\n<p>Please reference <a href=\"/2.10/api/core/arg.html\">IArgument</a> interface documentation for writing your own argument handler.</p>\n<h2 id=\"Adding-Arguments\"><a href=\"#Adding-Arguments\" class=\"headerlink\" title=\"Adding Arguments\"></a>Adding Arguments</h2><p>The <code>IArgument</code> interface is loosely based on <code>ArgParse</code> directly.  That said, it only defines a minimal set of params that must be honored by the handler implementation, even though the handler itself may except more than that.  The following shows some basic examples of adding arguments based on the interface (meaning, these examples should work regardless of what the handler is):</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># create the application</span></div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># then setup the application... which will use our 'mylog' handler</span></div><div class=\"line\">app.setup()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># add any arguments after setup(), and before run()</span></div><div class=\"line\">app.args.add_argument(<span class=\"string\">'-f'</span>, <span class=\"string\">'--foo'</span>, action=<span class=\"string\">'store'</span>, dest=<span class=\"string\">'foo'</span>,</div><div class=\"line\">                      help=<span class=\"string\">'the notorious foo option'</span>)</div><div class=\"line\">app.args.add_argument(<span class=\"string\">'-V'</span>, action=<span class=\"string\">'store_true'</span>, dest=<span class=\"string\">'vendetta'</span>,</div><div class=\"line\">                      help=<span class=\"string\">'v for vendetta'</span>)</div><div class=\"line\">app.args.add_argument(<span class=\"string\">'-A'</span>, action=<span class=\"string\">'store_const'</span>, const=<span class=\"number\">12345</span>,</div><div class=\"line\">                      help=<span class=\"string\">'the big a option'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># then run the application</span></div><div class=\"line\">app.run()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># access the parsed args from the app.pargs shortcut</span></div><div class=\"line\"><span class=\"keyword\">if</span> app.pargs.foo:</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"Received foo option with value %s\"</span> % app.pargs.foo</div><div class=\"line\"><span class=\"keyword\">if</span> app.pargs.vendetta:</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"Received V for Vendetta!\"</span></div><div class=\"line\"><span class=\"keyword\">if</span> app.pargs.A:</div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"Received the A option with value %s\"</span> % app.pargs.A</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># close the application</span></div><div class=\"line\">app.close()</div></pre></td></tr></table></figure>\n<p>Here we have setup a basic application, and then add a few arguments to the parser.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python test.py --help</div><div class=\"line\">usage: test.py [-h] [--debug] [--quiet] [-f FOO] [-V] [-A]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help         show this help message and exit</div><div class=\"line\">  --debug            toggle debug output</div><div class=\"line\">  --quiet            suppress all output</div><div class=\"line\">  -f FOO, --foo FOO  the notorious foo option</div><div class=\"line\">  -V                 v for vendetta</div><div class=\"line\">  -A                 the big a option</div><div class=\"line\"></div><div class=\"line\">$ python test.py --foo=bar</div><div class=\"line\">Received foo option with value bar</div><div class=\"line\"></div><div class=\"line\">$ python test.py -V</div><div class=\"line\">Received V for Vendetta!</div></pre></td></tr></table></figure>\n<h2 id=\"Accessing-Parsed-Arguments\"><a href=\"#Accessing-Parsed-Arguments\" class=\"headerlink\" title=\"Accessing Parsed Arguments\"></a>Accessing Parsed Arguments</h2><p>The <code>IArgument</code> interface defines that the <code>parse()</code> function return any type of object that stores the name of the argument as a class member. Meaning, when adding the <code>foo</code> option with <code>action=&#39;store&#39;</code> and the value is stored as the <code>foo</code> destination… that would be accessible as <code>app.pargs.foo</code>.  In the case of the <code>ArgParseArgumentHandler</code> the return object is exactly what you would expect by calling <code>parser.parse_args()</code>, but may be different with other argument handler implementations. The parsed arguments are actually stored as <code>app._parsed_args</code>, but are exposed as <code>app.pargs</code>.  Accessing <code>app.pargs</code> can be seen in the examples above.</p>\n"},{"title":"Introduction","type":"guide","version":"2.10","order":1,"_content":"\n## What is Cement?\n\nCement is an advanced Application Framework for Python, with a primary focus on Command Line Interfaces (CLI).  Its goal is to introduce a standard, and feature-full platform for both simple and complex command line applications as well as support rapid development needs without sacrificing quality.  Cement is flexible, and it's use cases span from the simplicity of a micro-framework to the complexity of a mega-framework. Whether it's a single file script, or a multi-tier application, Cement is the foundation you've been looking for.\n\nThe first commit to Git was on Dec 4, 2009.  Since then, the framework has seen several iterations in design, and has continued to grow and improve since it's inception.  Cement is the most stable, and complete framework for command line and backend application development.\n\n## Core Features\n\nCore features include (but are not limited to):\n\n- Core pieces of the framework are customizable via handlers/interfaces\n- Extension handler interface to easily extend framework functionality\n- Config handler supports parsing multiple config files into one config\n- Argument handler parses command line arguments and merges with config\n- Log handler supports console and file logging\n- Plugin handler provides an interface to easily extend your application\n- Hook support adds a bit of magic to apps and also ties into framework\n- Handler system connects implementation classes with Interfaces\n- Output handler interface renders return dictionaries to console\n- Cache handler interface adds caching support for improved performance\n- Controller handler supports sub-commands, and nested controllers\n- Zero external dependencies* of the core library\n- 100% test coverage using ``nose`` and ``coverage``\n- 100% PEP8 and style compliant using ``flake8``\n- Extensive documentation\n- Tested on Python 2.6, 2.7, 3.3, 3.4, 3.5\n\n<p class=\"tip-warn\">Note that argparse is required as an external dependency for Python < 2.7 and < 3.2.  Additionally, some optional extensions that are shipped with the mainline Cement sources do require external dependencies.  It is the responsibility of the application developer to include these dependencies along with their application if they intend to use any optional extensions that have external dependencies, as Cement explicitly does not include them.*</p>\n\n## License\n\nThe Cement Framework is Open Source and is distributed under the BSD License (three clause).\n\n```\nCopyright (c) 2009-2017 Data Folk Labs, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of Data Folk Labs, LLC. nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n```\n\n## Projects Built on Cement™\n\nThe following is an incomplete lists of notable projects that are Built on Cement™:\n\n- [Amazon Elastic Beanstalk CLI](http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb-cli3.html) ([PYPI](https://pypi.python.org/pypi/awsebcli))\n- [Easy Engine](https://easyengine.io/) ([GitHub](https://github.com/EasyEngine/easyengine))\n- [SentientHome](https://github.com/fxstein/SentientHome)\n- [Pubkey](https://github.com/fxstein/pubkey)\n- [HCE Project](http://hce-project.com/)\n- [QLDS Manager](https://qlds-manager.readthedocs.io/en/stable/index.html) ([GitHub](https://github.com/rzeka/QLDS-Manager))\n\nIf you are building a project on the Cement Framework and would like to see your company or project listed here [please create an issue and/or pull request on GitHub](https://github.com/datafolklabs/cement/).\n\n\n## Installation\n\nStable versions are available via PyPi:\n\n```\n$ pip install cement\n```\n\nDevelopment versions are available via Github:\n\n```\n$ git clone git://github.com/datafolklabs/cement.git\n\n$ cd cement/\n\n$ python setup.py install\n```\n\n## Getting Started\n\n<p class=\"tip-warn\">The developer guide assumes intermediate level knowledge of Python. If you are totally new to Python development, you might want to get more familiar with the language before jumping into a framework.</p>\n\nEx: Hello World:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    app.run()\n    print('Hello World!')\n```\n\nCLI Usage:\n\n```\n$ python myapp.py --help\nusage: myapp [-h] [--debug] [--quiet]\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n\n$ python myapp.py\nHello World!\n```\n","source":"2.10/dev/index.md","raw":"---\ntitle: Introduction\ntype: guide\nversion: \"2.10\"\norder: 1\n---\n\n## What is Cement?\n\nCement is an advanced Application Framework for Python, with a primary focus on Command Line Interfaces (CLI).  Its goal is to introduce a standard, and feature-full platform for both simple and complex command line applications as well as support rapid development needs without sacrificing quality.  Cement is flexible, and it's use cases span from the simplicity of a micro-framework to the complexity of a mega-framework. Whether it's a single file script, or a multi-tier application, Cement is the foundation you've been looking for.\n\nThe first commit to Git was on Dec 4, 2009.  Since then, the framework has seen several iterations in design, and has continued to grow and improve since it's inception.  Cement is the most stable, and complete framework for command line and backend application development.\n\n## Core Features\n\nCore features include (but are not limited to):\n\n- Core pieces of the framework are customizable via handlers/interfaces\n- Extension handler interface to easily extend framework functionality\n- Config handler supports parsing multiple config files into one config\n- Argument handler parses command line arguments and merges with config\n- Log handler supports console and file logging\n- Plugin handler provides an interface to easily extend your application\n- Hook support adds a bit of magic to apps and also ties into framework\n- Handler system connects implementation classes with Interfaces\n- Output handler interface renders return dictionaries to console\n- Cache handler interface adds caching support for improved performance\n- Controller handler supports sub-commands, and nested controllers\n- Zero external dependencies* of the core library\n- 100% test coverage using ``nose`` and ``coverage``\n- 100% PEP8 and style compliant using ``flake8``\n- Extensive documentation\n- Tested on Python 2.6, 2.7, 3.3, 3.4, 3.5\n\n<p class=\"tip-warn\">Note that argparse is required as an external dependency for Python < 2.7 and < 3.2.  Additionally, some optional extensions that are shipped with the mainline Cement sources do require external dependencies.  It is the responsibility of the application developer to include these dependencies along with their application if they intend to use any optional extensions that have external dependencies, as Cement explicitly does not include them.*</p>\n\n## License\n\nThe Cement Framework is Open Source and is distributed under the BSD License (three clause).\n\n```\nCopyright (c) 2009-2017 Data Folk Labs, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of Data Folk Labs, LLC. nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n```\n\n## Projects Built on Cement™\n\nThe following is an incomplete lists of notable projects that are Built on Cement™:\n\n- [Amazon Elastic Beanstalk CLI](http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb-cli3.html) ([PYPI](https://pypi.python.org/pypi/awsebcli))\n- [Easy Engine](https://easyengine.io/) ([GitHub](https://github.com/EasyEngine/easyengine))\n- [SentientHome](https://github.com/fxstein/SentientHome)\n- [Pubkey](https://github.com/fxstein/pubkey)\n- [HCE Project](http://hce-project.com/)\n- [QLDS Manager](https://qlds-manager.readthedocs.io/en/stable/index.html) ([GitHub](https://github.com/rzeka/QLDS-Manager))\n\nIf you are building a project on the Cement Framework and would like to see your company or project listed here [please create an issue and/or pull request on GitHub](https://github.com/datafolklabs/cement/).\n\n\n## Installation\n\nStable versions are available via PyPi:\n\n```\n$ pip install cement\n```\n\nDevelopment versions are available via Github:\n\n```\n$ git clone git://github.com/datafolklabs/cement.git\n\n$ cd cement/\n\n$ python setup.py install\n```\n\n## Getting Started\n\n<p class=\"tip-warn\">The developer guide assumes intermediate level knowledge of Python. If you are totally new to Python development, you might want to get more familiar with the language before jumping into a framework.</p>\n\nEx: Hello World:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    app.run()\n    print('Hello World!')\n```\n\nCLI Usage:\n\n```\n$ python myapp.py --help\nusage: myapp [-h] [--debug] [--quiet]\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n\n$ python myapp.py\nHello World!\n```\n","date":"2018-01-17T03:37:55.080Z","updated":"2018-01-17T03:37:55.080Z","path":"2.10/dev/index.html","_id":"cj5dg8qrv0009h6pwyq5ts5du","comments":1,"layout":"page","content":"<h2 id=\"What-is-Cement\"><a href=\"#What-is-Cement\" class=\"headerlink\" title=\"What is Cement?\"></a>What is Cement?</h2><p>Cement is an advanced Application Framework for Python, with a primary focus on Command Line Interfaces (CLI).  Its goal is to introduce a standard, and feature-full platform for both simple and complex command line applications as well as support rapid development needs without sacrificing quality.  Cement is flexible, and it’s use cases span from the simplicity of a micro-framework to the complexity of a mega-framework. Whether it’s a single file script, or a multi-tier application, Cement is the foundation you’ve been looking for.</p>\n<p>The first commit to Git was on Dec 4, 2009.  Since then, the framework has seen several iterations in design, and has continued to grow and improve since it’s inception.  Cement is the most stable, and complete framework for command line and backend application development.</p>\n<h2 id=\"Core-Features\"><a href=\"#Core-Features\" class=\"headerlink\" title=\"Core Features\"></a>Core Features</h2><p>Core features include (but are not limited to):</p>\n<ul>\n<li>Core pieces of the framework are customizable via handlers/interfaces</li>\n<li>Extension handler interface to easily extend framework functionality</li>\n<li>Config handler supports parsing multiple config files into one config</li>\n<li>Argument handler parses command line arguments and merges with config</li>\n<li>Log handler supports console and file logging</li>\n<li>Plugin handler provides an interface to easily extend your application</li>\n<li>Hook support adds a bit of magic to apps and also ties into framework</li>\n<li>Handler system connects implementation classes with Interfaces</li>\n<li>Output handler interface renders return dictionaries to console</li>\n<li>Cache handler interface adds caching support for improved performance</li>\n<li>Controller handler supports sub-commands, and nested controllers</li>\n<li>Zero external dependencies* of the core library</li>\n<li>100% test coverage using <code>nose</code> and <code>coverage</code></li>\n<li>100% PEP8 and style compliant using <code>flake8</code></li>\n<li>Extensive documentation</li>\n<li>Tested on Python 2.6, 2.7, 3.3, 3.4, 3.5</li>\n</ul>\n<p class=\"tip-warn\">Note that argparse is required as an external dependency for Python &lt; 2.7 and &lt; 3.2.  Additionally, some optional extensions that are shipped with the mainline Cement sources do require external dependencies.  It is the responsibility of the application developer to include these dependencies along with their application if they intend to use any optional extensions that have external dependencies, as Cement explicitly does not include them.*</p>\n\n<h2 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h2><p>The Cement Framework is Open Source and is distributed under the BSD License (three clause).</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Copyright (c) 2009-2017 Data Folk Labs, LLC</div><div class=\"line\">All rights reserved.</div><div class=\"line\"></div><div class=\"line\">Redistribution and use in source and binary forms, with or without</div><div class=\"line\">modification, are permitted provided that the following conditions are met:</div><div class=\"line\"></div><div class=\"line\">    * Redistributions of source code must retain the above copyright notice,</div><div class=\"line\">      this list of conditions and the following disclaimer.</div><div class=\"line\">    * Redistributions in binary form must reproduce the above copyright</div><div class=\"line\">      notice, this list of conditions and the following disclaimer in the</div><div class=\"line\">      documentation and/or other materials provided with the distribution.</div><div class=\"line\">    * Neither the name of Data Folk Labs, LLC. nor the names of its</div><div class=\"line\">      contributors may be used to endorse or promote products derived from</div><div class=\"line\">      this software without specific prior written permission.</div><div class=\"line\"></div><div class=\"line\">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</div><div class=\"line\">AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</div><div class=\"line\">IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</div><div class=\"line\">DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</div><div class=\"line\">FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</div><div class=\"line\">DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</div><div class=\"line\">SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</div><div class=\"line\">CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</div><div class=\"line\">OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</div><div class=\"line\">OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</div></pre></td></tr></table></figure>\n<h2 id=\"Projects-Built-on-Cement™\"><a href=\"#Projects-Built-on-Cement™\" class=\"headerlink\" title=\"Projects Built on Cement™\"></a>Projects Built on Cement™</h2><p>The following is an incomplete lists of notable projects that are Built on Cement™:</p>\n<ul>\n<li><a href=\"http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb-cli3.html\" target=\"_blank\" rel=\"external\">Amazon Elastic Beanstalk CLI</a> (<a href=\"https://pypi.python.org/pypi/awsebcli\" target=\"_blank\" rel=\"external\">PYPI</a>)</li>\n<li><a href=\"https://easyengine.io/\" target=\"_blank\" rel=\"external\">Easy Engine</a> (<a href=\"https://github.com/EasyEngine/easyengine\" target=\"_blank\" rel=\"external\">GitHub</a>)</li>\n<li><a href=\"https://github.com/fxstein/SentientHome\" target=\"_blank\" rel=\"external\">SentientHome</a></li>\n<li><a href=\"https://github.com/fxstein/pubkey\" target=\"_blank\" rel=\"external\">Pubkey</a></li>\n<li><a href=\"http://hce-project.com/\" target=\"_blank\" rel=\"external\">HCE Project</a></li>\n<li><a href=\"https://qlds-manager.readthedocs.io/en/stable/index.html\" target=\"_blank\" rel=\"external\">QLDS Manager</a> (<a href=\"https://github.com/rzeka/QLDS-Manager\" target=\"_blank\" rel=\"external\">GitHub</a>)</li>\n</ul>\n<p>If you are building a project on the Cement Framework and would like to see your company or project listed here <a href=\"https://github.com/datafolklabs/cement/\" target=\"_blank\" rel=\"external\">please create an issue and/or pull request on GitHub</a>.</p>\n<h2 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"></a>Installation</h2><p>Stable versions are available via PyPi:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ pip install cement</div></pre></td></tr></table></figure>\n<p>Development versions are available via Github:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git clone git://github.com/datafolklabs/cement.git</div><div class=\"line\"></div><div class=\"line\">$ cd cement/</div><div class=\"line\"></div><div class=\"line\">$ python setup.py install</div></pre></td></tr></table></figure>\n<h2 id=\"Getting-Started\"><a href=\"#Getting-Started\" class=\"headerlink\" title=\"Getting Started\"></a>Getting Started</h2><p class=\"tip-warn\">The developer guide assumes intermediate level knowledge of Python. If you are totally new to Python development, you might want to get more familiar with the language before jumping into a framework.</p>\n\n<p>Ex: Hello World:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\">    print(<span class=\"string\">'Hello World!'</span>)</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py</div><div class=\"line\">Hello World!</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"What-is-Cement\"><a href=\"#What-is-Cement\" class=\"headerlink\" title=\"What is Cement?\"></a>What is Cement?</h2><p>Cement is an advanced Application Framework for Python, with a primary focus on Command Line Interfaces (CLI).  Its goal is to introduce a standard, and feature-full platform for both simple and complex command line applications as well as support rapid development needs without sacrificing quality.  Cement is flexible, and it’s use cases span from the simplicity of a micro-framework to the complexity of a mega-framework. Whether it’s a single file script, or a multi-tier application, Cement is the foundation you’ve been looking for.</p>\n<p>The first commit to Git was on Dec 4, 2009.  Since then, the framework has seen several iterations in design, and has continued to grow and improve since it’s inception.  Cement is the most stable, and complete framework for command line and backend application development.</p>\n<h2 id=\"Core-Features\"><a href=\"#Core-Features\" class=\"headerlink\" title=\"Core Features\"></a>Core Features</h2><p>Core features include (but are not limited to):</p>\n<ul>\n<li>Core pieces of the framework are customizable via handlers/interfaces</li>\n<li>Extension handler interface to easily extend framework functionality</li>\n<li>Config handler supports parsing multiple config files into one config</li>\n<li>Argument handler parses command line arguments and merges with config</li>\n<li>Log handler supports console and file logging</li>\n<li>Plugin handler provides an interface to easily extend your application</li>\n<li>Hook support adds a bit of magic to apps and also ties into framework</li>\n<li>Handler system connects implementation classes with Interfaces</li>\n<li>Output handler interface renders return dictionaries to console</li>\n<li>Cache handler interface adds caching support for improved performance</li>\n<li>Controller handler supports sub-commands, and nested controllers</li>\n<li>Zero external dependencies* of the core library</li>\n<li>100% test coverage using <code>nose</code> and <code>coverage</code></li>\n<li>100% PEP8 and style compliant using <code>flake8</code></li>\n<li>Extensive documentation</li>\n<li>Tested on Python 2.6, 2.7, 3.3, 3.4, 3.5</li>\n</ul>\n<p class=\"tip-warn\">Note that argparse is required as an external dependency for Python &lt; 2.7 and &lt; 3.2.  Additionally, some optional extensions that are shipped with the mainline Cement sources do require external dependencies.  It is the responsibility of the application developer to include these dependencies along with their application if they intend to use any optional extensions that have external dependencies, as Cement explicitly does not include them.*</p>\n\n<h2 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h2><p>The Cement Framework is Open Source and is distributed under the BSD License (three clause).</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Copyright (c) 2009-2017 Data Folk Labs, LLC</div><div class=\"line\">All rights reserved.</div><div class=\"line\"></div><div class=\"line\">Redistribution and use in source and binary forms, with or without</div><div class=\"line\">modification, are permitted provided that the following conditions are met:</div><div class=\"line\"></div><div class=\"line\">    * Redistributions of source code must retain the above copyright notice,</div><div class=\"line\">      this list of conditions and the following disclaimer.</div><div class=\"line\">    * Redistributions in binary form must reproduce the above copyright</div><div class=\"line\">      notice, this list of conditions and the following disclaimer in the</div><div class=\"line\">      documentation and/or other materials provided with the distribution.</div><div class=\"line\">    * Neither the name of Data Folk Labs, LLC. nor the names of its</div><div class=\"line\">      contributors may be used to endorse or promote products derived from</div><div class=\"line\">      this software without specific prior written permission.</div><div class=\"line\"></div><div class=\"line\">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</div><div class=\"line\">AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</div><div class=\"line\">IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</div><div class=\"line\">DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</div><div class=\"line\">FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</div><div class=\"line\">DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</div><div class=\"line\">SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</div><div class=\"line\">CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</div><div class=\"line\">OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</div><div class=\"line\">OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</div></pre></td></tr></table></figure>\n<h2 id=\"Projects-Built-on-Cement™\"><a href=\"#Projects-Built-on-Cement™\" class=\"headerlink\" title=\"Projects Built on Cement™\"></a>Projects Built on Cement™</h2><p>The following is an incomplete lists of notable projects that are Built on Cement™:</p>\n<ul>\n<li><a href=\"http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb-cli3.html\">Amazon Elastic Beanstalk CLI</a> (<a href=\"https://pypi.python.org/pypi/awsebcli\">PYPI</a>)</li>\n<li><a href=\"https://easyengine.io/\">Easy Engine</a> (<a href=\"https://github.com/EasyEngine/easyengine\">GitHub</a>)</li>\n<li><a href=\"https://github.com/fxstein/SentientHome\">SentientHome</a></li>\n<li><a href=\"https://github.com/fxstein/pubkey\">Pubkey</a></li>\n<li><a href=\"http://hce-project.com/\">HCE Project</a></li>\n<li><a href=\"https://qlds-manager.readthedocs.io/en/stable/index.html\">QLDS Manager</a> (<a href=\"https://github.com/rzeka/QLDS-Manager\">GitHub</a>)</li>\n</ul>\n<p>If you are building a project on the Cement Framework and would like to see your company or project listed here <a href=\"https://github.com/datafolklabs/cement/\">please create an issue and/or pull request on GitHub</a>.</p>\n<h2 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"></a>Installation</h2><p>Stable versions are available via PyPi:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ pip install cement</div></pre></td></tr></table></figure>\n<p>Development versions are available via Github:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git clone git://github.com/datafolklabs/cement.git</div><div class=\"line\"></div><div class=\"line\">$ cd cement/</div><div class=\"line\"></div><div class=\"line\">$ python setup.py install</div></pre></td></tr></table></figure>\n<h2 id=\"Getting-Started\"><a href=\"#Getting-Started\" class=\"headerlink\" title=\"Getting Started\"></a>Getting Started</h2><p class=\"tip-warn\">The developer guide assumes intermediate level knowledge of Python. If you are totally new to Python development, you might want to get more familiar with the language before jumping into a framework.</p>\n\n<p>Ex: Hello World:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\">    print(<span class=\"string\">'Hello World!'</span>)</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py</div><div class=\"line\">Hello World!</div></pre></td></tr></table></figure>\n"},{"title":"Logging","type":"guide","version":"2.10","order":7,"_content":"\nCement defines a logging interface called [ILog](/{{ version }}/api/core/log.html), as well as the default [LoggingLogHandler](/2.10/api/ext/ext_logging.html) that implements the interface.   This handler is built on top of the [Logging](http://docs.python.org/library/logging.html) module which is included in the Python standard library.\n\nPlease note that there may be other handler's that implement the ILog interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.\n\nThe following log handlers are included and maintained with Cement:\n\n- [LoggingLogHandler](/{{ version }}/api/ext/ext_logging.html)\n- [ColorLogHandler](/{{ version }}/api/ext/ext_colorlog.html)\n\n\nPlease reference the [ILog](/{{ version }}/api/core/config.html) interface documentation for writing your own log handler.\n\n\n## Logging Messages\n\nThe following shows logging to each of the defined log levels.\n\n```python\nfrom cement.core import foundation\napp = foundation.CementApp('myapp')\n\n# First setup the application\napp.setup()\n\n# Run the application (even though it doesn't do much here)\napp.run()\n\n# Log a debug message\napp.log.debug('This is a debug message.')\n\n# Log an info message\napp.log.info('This is an info message.')\n\n# Log a warning message\napp.log.warning('This is a warning message.')\n\n# Log an error message\napp.log.error('This is an error message.')\n\n# Log an fatal error message\napp.log.fatal('This is a fatal message.')\n\n# Close the application\napp.close()\n```\n\n\nThe above is displayed in order of 'severity' you can say.  If the log level is set to 'INFO', you will receive all 'info' messages and above .. including warning, error, and fatal.  However, you will not receive DEBUG level messages. The same goes for a log level of 'WARNING', where you will receive warning, error, and fatal... but you will not receive INFO, or DEBUG level messages.\n\n\n## Changing Log Level\n\nThe log level defaults to INFO, based on the 'config_defaults' of the log handler.  You can override this via config_defaults:\n\n```python\nfrom cement.core import foundation, backend\nfrom cement.utils.misc import init_defaults\n\ndefaults = init_defaults('myapp', 'log.logging')\ndefaults['log.logging']['level'] = 'WARNING'\n\napp = foundation.CementApp('myapp', config_defaults=defaults)\napp.setup()\n```\n\nThis will also be overridden by the 'level' setting under a `[log.logging]` section in any of the applications configuration files that are parsed.\n\nYou should also note that Cement includes a `--debug` command line option by default.  This triggers the log level to 'DEBUG' and is helpful for quickly debugging issues:\n\n```\n$ python test.py --debug\n2012-07-13 02:19:42,270 (DEBUG) cement.core.foundation : laying cement for the 'myapp' application\n2012-07-13 02:19:42,270 (DEBUG) cement.core.hook : defining hook 'pre_setup'\n2012-07-13 02:19:42,270 (DEBUG) cement.core.hook : defining hook 'post_setup'\n2012-07-13 02:19:42,270 (DEBUG) cement.core.hook : defining hook 'pre_run'\n2012-07-13 02:19:42,270 (DEBUG) cement.core.hook : defining hook 'post_run'\n2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook 'pre_close'\n2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook 'post_close'\n2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook 'signal'\n2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook 'pre_render'\n2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook 'post_render'\n2012-07-13 02:19:42,271 (DEBUG) cement.core.handler : defining handler type 'extension' (IExtension)\n2012-07-13 02:19:42,271 (DEBUG) cement.core.handler : defining handler type 'log' (ILog)\n2012-07-13 02:19:42,271 (DEBUG) cement.core.handler : defining handler type 'config' (IConfig)\n2012-07-13 02:19:42,271 (DEBUG) cement.core.handler : defining handler type 'plugin' (IPlugin)\n2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : defining handler type 'output' (IOutput)\n2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : defining handler type 'argument' (IArgument)\n2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : defining handler type 'controller' (IController)\n2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : defining handler type 'cache' (ICache)\n2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : registering handler '<class 'cement.core.extension.CementExtensionHandler'>' into handlers['extension']['cement']\n2012-07-13 02:19:42,272 (DEBUG) cement.core.foundation : now setting up the 'myapp' application\n2012-07-13 02:19:42,272 (DEBUG) cement.core.foundation : adding signal handler for signal 15\n2012-07-13 02:19:42,273 (DEBUG) cement.core.foundation : adding signal handler for signal 2\n2012-07-13 02:19:42,273 (DEBUG) cement.core.foundation : setting up myapp.extension handler\n2012-07-13 02:19:42,273 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_dummy' framework extension\n2012-07-13 02:19:42,273 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_dummy.DummyOutputHandler'>' into handlers['output']['null']\n2012-07-13 02:19:42,273 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_plugin' framework extension\n2012-07-13 02:19:42,273 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_plugin.CementPluginHandler'>' into handlers['plugin']['cement']\n2012-07-13 02:19:42,273 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_configparser' framework extension\n2012-07-13 02:19:42,274 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_configparser.ConfigParserConfigHandler'>' into handlers['config']['configparser']\n2012-07-13 02:19:42,274 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_logging' framework extension\n2012-07-13 02:19:42,274 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_logging.LoggingLogHandler'>' into handlers['log']['logging']\n2012-07-13 02:19:42,274 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_argparse' framework extension\n2012-07-13 02:19:42,276 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_argparse.ArgParseArgumentHandler'>' into handlers['argument']['argparse']\n2012-07-13 02:19:42,276 (DEBUG) cement.core.foundation : setting up myapp.config handler\n2012-07-13 02:19:42,276 (DEBUG) cement.ext.ext_configparser : config file '/etc/myapp/myapp.conf' does not exist, skipping...\n2012-07-13 02:19:42,277 (DEBUG) cement.core.foundation : no cache handler defined, skipping.\n2012-07-13 02:19:42,277 (DEBUG) cement.core.foundation : setting up myapp.log handler\n2012-07-13 02:19:42,277 (DEBUG) cement.core.handler : merging config defaults from '<cement.ext.ext_logging.LoggingLogHandler object at 0x100588dd0>'\n2012-07-13 02:19:42,277 (DEBUG) myapp : logging initialized for 'myapp' using LoggingLogHandler\n2012-07-13 02:19:42,278 (DEBUG) cement.core.foundation : setting up myapp.plugin handler\n2012-07-13 02:19:42,278 (DEBUG) cement.ext.ext_plugin : plugin config dir /etc/myapp/plugins.d does not exist.\n2012-07-13 02:19:42,278 (DEBUG) cement.core.foundation : setting up myapp.arg handler\n2012-07-13 02:19:42,279 (DEBUG) cement.core.foundation : setting up myapp.output handler\n2012-07-13 02:19:42,279 (DEBUG) cement.core.foundation : setting up application controllers\n2012-07-13 02:19:42,279 (DEBUG) cement.core.foundation : no controller could be found.\n2012-07-13 02:19:42,280 (DEBUG) cement.core.foundation : closing the application\n```\n\nYou can see that debug logging is extremely verbose.  In the above you will note the message format is:\n\n```\nTIMESTAMP - LEVEL - MODULE - MESSAGE\n```\n\nThe Cement framework only logs to DEBUG, where the MODULE is displayed as 'cement.core.whatever'.  Note that Cement uses a minimal logger that is separate from the application log, therefore settings you change in your application do not affect it.\n\n\n## Logging to Console\n\nThe default log handler configuration enables logging to console.  For example:\n\n```python\nfrom cement.core import foundation\napp = foundation.CementApp('myapp')\napp.setup()\napp.run()\napp.log.info('This is my info message')\napp.close()\n```\n\nWhen running this script at command line you would get:\n\n```\n$ python test.py\nINFO: This is my info message\n```\n\nThis can be disabled by setting 'to_console=False' in either the application defaults, or in an application configuration file under the '[log.logging]' section.\n\n\n## Logging to File\n\nFile logging is disabled by default, but is just one line to enable.  Simply set the 'file' setting under the '[log.logging]' config section either by application defaults, or via a configuration file.\n\n```python\nfrom cement.core import foundation, backend\nfrom cement.utils.misc import init_defaults\n\ndefaults = init_defaults('myapp', 'log.logging')\ndefaults['log.logging']['file'] = 'my.log'\n\napp = foundation.CementApp('myapp', config_defaults=defaults)\napp.setup()\napp.run()\napp.log.info('This is my info message')\napp.close()\n```\n\nRunning this we will see:\n\n```\n$ python test.py\nINFO: This is my info message\n\n$ cat my.log\n2011-08-26 17:50:16,306 (INFO) myapp : This is my info message\n```\n\n\nNotice that the logging is a bit more verbose when logged to a file.\n\n\n## Tips on Debugging\n\nNote: The following is specific to the default [LoggingLogHandler](/{{ version }}/api/ext/ext_logging) only, and is not an implementation of the ILog interface.\n\nLogging to 'app.log.debug()' is pretty straight forward, however adding an additional parameter for the 'namespace' can greatly increase insight into where that log is happening.  The 'namespace' defaults to the application name which you will see in every log like this:\n\n```\n2012-07-30 18:05:11,357 (DEBUG) myapp : This is my message\n```\n\nFor debugging, it might be more useful to change this to __name__:\n\n```python\napp.log.debug('This is my info message', __name__)\n```\n\nWhich looks like:\n\n```\n2012-07-30 18:05:11,357 (DEBUG) myapp.somepackage.test : This is my message\n```\n\nOr even more verbose, the __file__ and a line number of the log:\n\n```python\napp.log.debug('This is my info message', '%s,L2734' % __file__)\n```\n\nWhich looks like:\n\n```\n2012-07-30 18:05:11,357 (DEBUG) myapp/somepackage/test.py,L2345 : This is my message\n```\n\nYou can override this with anything... it doesn't have to be just for debugging.\n","source":"2.10/dev/logging.md","raw":"---\ntitle: Logging\ntype: guide\nversion: \"2.10\"\norder: 7\n---\n\nCement defines a logging interface called [ILog](/{{ version }}/api/core/log.html), as well as the default [LoggingLogHandler](/2.10/api/ext/ext_logging.html) that implements the interface.   This handler is built on top of the [Logging](http://docs.python.org/library/logging.html) module which is included in the Python standard library.\n\nPlease note that there may be other handler's that implement the ILog interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.\n\nThe following log handlers are included and maintained with Cement:\n\n- [LoggingLogHandler](/{{ version }}/api/ext/ext_logging.html)\n- [ColorLogHandler](/{{ version }}/api/ext/ext_colorlog.html)\n\n\nPlease reference the [ILog](/{{ version }}/api/core/config.html) interface documentation for writing your own log handler.\n\n\n## Logging Messages\n\nThe following shows logging to each of the defined log levels.\n\n```python\nfrom cement.core import foundation\napp = foundation.CementApp('myapp')\n\n# First setup the application\napp.setup()\n\n# Run the application (even though it doesn't do much here)\napp.run()\n\n# Log a debug message\napp.log.debug('This is a debug message.')\n\n# Log an info message\napp.log.info('This is an info message.')\n\n# Log a warning message\napp.log.warning('This is a warning message.')\n\n# Log an error message\napp.log.error('This is an error message.')\n\n# Log an fatal error message\napp.log.fatal('This is a fatal message.')\n\n# Close the application\napp.close()\n```\n\n\nThe above is displayed in order of 'severity' you can say.  If the log level is set to 'INFO', you will receive all 'info' messages and above .. including warning, error, and fatal.  However, you will not receive DEBUG level messages. The same goes for a log level of 'WARNING', where you will receive warning, error, and fatal... but you will not receive INFO, or DEBUG level messages.\n\n\n## Changing Log Level\n\nThe log level defaults to INFO, based on the 'config_defaults' of the log handler.  You can override this via config_defaults:\n\n```python\nfrom cement.core import foundation, backend\nfrom cement.utils.misc import init_defaults\n\ndefaults = init_defaults('myapp', 'log.logging')\ndefaults['log.logging']['level'] = 'WARNING'\n\napp = foundation.CementApp('myapp', config_defaults=defaults)\napp.setup()\n```\n\nThis will also be overridden by the 'level' setting under a `[log.logging]` section in any of the applications configuration files that are parsed.\n\nYou should also note that Cement includes a `--debug` command line option by default.  This triggers the log level to 'DEBUG' and is helpful for quickly debugging issues:\n\n```\n$ python test.py --debug\n2012-07-13 02:19:42,270 (DEBUG) cement.core.foundation : laying cement for the 'myapp' application\n2012-07-13 02:19:42,270 (DEBUG) cement.core.hook : defining hook 'pre_setup'\n2012-07-13 02:19:42,270 (DEBUG) cement.core.hook : defining hook 'post_setup'\n2012-07-13 02:19:42,270 (DEBUG) cement.core.hook : defining hook 'pre_run'\n2012-07-13 02:19:42,270 (DEBUG) cement.core.hook : defining hook 'post_run'\n2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook 'pre_close'\n2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook 'post_close'\n2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook 'signal'\n2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook 'pre_render'\n2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook 'post_render'\n2012-07-13 02:19:42,271 (DEBUG) cement.core.handler : defining handler type 'extension' (IExtension)\n2012-07-13 02:19:42,271 (DEBUG) cement.core.handler : defining handler type 'log' (ILog)\n2012-07-13 02:19:42,271 (DEBUG) cement.core.handler : defining handler type 'config' (IConfig)\n2012-07-13 02:19:42,271 (DEBUG) cement.core.handler : defining handler type 'plugin' (IPlugin)\n2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : defining handler type 'output' (IOutput)\n2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : defining handler type 'argument' (IArgument)\n2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : defining handler type 'controller' (IController)\n2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : defining handler type 'cache' (ICache)\n2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : registering handler '<class 'cement.core.extension.CementExtensionHandler'>' into handlers['extension']['cement']\n2012-07-13 02:19:42,272 (DEBUG) cement.core.foundation : now setting up the 'myapp' application\n2012-07-13 02:19:42,272 (DEBUG) cement.core.foundation : adding signal handler for signal 15\n2012-07-13 02:19:42,273 (DEBUG) cement.core.foundation : adding signal handler for signal 2\n2012-07-13 02:19:42,273 (DEBUG) cement.core.foundation : setting up myapp.extension handler\n2012-07-13 02:19:42,273 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_dummy' framework extension\n2012-07-13 02:19:42,273 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_dummy.DummyOutputHandler'>' into handlers['output']['null']\n2012-07-13 02:19:42,273 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_plugin' framework extension\n2012-07-13 02:19:42,273 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_plugin.CementPluginHandler'>' into handlers['plugin']['cement']\n2012-07-13 02:19:42,273 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_configparser' framework extension\n2012-07-13 02:19:42,274 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_configparser.ConfigParserConfigHandler'>' into handlers['config']['configparser']\n2012-07-13 02:19:42,274 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_logging' framework extension\n2012-07-13 02:19:42,274 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_logging.LoggingLogHandler'>' into handlers['log']['logging']\n2012-07-13 02:19:42,274 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_argparse' framework extension\n2012-07-13 02:19:42,276 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_argparse.ArgParseArgumentHandler'>' into handlers['argument']['argparse']\n2012-07-13 02:19:42,276 (DEBUG) cement.core.foundation : setting up myapp.config handler\n2012-07-13 02:19:42,276 (DEBUG) cement.ext.ext_configparser : config file '/etc/myapp/myapp.conf' does not exist, skipping...\n2012-07-13 02:19:42,277 (DEBUG) cement.core.foundation : no cache handler defined, skipping.\n2012-07-13 02:19:42,277 (DEBUG) cement.core.foundation : setting up myapp.log handler\n2012-07-13 02:19:42,277 (DEBUG) cement.core.handler : merging config defaults from '<cement.ext.ext_logging.LoggingLogHandler object at 0x100588dd0>'\n2012-07-13 02:19:42,277 (DEBUG) myapp : logging initialized for 'myapp' using LoggingLogHandler\n2012-07-13 02:19:42,278 (DEBUG) cement.core.foundation : setting up myapp.plugin handler\n2012-07-13 02:19:42,278 (DEBUG) cement.ext.ext_plugin : plugin config dir /etc/myapp/plugins.d does not exist.\n2012-07-13 02:19:42,278 (DEBUG) cement.core.foundation : setting up myapp.arg handler\n2012-07-13 02:19:42,279 (DEBUG) cement.core.foundation : setting up myapp.output handler\n2012-07-13 02:19:42,279 (DEBUG) cement.core.foundation : setting up application controllers\n2012-07-13 02:19:42,279 (DEBUG) cement.core.foundation : no controller could be found.\n2012-07-13 02:19:42,280 (DEBUG) cement.core.foundation : closing the application\n```\n\nYou can see that debug logging is extremely verbose.  In the above you will note the message format is:\n\n```\nTIMESTAMP - LEVEL - MODULE - MESSAGE\n```\n\nThe Cement framework only logs to DEBUG, where the MODULE is displayed as 'cement.core.whatever'.  Note that Cement uses a minimal logger that is separate from the application log, therefore settings you change in your application do not affect it.\n\n\n## Logging to Console\n\nThe default log handler configuration enables logging to console.  For example:\n\n```python\nfrom cement.core import foundation\napp = foundation.CementApp('myapp')\napp.setup()\napp.run()\napp.log.info('This is my info message')\napp.close()\n```\n\nWhen running this script at command line you would get:\n\n```\n$ python test.py\nINFO: This is my info message\n```\n\nThis can be disabled by setting 'to_console=False' in either the application defaults, or in an application configuration file under the '[log.logging]' section.\n\n\n## Logging to File\n\nFile logging is disabled by default, but is just one line to enable.  Simply set the 'file' setting under the '[log.logging]' config section either by application defaults, or via a configuration file.\n\n```python\nfrom cement.core import foundation, backend\nfrom cement.utils.misc import init_defaults\n\ndefaults = init_defaults('myapp', 'log.logging')\ndefaults['log.logging']['file'] = 'my.log'\n\napp = foundation.CementApp('myapp', config_defaults=defaults)\napp.setup()\napp.run()\napp.log.info('This is my info message')\napp.close()\n```\n\nRunning this we will see:\n\n```\n$ python test.py\nINFO: This is my info message\n\n$ cat my.log\n2011-08-26 17:50:16,306 (INFO) myapp : This is my info message\n```\n\n\nNotice that the logging is a bit more verbose when logged to a file.\n\n\n## Tips on Debugging\n\nNote: The following is specific to the default [LoggingLogHandler](/{{ version }}/api/ext/ext_logging) only, and is not an implementation of the ILog interface.\n\nLogging to 'app.log.debug()' is pretty straight forward, however adding an additional parameter for the 'namespace' can greatly increase insight into where that log is happening.  The 'namespace' defaults to the application name which you will see in every log like this:\n\n```\n2012-07-30 18:05:11,357 (DEBUG) myapp : This is my message\n```\n\nFor debugging, it might be more useful to change this to __name__:\n\n```python\napp.log.debug('This is my info message', __name__)\n```\n\nWhich looks like:\n\n```\n2012-07-30 18:05:11,357 (DEBUG) myapp.somepackage.test : This is my message\n```\n\nOr even more verbose, the __file__ and a line number of the log:\n\n```python\napp.log.debug('This is my info message', '%s,L2734' % __file__)\n```\n\nWhich looks like:\n\n```\n2012-07-30 18:05:11,357 (DEBUG) myapp/somepackage/test.py,L2345 : This is my message\n```\n\nYou can override this with anything... it doesn't have to be just for debugging.\n","date":"2017-08-04T03:18:43.000Z","updated":"2017-08-04T03:18:43.000Z","path":"2.10/dev/logging.html","_id":"cj5dg8qrw000ah6pwfma0a33p","comments":1,"layout":"page","content":"<p>Cement defines a logging interface called <a href=\"/2.10/api/core/log.html\">ILog</a>, as well as the default <a href=\"/2.10/api/ext/ext_logging.html\">LoggingLogHandler</a> that implements the interface.   This handler is built on top of the <a href=\"http://docs.python.org/library/logging.html\" target=\"_blank\" rel=\"external\">Logging</a> module which is included in the Python standard library.</p>\n<p>Please note that there may be other handler’s that implement the ILog interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.</p>\n<p>The following log handlers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/ext/ext_logging.html\">LoggingLogHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_colorlog.html\">ColorLogHandler</a></li>\n</ul>\n<p>Please reference the <a href=\"/2.10/api/core/config.html\">ILog</a> interface documentation for writing your own log handler.</p>\n<h2 id=\"Logging-Messages\"><a href=\"#Logging-Messages\" class=\"headerlink\" title=\"Logging Messages\"></a>Logging Messages</h2><p>The following shows logging to each of the defined log levels.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># First setup the application</span></div><div class=\"line\">app.setup()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Run the application (even though it doesn't do much here)</span></div><div class=\"line\">app.run()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Log a debug message</span></div><div class=\"line\">app.log.debug(<span class=\"string\">'This is a debug message.'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Log an info message</span></div><div class=\"line\">app.log.info(<span class=\"string\">'This is an info message.'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Log a warning message</span></div><div class=\"line\">app.log.warning(<span class=\"string\">'This is a warning message.'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Log an error message</span></div><div class=\"line\">app.log.error(<span class=\"string\">'This is an error message.'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Log an fatal error message</span></div><div class=\"line\">app.log.fatal(<span class=\"string\">'This is a fatal message.'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Close the application</span></div><div class=\"line\">app.close()</div></pre></td></tr></table></figure>\n<p>The above is displayed in order of ‘severity’ you can say.  If the log level is set to ‘INFO’, you will receive all ‘info’ messages and above .. including warning, error, and fatal.  However, you will not receive DEBUG level messages. The same goes for a log level of ‘WARNING’, where you will receive warning, error, and fatal… but you will not receive INFO, or DEBUG level messages.</p>\n<h2 id=\"Changing-Log-Level\"><a href=\"#Changing-Log-Level\" class=\"headerlink\" title=\"Changing Log Level\"></a>Changing Log Level</h2><p>The log level defaults to INFO, based on the ‘config_defaults’ of the log handler.  You can override this via config_defaults:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation, backend</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>, <span class=\"string\">'log.logging'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'log.logging'</span>][<span class=\"string\">'level'</span>] = <span class=\"string\">'WARNING'</span></div><div class=\"line\"></div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>, config_defaults=defaults)</div><div class=\"line\">app.setup()</div></pre></td></tr></table></figure>\n<p>This will also be overridden by the ‘level’ setting under a <code>[log.logging]</code> section in any of the applications configuration files that are parsed.</p>\n<p>You should also note that Cement includes a <code>--debug</code> command line option by default.  This triggers the log level to ‘DEBUG’ and is helpful for quickly debugging issues:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python test.py --debug</div><div class=\"line\">2012-07-13 02:19:42,270 (DEBUG) cement.core.foundation : laying cement for the &apos;myapp&apos; application</div><div class=\"line\">2012-07-13 02:19:42,270 (DEBUG) cement.core.hook : defining hook &apos;pre_setup&apos;</div><div class=\"line\">2012-07-13 02:19:42,270 (DEBUG) cement.core.hook : defining hook &apos;post_setup&apos;</div><div class=\"line\">2012-07-13 02:19:42,270 (DEBUG) cement.core.hook : defining hook &apos;pre_run&apos;</div><div class=\"line\">2012-07-13 02:19:42,270 (DEBUG) cement.core.hook : defining hook &apos;post_run&apos;</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook &apos;pre_close&apos;</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook &apos;post_close&apos;</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook &apos;signal&apos;</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook &apos;pre_render&apos;</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook &apos;post_render&apos;</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.handler : defining handler type &apos;extension&apos; (IExtension)</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.handler : defining handler type &apos;log&apos; (ILog)</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.handler : defining handler type &apos;config&apos; (IConfig)</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.handler : defining handler type &apos;plugin&apos; (IPlugin)</div><div class=\"line\">2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : defining handler type &apos;output&apos; (IOutput)</div><div class=\"line\">2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : defining handler type &apos;argument&apos; (IArgument)</div><div class=\"line\">2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : defining handler type &apos;controller&apos; (IController)</div><div class=\"line\">2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : defining handler type &apos;cache&apos; (ICache)</div><div class=\"line\">2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.core.extension.CementExtensionHandler&apos;&gt;&apos; into handlers[&apos;extension&apos;][&apos;cement&apos;]</div><div class=\"line\">2012-07-13 02:19:42,272 (DEBUG) cement.core.foundation : now setting up the &apos;myapp&apos; application</div><div class=\"line\">2012-07-13 02:19:42,272 (DEBUG) cement.core.foundation : adding signal handler for signal 15</div><div class=\"line\">2012-07-13 02:19:42,273 (DEBUG) cement.core.foundation : adding signal handler for signal 2</div><div class=\"line\">2012-07-13 02:19:42,273 (DEBUG) cement.core.foundation : setting up myapp.extension handler</div><div class=\"line\">2012-07-13 02:19:42,273 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_dummy&apos; framework extension</div><div class=\"line\">2012-07-13 02:19:42,273 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_dummy.DummyOutputHandler&apos;&gt;&apos; into handlers[&apos;output&apos;][&apos;null&apos;]</div><div class=\"line\">2012-07-13 02:19:42,273 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_plugin&apos; framework extension</div><div class=\"line\">2012-07-13 02:19:42,273 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_plugin.CementPluginHandler&apos;&gt;&apos; into handlers[&apos;plugin&apos;][&apos;cement&apos;]</div><div class=\"line\">2012-07-13 02:19:42,273 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_configparser&apos; framework extension</div><div class=\"line\">2012-07-13 02:19:42,274 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_configparser.ConfigParserConfigHandler&apos;&gt;&apos; into handlers[&apos;config&apos;][&apos;configparser&apos;]</div><div class=\"line\">2012-07-13 02:19:42,274 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_logging&apos; framework extension</div><div class=\"line\">2012-07-13 02:19:42,274 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_logging.LoggingLogHandler&apos;&gt;&apos; into handlers[&apos;log&apos;][&apos;logging&apos;]</div><div class=\"line\">2012-07-13 02:19:42,274 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_argparse&apos; framework extension</div><div class=\"line\">2012-07-13 02:19:42,276 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_argparse.ArgParseArgumentHandler&apos;&gt;&apos; into handlers[&apos;argument&apos;][&apos;argparse&apos;]</div><div class=\"line\">2012-07-13 02:19:42,276 (DEBUG) cement.core.foundation : setting up myapp.config handler</div><div class=\"line\">2012-07-13 02:19:42,276 (DEBUG) cement.ext.ext_configparser : config file &apos;/etc/myapp/myapp.conf&apos; does not exist, skipping...</div><div class=\"line\">2012-07-13 02:19:42,277 (DEBUG) cement.core.foundation : no cache handler defined, skipping.</div><div class=\"line\">2012-07-13 02:19:42,277 (DEBUG) cement.core.foundation : setting up myapp.log handler</div><div class=\"line\">2012-07-13 02:19:42,277 (DEBUG) cement.core.handler : merging config defaults from &apos;&lt;cement.ext.ext_logging.LoggingLogHandler object at 0x100588dd0&gt;&apos;</div><div class=\"line\">2012-07-13 02:19:42,277 (DEBUG) myapp : logging initialized for &apos;myapp&apos; using LoggingLogHandler</div><div class=\"line\">2012-07-13 02:19:42,278 (DEBUG) cement.core.foundation : setting up myapp.plugin handler</div><div class=\"line\">2012-07-13 02:19:42,278 (DEBUG) cement.ext.ext_plugin : plugin config dir /etc/myapp/plugins.d does not exist.</div><div class=\"line\">2012-07-13 02:19:42,278 (DEBUG) cement.core.foundation : setting up myapp.arg handler</div><div class=\"line\">2012-07-13 02:19:42,279 (DEBUG) cement.core.foundation : setting up myapp.output handler</div><div class=\"line\">2012-07-13 02:19:42,279 (DEBUG) cement.core.foundation : setting up application controllers</div><div class=\"line\">2012-07-13 02:19:42,279 (DEBUG) cement.core.foundation : no controller could be found.</div><div class=\"line\">2012-07-13 02:19:42,280 (DEBUG) cement.core.foundation : closing the application</div></pre></td></tr></table></figure>\n<p>You can see that debug logging is extremely verbose.  In the above you will note the message format is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">TIMESTAMP - LEVEL - MODULE - MESSAGE</div></pre></td></tr></table></figure>\n<p>The Cement framework only logs to DEBUG, where the MODULE is displayed as ‘cement.core.whatever’.  Note that Cement uses a minimal logger that is separate from the application log, therefore settings you change in your application do not affect it.</p>\n<h2 id=\"Logging-to-Console\"><a href=\"#Logging-to-Console\" class=\"headerlink\" title=\"Logging to Console\"></a>Logging to Console</h2><p>The default log handler configuration enables logging to console.  For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>)</div><div class=\"line\">app.setup()</div><div class=\"line\">app.run()</div><div class=\"line\">app.log.info(<span class=\"string\">'This is my info message'</span>)</div><div class=\"line\">app.close()</div></pre></td></tr></table></figure>\n<p>When running this script at command line you would get:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python test.py</div><div class=\"line\">INFO: This is my info message</div></pre></td></tr></table></figure>\n<p>This can be disabled by setting ‘to_console=False’ in either the application defaults, or in an application configuration file under the ‘[log.logging]’ section.</p>\n<h2 id=\"Logging-to-File\"><a href=\"#Logging-to-File\" class=\"headerlink\" title=\"Logging to File\"></a>Logging to File</h2><p>File logging is disabled by default, but is just one line to enable.  Simply set the ‘file’ setting under the ‘[log.logging]’ config section either by application defaults, or via a configuration file.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation, backend</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>, <span class=\"string\">'log.logging'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'log.logging'</span>][<span class=\"string\">'file'</span>] = <span class=\"string\">'my.log'</span></div><div class=\"line\"></div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>, config_defaults=defaults)</div><div class=\"line\">app.setup()</div><div class=\"line\">app.run()</div><div class=\"line\">app.log.info(<span class=\"string\">'This is my info message'</span>)</div><div class=\"line\">app.close()</div></pre></td></tr></table></figure>\n<p>Running this we will see:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python test.py</div><div class=\"line\">INFO: This is my info message</div><div class=\"line\"></div><div class=\"line\">$ cat my.log</div><div class=\"line\">2011-08-26 17:50:16,306 (INFO) myapp : This is my info message</div></pre></td></tr></table></figure>\n<p>Notice that the logging is a bit more verbose when logged to a file.</p>\n<h2 id=\"Tips-on-Debugging\"><a href=\"#Tips-on-Debugging\" class=\"headerlink\" title=\"Tips on Debugging\"></a>Tips on Debugging</h2><p>Note: The following is specific to the default <a href=\"/2.10/api/ext/ext_logging\">LoggingLogHandler</a> only, and is not an implementation of the ILog interface.</p>\n<p>Logging to ‘app.log.debug()’ is pretty straight forward, however adding an additional parameter for the ‘namespace’ can greatly increase insight into where that log is happening.  The ‘namespace’ defaults to the application name which you will see in every log like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">2012-07-30 18:05:11,357 (DEBUG) myapp : This is my message</div></pre></td></tr></table></figure>\n<p>For debugging, it might be more useful to change this to <strong>name</strong>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.log.debug(<span class=\"string\">'This is my info message'</span>, __name__)</div></pre></td></tr></table></figure>\n<p>Which looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">2012-07-30 18:05:11,357 (DEBUG) myapp.somepackage.test : This is my message</div></pre></td></tr></table></figure>\n<p>Or even more verbose, the <strong>file</strong> and a line number of the log:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.log.debug(<span class=\"string\">'This is my info message'</span>, <span class=\"string\">'%s,L2734'</span> % __file__)</div></pre></td></tr></table></figure>\n<p>Which looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">2012-07-30 18:05:11,357 (DEBUG) myapp/somepackage/test.py,L2345 : This is my message</div></pre></td></tr></table></figure>\n<p>You can override this with anything… it doesn’t have to be just for debugging.</p>\n","excerpt":"","more":"<p>Cement defines a logging interface called <a href=\"/2.10/api/core/log.html\">ILog</a>, as well as the default <a href=\"/2.10/api/ext/ext_logging.html\">LoggingLogHandler</a> that implements the interface.   This handler is built on top of the <a href=\"http://docs.python.org/library/logging.html\">Logging</a> module which is included in the Python standard library.</p>\n<p>Please note that there may be other handler’s that implement the ILog interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.</p>\n<p>The following log handlers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/ext/ext_logging.html\">LoggingLogHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_colorlog.html\">ColorLogHandler</a></li>\n</ul>\n<p>Please reference the <a href=\"/2.10/api/core/config.html\">ILog</a> interface documentation for writing your own log handler.</p>\n<h2 id=\"Logging-Messages\"><a href=\"#Logging-Messages\" class=\"headerlink\" title=\"Logging Messages\"></a>Logging Messages</h2><p>The following shows logging to each of the defined log levels.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># First setup the application</span></div><div class=\"line\">app.setup()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Run the application (even though it doesn't do much here)</span></div><div class=\"line\">app.run()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Log a debug message</span></div><div class=\"line\">app.log.debug(<span class=\"string\">'This is a debug message.'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Log an info message</span></div><div class=\"line\">app.log.info(<span class=\"string\">'This is an info message.'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Log a warning message</span></div><div class=\"line\">app.log.warning(<span class=\"string\">'This is a warning message.'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Log an error message</span></div><div class=\"line\">app.log.error(<span class=\"string\">'This is an error message.'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Log an fatal error message</span></div><div class=\"line\">app.log.fatal(<span class=\"string\">'This is a fatal message.'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Close the application</span></div><div class=\"line\">app.close()</div></pre></td></tr></table></figure>\n<p>The above is displayed in order of ‘severity’ you can say.  If the log level is set to ‘INFO’, you will receive all ‘info’ messages and above .. including warning, error, and fatal.  However, you will not receive DEBUG level messages. The same goes for a log level of ‘WARNING’, where you will receive warning, error, and fatal… but you will not receive INFO, or DEBUG level messages.</p>\n<h2 id=\"Changing-Log-Level\"><a href=\"#Changing-Log-Level\" class=\"headerlink\" title=\"Changing Log Level\"></a>Changing Log Level</h2><p>The log level defaults to INFO, based on the ‘config_defaults’ of the log handler.  You can override this via config_defaults:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation, backend</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>, <span class=\"string\">'log.logging'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'log.logging'</span>][<span class=\"string\">'level'</span>] = <span class=\"string\">'WARNING'</span></div><div class=\"line\"></div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>, config_defaults=defaults)</div><div class=\"line\">app.setup()</div></pre></td></tr></table></figure>\n<p>This will also be overridden by the ‘level’ setting under a <code>[log.logging]</code> section in any of the applications configuration files that are parsed.</p>\n<p>You should also note that Cement includes a <code>--debug</code> command line option by default.  This triggers the log level to ‘DEBUG’ and is helpful for quickly debugging issues:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python test.py --debug</div><div class=\"line\">2012-07-13 02:19:42,270 (DEBUG) cement.core.foundation : laying cement for the &apos;myapp&apos; application</div><div class=\"line\">2012-07-13 02:19:42,270 (DEBUG) cement.core.hook : defining hook &apos;pre_setup&apos;</div><div class=\"line\">2012-07-13 02:19:42,270 (DEBUG) cement.core.hook : defining hook &apos;post_setup&apos;</div><div class=\"line\">2012-07-13 02:19:42,270 (DEBUG) cement.core.hook : defining hook &apos;pre_run&apos;</div><div class=\"line\">2012-07-13 02:19:42,270 (DEBUG) cement.core.hook : defining hook &apos;post_run&apos;</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook &apos;pre_close&apos;</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook &apos;post_close&apos;</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook &apos;signal&apos;</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook &apos;pre_render&apos;</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.hook : defining hook &apos;post_render&apos;</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.handler : defining handler type &apos;extension&apos; (IExtension)</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.handler : defining handler type &apos;log&apos; (ILog)</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.handler : defining handler type &apos;config&apos; (IConfig)</div><div class=\"line\">2012-07-13 02:19:42,271 (DEBUG) cement.core.handler : defining handler type &apos;plugin&apos; (IPlugin)</div><div class=\"line\">2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : defining handler type &apos;output&apos; (IOutput)</div><div class=\"line\">2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : defining handler type &apos;argument&apos; (IArgument)</div><div class=\"line\">2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : defining handler type &apos;controller&apos; (IController)</div><div class=\"line\">2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : defining handler type &apos;cache&apos; (ICache)</div><div class=\"line\">2012-07-13 02:19:42,272 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.core.extension.CementExtensionHandler&apos;&gt;&apos; into handlers[&apos;extension&apos;][&apos;cement&apos;]</div><div class=\"line\">2012-07-13 02:19:42,272 (DEBUG) cement.core.foundation : now setting up the &apos;myapp&apos; application</div><div class=\"line\">2012-07-13 02:19:42,272 (DEBUG) cement.core.foundation : adding signal handler for signal 15</div><div class=\"line\">2012-07-13 02:19:42,273 (DEBUG) cement.core.foundation : adding signal handler for signal 2</div><div class=\"line\">2012-07-13 02:19:42,273 (DEBUG) cement.core.foundation : setting up myapp.extension handler</div><div class=\"line\">2012-07-13 02:19:42,273 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_dummy&apos; framework extension</div><div class=\"line\">2012-07-13 02:19:42,273 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_dummy.DummyOutputHandler&apos;&gt;&apos; into handlers[&apos;output&apos;][&apos;null&apos;]</div><div class=\"line\">2012-07-13 02:19:42,273 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_plugin&apos; framework extension</div><div class=\"line\">2012-07-13 02:19:42,273 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_plugin.CementPluginHandler&apos;&gt;&apos; into handlers[&apos;plugin&apos;][&apos;cement&apos;]</div><div class=\"line\">2012-07-13 02:19:42,273 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_configparser&apos; framework extension</div><div class=\"line\">2012-07-13 02:19:42,274 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_configparser.ConfigParserConfigHandler&apos;&gt;&apos; into handlers[&apos;config&apos;][&apos;configparser&apos;]</div><div class=\"line\">2012-07-13 02:19:42,274 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_logging&apos; framework extension</div><div class=\"line\">2012-07-13 02:19:42,274 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_logging.LoggingLogHandler&apos;&gt;&apos; into handlers[&apos;log&apos;][&apos;logging&apos;]</div><div class=\"line\">2012-07-13 02:19:42,274 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_argparse&apos; framework extension</div><div class=\"line\">2012-07-13 02:19:42,276 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_argparse.ArgParseArgumentHandler&apos;&gt;&apos; into handlers[&apos;argument&apos;][&apos;argparse&apos;]</div><div class=\"line\">2012-07-13 02:19:42,276 (DEBUG) cement.core.foundation : setting up myapp.config handler</div><div class=\"line\">2012-07-13 02:19:42,276 (DEBUG) cement.ext.ext_configparser : config file &apos;/etc/myapp/myapp.conf&apos; does not exist, skipping...</div><div class=\"line\">2012-07-13 02:19:42,277 (DEBUG) cement.core.foundation : no cache handler defined, skipping.</div><div class=\"line\">2012-07-13 02:19:42,277 (DEBUG) cement.core.foundation : setting up myapp.log handler</div><div class=\"line\">2012-07-13 02:19:42,277 (DEBUG) cement.core.handler : merging config defaults from &apos;&lt;cement.ext.ext_logging.LoggingLogHandler object at 0x100588dd0&gt;&apos;</div><div class=\"line\">2012-07-13 02:19:42,277 (DEBUG) myapp : logging initialized for &apos;myapp&apos; using LoggingLogHandler</div><div class=\"line\">2012-07-13 02:19:42,278 (DEBUG) cement.core.foundation : setting up myapp.plugin handler</div><div class=\"line\">2012-07-13 02:19:42,278 (DEBUG) cement.ext.ext_plugin : plugin config dir /etc/myapp/plugins.d does not exist.</div><div class=\"line\">2012-07-13 02:19:42,278 (DEBUG) cement.core.foundation : setting up myapp.arg handler</div><div class=\"line\">2012-07-13 02:19:42,279 (DEBUG) cement.core.foundation : setting up myapp.output handler</div><div class=\"line\">2012-07-13 02:19:42,279 (DEBUG) cement.core.foundation : setting up application controllers</div><div class=\"line\">2012-07-13 02:19:42,279 (DEBUG) cement.core.foundation : no controller could be found.</div><div class=\"line\">2012-07-13 02:19:42,280 (DEBUG) cement.core.foundation : closing the application</div></pre></td></tr></table></figure>\n<p>You can see that debug logging is extremely verbose.  In the above you will note the message format is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">TIMESTAMP - LEVEL - MODULE - MESSAGE</div></pre></td></tr></table></figure>\n<p>The Cement framework only logs to DEBUG, where the MODULE is displayed as ‘cement.core.whatever’.  Note that Cement uses a minimal logger that is separate from the application log, therefore settings you change in your application do not affect it.</p>\n<h2 id=\"Logging-to-Console\"><a href=\"#Logging-to-Console\" class=\"headerlink\" title=\"Logging to Console\"></a>Logging to Console</h2><p>The default log handler configuration enables logging to console.  For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>)</div><div class=\"line\">app.setup()</div><div class=\"line\">app.run()</div><div class=\"line\">app.log.info(<span class=\"string\">'This is my info message'</span>)</div><div class=\"line\">app.close()</div></pre></td></tr></table></figure>\n<p>When running this script at command line you would get:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python test.py</div><div class=\"line\">INFO: This is my info message</div></pre></td></tr></table></figure>\n<p>This can be disabled by setting ‘to_console=False’ in either the application defaults, or in an application configuration file under the ‘[log.logging]’ section.</p>\n<h2 id=\"Logging-to-File\"><a href=\"#Logging-to-File\" class=\"headerlink\" title=\"Logging to File\"></a>Logging to File</h2><p>File logging is disabled by default, but is just one line to enable.  Simply set the ‘file’ setting under the ‘[log.logging]’ config section either by application defaults, or via a configuration file.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation, backend</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>, <span class=\"string\">'log.logging'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'log.logging'</span>][<span class=\"string\">'file'</span>] = <span class=\"string\">'my.log'</span></div><div class=\"line\"></div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>, config_defaults=defaults)</div><div class=\"line\">app.setup()</div><div class=\"line\">app.run()</div><div class=\"line\">app.log.info(<span class=\"string\">'This is my info message'</span>)</div><div class=\"line\">app.close()</div></pre></td></tr></table></figure>\n<p>Running this we will see:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python test.py</div><div class=\"line\">INFO: This is my info message</div><div class=\"line\"></div><div class=\"line\">$ cat my.log</div><div class=\"line\">2011-08-26 17:50:16,306 (INFO) myapp : This is my info message</div></pre></td></tr></table></figure>\n<p>Notice that the logging is a bit more verbose when logged to a file.</p>\n<h2 id=\"Tips-on-Debugging\"><a href=\"#Tips-on-Debugging\" class=\"headerlink\" title=\"Tips on Debugging\"></a>Tips on Debugging</h2><p>Note: The following is specific to the default <a href=\"/2.10/api/ext/ext_logging\">LoggingLogHandler</a> only, and is not an implementation of the ILog interface.</p>\n<p>Logging to ‘app.log.debug()’ is pretty straight forward, however adding an additional parameter for the ‘namespace’ can greatly increase insight into where that log is happening.  The ‘namespace’ defaults to the application name which you will see in every log like this:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">2012-07-30 18:05:11,357 (DEBUG) myapp : This is my message</div></pre></td></tr></table></figure>\n<p>For debugging, it might be more useful to change this to <strong>name</strong>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.log.debug(<span class=\"string\">'This is my info message'</span>, __name__)</div></pre></td></tr></table></figure>\n<p>Which looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">2012-07-30 18:05:11,357 (DEBUG) myapp.somepackage.test : This is my message</div></pre></td></tr></table></figure>\n<p>Or even more verbose, the <strong>file</strong> and a line number of the log:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">app.log.debug(<span class=\"string\">'This is my info message'</span>, <span class=\"string\">'%s,L2734'</span> % __file__)</div></pre></td></tr></table></figure>\n<p>Which looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">2012-07-30 18:05:11,357 (DEBUG) myapp/somepackage/test.py,L2345 : This is my message</div></pre></td></tr></table></figure>\n<p>You can override this with anything… it doesn’t have to be just for debugging.</p>\n"},{"title":"Interfaces and Handlers","type":"guide","version":"2.10","order":4,"_content":"\nCement has a unique interface and handler system that is used to break up pieces of the framework and allow customization of how Cement handles everything from logging to config file parsing, and almost every action in between.\n\nThe Cement Interface code is loosely modeled after [Zope Interface](http://old.zope.org/Products/ZopeInterface) which allows a developer to define an interface that other developers can then create implementations for.  For example, an interface might define that a class have a function called `_setup()`.  Any implementation of that interface must provide a function called `_setup()`, and perform the expected actions when called.\n\nIn Cement, we call the implementation of interfaces `handlers` and provide the ability to easily register, and retrieve them via the app.\n\nAPI References:\n\n- [Cement Interface Module](/2.10/api/cement.core.interface)\n- [Cement Handler Module](/2.10/api/cement.core.handler)\n\n\n## Defining an Interface\n\nCement uses interfaces and handlers extensively to manage the framework, however developers can also make use of this system to provide a clean, and standardized way of allowing other developers to customize their application.\n\nThe following defines a basic interface:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.interface import Interface, Attribute\n\nclass MyInterface(Interface):\n    class IMeta:\n        label = 'myinterface'\n\n    # Must be provided by the implementation\n    Meta = Attribute('Handler Meta-data')\n    my_var = Attribute('A variable of epic proportions.')\n\n    def _setup(app_obj):\n        \"\"\"\n        The setup function is called during application initialization and\n        must 'setup' the handler object making it ready for the framework\n        or the application to make further calls to it.\n\n        Required Arguments:\n\n            app_obj\n                The application object.\n\n        Returns: n/a\n\n        \"\"\"\n\n    def do_something():\n        \"\"\"\n        This function does something.\n\n        \"\"\"\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        define_handlers = [MyInterface]\n\n\nAlternatively, if you need more control you might define a handler this way:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    # define interfaces after app is created\n    app.handler.define(MyInterface)\n\n    app.run()\n```\n\nThe above simply defines the interface.  It does *not* implement any functionality, and can't be used directly.  This is why the class functions do not have an argument of `self`, nor do they contain any code other than comments.\n\nThat said, what is required is an `IMeta` class that is used to interact with the interface.  At the very least, this must include a unique `label` to identify the interface.  This can also be considered the 'handler type'. For example, the `ILog` interface has a label of `log` and any handlers registered to that interface are stored in `HandlerManager.__handlers__['log']`.\n\nNotice that we defined `Meta` and `my_var` as Interface Attributes.  This is a simple identifier that describes an attribute that an implementation is expected to provide.\n\n\n## Validating Interfaces\n\nA validator call back function can be defined in the interfaces IMeta class like this:\n\n```python\nfrom cement.core import interface\n\ndef my_validator(klass, obj):\n    members = [\n        '_setup',\n        'do_something',\n        'my_var',\n        ]\n    interface.validate(MyInterface, obj, members)\n\nclass MyInterface(interface.Interface):\n    class IMeta:\n        label = 'myinterface'\n        validator = my_validator\n```\n\nWhen `CementApp.handler.register()` is called to register a handler to an interface, the validator is called and the handler object is passed to the  validator.  In the above example, we simply define what members we want to validate for and then call `interface.validate()` which will raise `cement.core.exc.InterfaceError` if validation fails.  It is not necessary to use `interface.validate()` but it is useful and recommended. In general, the key thing to note is that a validator either raises `InterfaceError` or does nothing if validation passes.\n\n\n## Registering Handlers to an Interface\n\nAn interface simply defines what an implementation is expected to provide, where a handler actually implements the interface.  The following example is a handler that implements the MyInterface above:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.handler import CementBaseHandler\nfrom myapp.interfaces import MyInterface\n\nclass MyHandler(CementBaseHandler):\n    class Meta:\n        interface = MyInterface\n        label = 'my_handler'\n        description = 'This handler implements MyInterface'\n        config_defaults = dict(\n            foo='bar'\n            )\n\n    my_var = 'This is my var'\n\n    def __init__(self):\n        self.app = None\n\n    def _setup(self, app_obj):\n        self.app = app_obj\n\n    def do_something(self):\n        print \"Doing work!\"\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        handlers = [MyHandler]\n```\n\nAlternatively, if you need more control you might use this approach:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    # register handler after the app is created\n    app.handler.register(MyHandler)\n\n    app.run()\n```\n\n\nThe above is a simple class that meets all the expectations of the interface. When calling `CementApp.handler.register()`, `MyHandler` is passed to the validator (if defined in the interface) and if it passes validation will be registered into `HandlerManager.__handlers__`.\n\n\n## Using Handlers\n\nThe following are a few examples of working with handlers:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    # Get a log handler called 'logging'\n    lh = app.handler.get('log', 'logging')\n\n    # Instantiate the handler class, passing any keyword arguments that \n    # the handler supports.\n    log = log_handler()\n\n    # Setup the handler, passing it the app object.\n    log._setup(app)\n\n    # List all handlers of type 'config'\n    app.handler.list('config')\n\n    # Check if an interface called 'output' is defined\n    app.handler.defined('output')\n\n    # Check if the handler 'argparse' is registered to the 'argument' \n    # interface\n    app.handler.registered('argument', 'argparse')\n```\n\nIt is important to note that handlers are stored with the app as uninstantiated objects.  Meaning you must instantiate them after retrieval, and call `_setup(app)` when using handlers directly (as in the above example).\n\n\n## Overriding Default Handlers\n\nCement sets up a number of default handlers for logging, config parsing, etc. These can be overridden in a number of ways.  The first way is by passing them as keyword arguments to `CementApp`:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom myapp.log import MyLogHandler\n\n# Create the application\napp = CementApp('myapp', log_handler=MyLogHandler)\napp.setup()\napp.run()\napp.close()\n```\n\nThe second way to override a handler is by setting it directly in the `CementApp` meta data:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom myapp.log import MyLogHandler\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        log_handler = MyLogHandler\n\nwith MyApp() as app:\n    app.run()\n```\n\n\nThere are times that you may want to pre-instantiate handlers before passing them to CementApp().  The following works just the same:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom myapp.log import MyLogHandler\n\nmy_log = MyLogHandler(some_param='some_value')\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        log_handler = my_log\n\nwith MyApp() as app:\n    app.run()\n```\n\nTo see what default handlers can be overridden, see the [cement.core.foundation](/2.10/api/cement.core.foundation) documentation.\n\n\n## Multiple Registered Handlers\n\nAll handlers and interfaces are unique.  In most cases, where the framework is concerned, only one handler is used.  For example, whatever is configured for the `log_handler` will be used and setup as `app.log`.  However, take for example an Output Handler.  You might have a default `output_handler` of `mustache`' (a text templating language) but may also want to override that handler with the `json` output handler when `-o json` is passed at command line.  In order to allow this functionality, both the `mustache` and `json` output handlers must be registered.\n\nAny number of handlers can be registered to an interface.  You might have a use case for an Interface/Handler that may provide different compatibility base on the operating system, or perhaps based on simply how the application is called.  A good example would be an application that automates building packages for Linux distributions.  An interface would define what a build handler needs to provide, but the build handler would be different based on the OS.  The application might have an `rpm` build handler, or a `dpkg` build handler to perform the build process differently.\n\n\n## Customizing Handlers\n\nThe most common way to customize a handler is to subclass it, and then pass it to `CementApp`:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.lib.ext_logging import LoggingLogHandler\n\nclass MyLogHandler(LoggingLogHandler):\n    class Meta:\n        label = 'mylog'\n\n    def info(self, msg):\n        # do something to customize this function, here...\n        super(MyLogHandler, self).info(msg)\n\napp = CementApp('myapp', log_handler=MyLogHandler)\n```\n\n## Handler Default Configuration Settings\n\nAll handlers can define default config file settings via their `config_defaults` meta option.  These will be merged into the `app.config` under the `[handler_interface].[handler_label]` section.  These settings are overridden in the following order.\n\n- The config_defaults dictionary passed to `CementApp`\n- Via any application config files with a `[handler_interface].[handler_type]` block (i.e. `cache.memcached`)\n\n\nThe following shows how to override defaults by passing them with the defaults dictionary to `CementApp`:\n\n```python\nfrom cement.core import foundation\nfrom cement.utils.misc import init_defaults\n\ndefaults = init_defaults('myinterface.myhandler')\ndefaults['myinterface.myhandler'] = dict(foo='bar')\napp = foundation.CementApp('myapp', config_defaults=defaults)\n```\n\nCement will use all defaults set via `MyHandler.Meta.config_defaults` (for this example), and then override just what is passed via `config_defaults['myinterface.myhandler']`.  You should use this approach only to modify the global defaults for your application.  The second way is to then set configuration file defaults under the `[myinterface.myhandler]` section.  For example:\n\n**my.config**\n\n```\n[myinterface.myhandler]\nfoo = bar\n```\n\nIn the real world this may look like `[cache.memcached]`, or `[database.mysql]` depending on what the interface label, and handler label's are.  Additionally, individual handlers can override their config section by setting `Meta.config_section`.\n\n\n## Overriding Handlers Via Command Line\n\nIn some use cases, you will want the end user to have access to override the default handler of a particular interface.  For example, Cement ships with multiple Output Handlers including `json`, `yaml`, and `mustache`.  A typical application might default to using `mustache` to render console output from text templates.  That said, without changing any code in the application, the end user can simply pass the `-o json` command line option and output the same data that is rendered to template, out in pure JSON.\n\nThe only built-in handler override that Cement includes is for the above mentioned example, but you can add any that your application requires.\n\nThe following example shows this in action... note that the following is already setup by Cement, but we're putting it here for clarity:\n\n```python\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n\n        # define what extensions we want to load\n        extensions = ['mustache', 'json', 'yaml']\n\n        # define our default output handler\n        output_handler = 'mustache'\n\n        # define our handler override options\n        handler_override_options = dict(\n            output = (['-o'], dict(help='output format')),\n            )\n\n\nwith MyApp() as app:\n    # run the application\n    app.run()\n\n    # define some data for the output handler\n    data = dict(foo='bar')\n\n    # render something using out output handlers, using mustache by\n    # default which will use the default.m templae\n    app.render(data, 'default.m')\n```\n\n\nNote what we see at command line:\n\n```\n$ python myapp.py --help\nusage: myapp.py [-h] [--debug] [--quiet] [-o {yaml,json}]\n\noptional arguments:\n  -h, --help      show this help message and exit\n  --debug         toggle debug output\n  --quiet         suppress all output\n  -o {yaml,json}  output format\n\n```\n\nNotice the `-o` command line option, that includes the choices: `yaml` and `json`.  This feature will include all Output Handlers that have the `overridable` meta-data option set to `True`.  The MustacheOutputHandler does not set this option, therefore it does not show up as a valid choice.\n\nNow what happens when we run it?\n\n```\n$ python myapp.py\nThis text is being rendered via Mustache.\nThe value of the 'foo' variable is => 'bar'\n```\n\nThe above is the default output, using `mustache` as our `output_handler`, and rendering the output text from a template called `default.m`.  We can now override the output handler using the `-o` option and modify the output format:\n\n```\n$ python myapp.py -o json\n{\"foo\": \"bar\"}\n```\n\nAgain, any handler can be overridden in this fashion.\n","source":"2.10/dev/interfaces_and_handlers.md","raw":"---\ntitle: Interfaces and Handlers\ntype: guide\nversion: \"2.10\"\norder: 4\n---\n\nCement has a unique interface and handler system that is used to break up pieces of the framework and allow customization of how Cement handles everything from logging to config file parsing, and almost every action in between.\n\nThe Cement Interface code is loosely modeled after [Zope Interface](http://old.zope.org/Products/ZopeInterface) which allows a developer to define an interface that other developers can then create implementations for.  For example, an interface might define that a class have a function called `_setup()`.  Any implementation of that interface must provide a function called `_setup()`, and perform the expected actions when called.\n\nIn Cement, we call the implementation of interfaces `handlers` and provide the ability to easily register, and retrieve them via the app.\n\nAPI References:\n\n- [Cement Interface Module](/2.10/api/cement.core.interface)\n- [Cement Handler Module](/2.10/api/cement.core.handler)\n\n\n## Defining an Interface\n\nCement uses interfaces and handlers extensively to manage the framework, however developers can also make use of this system to provide a clean, and standardized way of allowing other developers to customize their application.\n\nThe following defines a basic interface:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.interface import Interface, Attribute\n\nclass MyInterface(Interface):\n    class IMeta:\n        label = 'myinterface'\n\n    # Must be provided by the implementation\n    Meta = Attribute('Handler Meta-data')\n    my_var = Attribute('A variable of epic proportions.')\n\n    def _setup(app_obj):\n        \"\"\"\n        The setup function is called during application initialization and\n        must 'setup' the handler object making it ready for the framework\n        or the application to make further calls to it.\n\n        Required Arguments:\n\n            app_obj\n                The application object.\n\n        Returns: n/a\n\n        \"\"\"\n\n    def do_something():\n        \"\"\"\n        This function does something.\n\n        \"\"\"\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        define_handlers = [MyInterface]\n\n\nAlternatively, if you need more control you might define a handler this way:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    # define interfaces after app is created\n    app.handler.define(MyInterface)\n\n    app.run()\n```\n\nThe above simply defines the interface.  It does *not* implement any functionality, and can't be used directly.  This is why the class functions do not have an argument of `self`, nor do they contain any code other than comments.\n\nThat said, what is required is an `IMeta` class that is used to interact with the interface.  At the very least, this must include a unique `label` to identify the interface.  This can also be considered the 'handler type'. For example, the `ILog` interface has a label of `log` and any handlers registered to that interface are stored in `HandlerManager.__handlers__['log']`.\n\nNotice that we defined `Meta` and `my_var` as Interface Attributes.  This is a simple identifier that describes an attribute that an implementation is expected to provide.\n\n\n## Validating Interfaces\n\nA validator call back function can be defined in the interfaces IMeta class like this:\n\n```python\nfrom cement.core import interface\n\ndef my_validator(klass, obj):\n    members = [\n        '_setup',\n        'do_something',\n        'my_var',\n        ]\n    interface.validate(MyInterface, obj, members)\n\nclass MyInterface(interface.Interface):\n    class IMeta:\n        label = 'myinterface'\n        validator = my_validator\n```\n\nWhen `CementApp.handler.register()` is called to register a handler to an interface, the validator is called and the handler object is passed to the  validator.  In the above example, we simply define what members we want to validate for and then call `interface.validate()` which will raise `cement.core.exc.InterfaceError` if validation fails.  It is not necessary to use `interface.validate()` but it is useful and recommended. In general, the key thing to note is that a validator either raises `InterfaceError` or does nothing if validation passes.\n\n\n## Registering Handlers to an Interface\n\nAn interface simply defines what an implementation is expected to provide, where a handler actually implements the interface.  The following example is a handler that implements the MyInterface above:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.handler import CementBaseHandler\nfrom myapp.interfaces import MyInterface\n\nclass MyHandler(CementBaseHandler):\n    class Meta:\n        interface = MyInterface\n        label = 'my_handler'\n        description = 'This handler implements MyInterface'\n        config_defaults = dict(\n            foo='bar'\n            )\n\n    my_var = 'This is my var'\n\n    def __init__(self):\n        self.app = None\n\n    def _setup(self, app_obj):\n        self.app = app_obj\n\n    def do_something(self):\n        print \"Doing work!\"\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        handlers = [MyHandler]\n```\n\nAlternatively, if you need more control you might use this approach:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    # register handler after the app is created\n    app.handler.register(MyHandler)\n\n    app.run()\n```\n\n\nThe above is a simple class that meets all the expectations of the interface. When calling `CementApp.handler.register()`, `MyHandler` is passed to the validator (if defined in the interface) and if it passes validation will be registered into `HandlerManager.__handlers__`.\n\n\n## Using Handlers\n\nThe following are a few examples of working with handlers:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    # Get a log handler called 'logging'\n    lh = app.handler.get('log', 'logging')\n\n    # Instantiate the handler class, passing any keyword arguments that \n    # the handler supports.\n    log = log_handler()\n\n    # Setup the handler, passing it the app object.\n    log._setup(app)\n\n    # List all handlers of type 'config'\n    app.handler.list('config')\n\n    # Check if an interface called 'output' is defined\n    app.handler.defined('output')\n\n    # Check if the handler 'argparse' is registered to the 'argument' \n    # interface\n    app.handler.registered('argument', 'argparse')\n```\n\nIt is important to note that handlers are stored with the app as uninstantiated objects.  Meaning you must instantiate them after retrieval, and call `_setup(app)` when using handlers directly (as in the above example).\n\n\n## Overriding Default Handlers\n\nCement sets up a number of default handlers for logging, config parsing, etc. These can be overridden in a number of ways.  The first way is by passing them as keyword arguments to `CementApp`:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom myapp.log import MyLogHandler\n\n# Create the application\napp = CementApp('myapp', log_handler=MyLogHandler)\napp.setup()\napp.run()\napp.close()\n```\n\nThe second way to override a handler is by setting it directly in the `CementApp` meta data:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom myapp.log import MyLogHandler\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        log_handler = MyLogHandler\n\nwith MyApp() as app:\n    app.run()\n```\n\n\nThere are times that you may want to pre-instantiate handlers before passing them to CementApp().  The following works just the same:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom myapp.log import MyLogHandler\n\nmy_log = MyLogHandler(some_param='some_value')\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        log_handler = my_log\n\nwith MyApp() as app:\n    app.run()\n```\n\nTo see what default handlers can be overridden, see the [cement.core.foundation](/2.10/api/cement.core.foundation) documentation.\n\n\n## Multiple Registered Handlers\n\nAll handlers and interfaces are unique.  In most cases, where the framework is concerned, only one handler is used.  For example, whatever is configured for the `log_handler` will be used and setup as `app.log`.  However, take for example an Output Handler.  You might have a default `output_handler` of `mustache`' (a text templating language) but may also want to override that handler with the `json` output handler when `-o json` is passed at command line.  In order to allow this functionality, both the `mustache` and `json` output handlers must be registered.\n\nAny number of handlers can be registered to an interface.  You might have a use case for an Interface/Handler that may provide different compatibility base on the operating system, or perhaps based on simply how the application is called.  A good example would be an application that automates building packages for Linux distributions.  An interface would define what a build handler needs to provide, but the build handler would be different based on the OS.  The application might have an `rpm` build handler, or a `dpkg` build handler to perform the build process differently.\n\n\n## Customizing Handlers\n\nThe most common way to customize a handler is to subclass it, and then pass it to `CementApp`:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.lib.ext_logging import LoggingLogHandler\n\nclass MyLogHandler(LoggingLogHandler):\n    class Meta:\n        label = 'mylog'\n\n    def info(self, msg):\n        # do something to customize this function, here...\n        super(MyLogHandler, self).info(msg)\n\napp = CementApp('myapp', log_handler=MyLogHandler)\n```\n\n## Handler Default Configuration Settings\n\nAll handlers can define default config file settings via their `config_defaults` meta option.  These will be merged into the `app.config` under the `[handler_interface].[handler_label]` section.  These settings are overridden in the following order.\n\n- The config_defaults dictionary passed to `CementApp`\n- Via any application config files with a `[handler_interface].[handler_type]` block (i.e. `cache.memcached`)\n\n\nThe following shows how to override defaults by passing them with the defaults dictionary to `CementApp`:\n\n```python\nfrom cement.core import foundation\nfrom cement.utils.misc import init_defaults\n\ndefaults = init_defaults('myinterface.myhandler')\ndefaults['myinterface.myhandler'] = dict(foo='bar')\napp = foundation.CementApp('myapp', config_defaults=defaults)\n```\n\nCement will use all defaults set via `MyHandler.Meta.config_defaults` (for this example), and then override just what is passed via `config_defaults['myinterface.myhandler']`.  You should use this approach only to modify the global defaults for your application.  The second way is to then set configuration file defaults under the `[myinterface.myhandler]` section.  For example:\n\n**my.config**\n\n```\n[myinterface.myhandler]\nfoo = bar\n```\n\nIn the real world this may look like `[cache.memcached]`, or `[database.mysql]` depending on what the interface label, and handler label's are.  Additionally, individual handlers can override their config section by setting `Meta.config_section`.\n\n\n## Overriding Handlers Via Command Line\n\nIn some use cases, you will want the end user to have access to override the default handler of a particular interface.  For example, Cement ships with multiple Output Handlers including `json`, `yaml`, and `mustache`.  A typical application might default to using `mustache` to render console output from text templates.  That said, without changing any code in the application, the end user can simply pass the `-o json` command line option and output the same data that is rendered to template, out in pure JSON.\n\nThe only built-in handler override that Cement includes is for the above mentioned example, but you can add any that your application requires.\n\nThe following example shows this in action... note that the following is already setup by Cement, but we're putting it here for clarity:\n\n```python\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n\n        # define what extensions we want to load\n        extensions = ['mustache', 'json', 'yaml']\n\n        # define our default output handler\n        output_handler = 'mustache'\n\n        # define our handler override options\n        handler_override_options = dict(\n            output = (['-o'], dict(help='output format')),\n            )\n\n\nwith MyApp() as app:\n    # run the application\n    app.run()\n\n    # define some data for the output handler\n    data = dict(foo='bar')\n\n    # render something using out output handlers, using mustache by\n    # default which will use the default.m templae\n    app.render(data, 'default.m')\n```\n\n\nNote what we see at command line:\n\n```\n$ python myapp.py --help\nusage: myapp.py [-h] [--debug] [--quiet] [-o {yaml,json}]\n\noptional arguments:\n  -h, --help      show this help message and exit\n  --debug         toggle debug output\n  --quiet         suppress all output\n  -o {yaml,json}  output format\n\n```\n\nNotice the `-o` command line option, that includes the choices: `yaml` and `json`.  This feature will include all Output Handlers that have the `overridable` meta-data option set to `True`.  The MustacheOutputHandler does not set this option, therefore it does not show up as a valid choice.\n\nNow what happens when we run it?\n\n```\n$ python myapp.py\nThis text is being rendered via Mustache.\nThe value of the 'foo' variable is => 'bar'\n```\n\nThe above is the default output, using `mustache` as our `output_handler`, and rendering the output text from a template called `default.m`.  We can now override the output handler using the `-o` option and modify the output format:\n\n```\n$ python myapp.py -o json\n{\"foo\": \"bar\"}\n```\n\nAgain, any handler can be overridden in this fashion.\n","date":"2017-06-25T00:25:43.000Z","updated":"2017-06-25T00:25:43.000Z","path":"2.10/dev/interfaces_and_handlers.html","comments":1,"layout":"page","_id":"cj5dg8qrx000bh6pwir1chgk1","content":"<p>Cement has a unique interface and handler system that is used to break up pieces of the framework and allow customization of how Cement handles everything from logging to config file parsing, and almost every action in between.</p>\n<p>The Cement Interface code is loosely modeled after <a href=\"http://old.zope.org/Products/ZopeInterface\" target=\"_blank\" rel=\"external\">Zope Interface</a> which allows a developer to define an interface that other developers can then create implementations for.  For example, an interface might define that a class have a function called <code>_setup()</code>.  Any implementation of that interface must provide a function called <code>_setup()</code>, and perform the expected actions when called.</p>\n<p>In Cement, we call the implementation of interfaces <code>handlers</code> and provide the ability to easily register, and retrieve them via the app.</p>\n<p>API References:</p>\n<ul>\n<li><a href=\"/2.10/api/cement.core.interface\">Cement Interface Module</a></li>\n<li><a href=\"/2.10/api/cement.core.handler\">Cement Handler Module</a></li>\n</ul>\n<h2 id=\"Defining-an-Interface\"><a href=\"#Defining-an-Interface\" class=\"headerlink\" title=\"Defining an Interface\"></a>Defining an Interface</h2><p>Cement uses interfaces and handlers extensively to manage the framework, however developers can also make use of this system to provide a clean, and standardized way of allowing other developers to customize their application.</p>\n<p>The following defines a basic interface:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.interface <span class=\"keyword\">import</span> Interface, Attribute</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInterface</span><span class=\"params\">(Interface)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IMeta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myinterface'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Must be provided by the implementation</span></div><div class=\"line\">    Meta = Attribute(<span class=\"string\">'Handler Meta-data'</span>)</div><div class=\"line\">    my_var = Attribute(<span class=\"string\">'A variable of epic proportions.'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_setup</span><span class=\"params\">(app_obj)</span>:</span></div><div class=\"line\">        <span class=\"string\">\"\"\"</span></div><div class=\"line\">        The setup function is called during application initialization and</div><div class=\"line\">        must 'setup' the handler object making it ready for the framework</div><div class=\"line\">        or the application to make further calls to it.</div><div class=\"line\"></div><div class=\"line\">        Required Arguments:</div><div class=\"line\"></div><div class=\"line\">            app_obj</div><div class=\"line\">                The application object.</div><div class=\"line\"></div><div class=\"line\">        Returns: n/a</div><div class=\"line\"></div><div class=\"line\">        \"\"\"</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_something</span><span class=\"params\">()</span>:</span></div><div class=\"line\">        <span class=\"string\">\"\"\"</span></div><div class=\"line\">        This function does something.</div><div class=\"line\"></div><div class=\"line\">        \"\"\"</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        define_handlers = [MyInterface]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">Alternatively, <span class=\"keyword\">if</span> you need more control you might define a handler this way:</div><div class=\"line\"></div><div class=\"line\">```python</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># define interfaces after app is created</span></div><div class=\"line\">    app.handler.define(MyInterface)</div><div class=\"line\"></div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>The above simply defines the interface.  It does <em>not</em> implement any functionality, and can’t be used directly.  This is why the class functions do not have an argument of <code>self</code>, nor do they contain any code other than comments.</p>\n<p>That said, what is required is an <code>IMeta</code> class that is used to interact with the interface.  At the very least, this must include a unique <code>label</code> to identify the interface.  This can also be considered the ‘handler type’. For example, the <code>ILog</code> interface has a label of <code>log</code> and any handlers registered to that interface are stored in <code>HandlerManager.__handlers__[&#39;log&#39;]</code>.</p>\n<p>Notice that we defined <code>Meta</code> and <code>my_var</code> as Interface Attributes.  This is a simple identifier that describes an attribute that an implementation is expected to provide.</p>\n<h2 id=\"Validating-Interfaces\"><a href=\"#Validating-Interfaces\" class=\"headerlink\" title=\"Validating Interfaces\"></a>Validating Interfaces</h2><p>A validator call back function can be defined in the interfaces IMeta class like this:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> interface</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_validator</span><span class=\"params\">(klass, obj)</span>:</span></div><div class=\"line\">    members = [</div><div class=\"line\">        <span class=\"string\">'_setup'</span>,</div><div class=\"line\">        <span class=\"string\">'do_something'</span>,</div><div class=\"line\">        <span class=\"string\">'my_var'</span>,</div><div class=\"line\">        ]</div><div class=\"line\">    interface.validate(MyInterface, obj, members)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInterface</span><span class=\"params\">(interface.Interface)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IMeta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myinterface'</span></div><div class=\"line\">        validator = my_validator</div></pre></td></tr></table></figure>\n<p>When <code>CementApp.handler.register()</code> is called to register a handler to an interface, the validator is called and the handler object is passed to the  validator.  In the above example, we simply define what members we want to validate for and then call <code>interface.validate()</code> which will raise <code>cement.core.exc.InterfaceError</code> if validation fails.  It is not necessary to use <code>interface.validate()</code> but it is useful and recommended. In general, the key thing to note is that a validator either raises <code>InterfaceError</code> or does nothing if validation passes.</p>\n<h2 id=\"Registering-Handlers-to-an-Interface\"><a href=\"#Registering-Handlers-to-an-Interface\" class=\"headerlink\" title=\"Registering Handlers to an Interface\"></a>Registering Handlers to an Interface</h2><p>An interface simply defines what an implementation is expected to provide, where a handler actually implements the interface.  The following example is a handler that implements the MyInterface above:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.handler <span class=\"keyword\">import</span> CementBaseHandler</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.interfaces <span class=\"keyword\">import</span> MyInterface</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span><span class=\"params\">(CementBaseHandler)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        interface = MyInterface</div><div class=\"line\">        label = <span class=\"string\">'my_handler'</span></div><div class=\"line\">        description = <span class=\"string\">'This handler implements MyInterface'</span></div><div class=\"line\">        config_defaults = dict(</div><div class=\"line\">            foo=<span class=\"string\">'bar'</span></div><div class=\"line\">            )</div><div class=\"line\"></div><div class=\"line\">    my_var = <span class=\"string\">'This is my var'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app = <span class=\"keyword\">None</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_setup</span><span class=\"params\">(self, app_obj)</span>:</span></div><div class=\"line\">        self.app = app_obj</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_something</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Doing work!\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        handlers = [MyHandler]</div></pre></td></tr></table></figure>\n<p>Alternatively, if you need more control you might use this approach:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># register handler after the app is created</span></div><div class=\"line\">    app.handler.register(MyHandler)</div><div class=\"line\"></div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>The above is a simple class that meets all the expectations of the interface. When calling <code>CementApp.handler.register()</code>, <code>MyHandler</code> is passed to the validator (if defined in the interface) and if it passes validation will be registered into <code>HandlerManager.__handlers__</code>.</p>\n<h2 id=\"Using-Handlers\"><a href=\"#Using-Handlers\" class=\"headerlink\" title=\"Using Handlers\"></a>Using Handlers</h2><p>The following are a few examples of working with handlers:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># Get a log handler called 'logging'</span></div><div class=\"line\">    lh = app.handler.get(<span class=\"string\">'log'</span>, <span class=\"string\">'logging'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Instantiate the handler class, passing any keyword arguments that </span></div><div class=\"line\">    <span class=\"comment\"># the handler supports.</span></div><div class=\"line\">    log = log_handler()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Setup the handler, passing it the app object.</span></div><div class=\"line\">    log._setup(app)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># List all handlers of type 'config'</span></div><div class=\"line\">    app.handler.list(<span class=\"string\">'config'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Check if an interface called 'output' is defined</span></div><div class=\"line\">    app.handler.defined(<span class=\"string\">'output'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Check if the handler 'argparse' is registered to the 'argument' </span></div><div class=\"line\">    <span class=\"comment\"># interface</span></div><div class=\"line\">    app.handler.registered(<span class=\"string\">'argument'</span>, <span class=\"string\">'argparse'</span>)</div></pre></td></tr></table></figure>\n<p>It is important to note that handlers are stored with the app as uninstantiated objects.  Meaning you must instantiate them after retrieval, and call <code>_setup(app)</code> when using handlers directly (as in the above example).</p>\n<h2 id=\"Overriding-Default-Handlers\"><a href=\"#Overriding-Default-Handlers\" class=\"headerlink\" title=\"Overriding Default Handlers\"></a>Overriding Default Handlers</h2><p>Cement sets up a number of default handlers for logging, config parsing, etc. These can be overridden in a number of ways.  The first way is by passing them as keyword arguments to <code>CementApp</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.log <span class=\"keyword\">import</span> MyLogHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Create the application</span></div><div class=\"line\">app = CementApp(<span class=\"string\">'myapp'</span>, log_handler=MyLogHandler)</div><div class=\"line\">app.setup()</div><div class=\"line\">app.run()</div><div class=\"line\">app.close()</div></pre></td></tr></table></figure>\n<p>The second way to override a handler is by setting it directly in the <code>CementApp</code> meta data:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.log <span class=\"keyword\">import</span> MyLogHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        log_handler = MyLogHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>There are times that you may want to pre-instantiate handlers before passing them to CementApp().  The following works just the same:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.log <span class=\"keyword\">import</span> MyLogHandler</div><div class=\"line\"></div><div class=\"line\">my_log = MyLogHandler(some_param=<span class=\"string\">'some_value'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        log_handler = my_log</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>To see what default handlers can be overridden, see the <a href=\"/2.10/api/cement.core.foundation\">cement.core.foundation</a> documentation.</p>\n<h2 id=\"Multiple-Registered-Handlers\"><a href=\"#Multiple-Registered-Handlers\" class=\"headerlink\" title=\"Multiple Registered Handlers\"></a>Multiple Registered Handlers</h2><p>All handlers and interfaces are unique.  In most cases, where the framework is concerned, only one handler is used.  For example, whatever is configured for the <code>log_handler</code> will be used and setup as <code>app.log</code>.  However, take for example an Output Handler.  You might have a default <code>output_handler</code> of <code>mustache</code>‘ (a text templating language) but may also want to override that handler with the <code>json</code> output handler when <code>-o json</code> is passed at command line.  In order to allow this functionality, both the <code>mustache</code> and <code>json</code> output handlers must be registered.</p>\n<p>Any number of handlers can be registered to an interface.  You might have a use case for an Interface/Handler that may provide different compatibility base on the operating system, or perhaps based on simply how the application is called.  A good example would be an application that automates building packages for Linux distributions.  An interface would define what a build handler needs to provide, but the build handler would be different based on the OS.  The application might have an <code>rpm</code> build handler, or a <code>dpkg</code> build handler to perform the build process differently.</p>\n<h2 id=\"Customizing-Handlers\"><a href=\"#Customizing-Handlers\" class=\"headerlink\" title=\"Customizing Handlers\"></a>Customizing Handlers</h2><p>The most common way to customize a handler is to subclass it, and then pass it to <code>CementApp</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.lib.ext_logging <span class=\"keyword\">import</span> LoggingLogHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyLogHandler</span><span class=\"params\">(LoggingLogHandler)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'mylog'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">info</span><span class=\"params\">(self, msg)</span>:</span></div><div class=\"line\">        <span class=\"comment\"># do something to customize this function, here...</span></div><div class=\"line\">        super(MyLogHandler, self).info(msg)</div><div class=\"line\"></div><div class=\"line\">app = CementApp(<span class=\"string\">'myapp'</span>, log_handler=MyLogHandler)</div></pre></td></tr></table></figure>\n<h2 id=\"Handler-Default-Configuration-Settings\"><a href=\"#Handler-Default-Configuration-Settings\" class=\"headerlink\" title=\"Handler Default Configuration Settings\"></a>Handler Default Configuration Settings</h2><p>All handlers can define default config file settings via their <code>config_defaults</code> meta option.  These will be merged into the <code>app.config</code> under the <code>[handler_interface].[handler_label]</code> section.  These settings are overridden in the following order.</p>\n<ul>\n<li>The config_defaults dictionary passed to <code>CementApp</code></li>\n<li>Via any application config files with a <code>[handler_interface].[handler_type]</code> block (i.e. <code>cache.memcached</code>)</li>\n</ul>\n<p>The following shows how to override defaults by passing them with the defaults dictionary to <code>CementApp</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myinterface.myhandler'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'myinterface.myhandler'</span>] = dict(foo=<span class=\"string\">'bar'</span>)</div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>, config_defaults=defaults)</div></pre></td></tr></table></figure>\n<p>Cement will use all defaults set via <code>MyHandler.Meta.config_defaults</code> (for this example), and then override just what is passed via <code>config_defaults[&#39;myinterface.myhandler&#39;]</code>.  You should use this approach only to modify the global defaults for your application.  The second way is to then set configuration file defaults under the <code>[myinterface.myhandler]</code> section.  For example:</p>\n<p><strong>my.config</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myinterface.myhandler]</div><div class=\"line\">foo = bar</div></pre></td></tr></table></figure>\n<p>In the real world this may look like <code>[cache.memcached]</code>, or <code>[database.mysql]</code> depending on what the interface label, and handler label’s are.  Additionally, individual handlers can override their config section by setting <code>Meta.config_section</code>.</p>\n<h2 id=\"Overriding-Handlers-Via-Command-Line\"><a href=\"#Overriding-Handlers-Via-Command-Line\" class=\"headerlink\" title=\"Overriding Handlers Via Command Line\"></a>Overriding Handlers Via Command Line</h2><p>In some use cases, you will want the end user to have access to override the default handler of a particular interface.  For example, Cement ships with multiple Output Handlers including <code>json</code>, <code>yaml</code>, and <code>mustache</code>.  A typical application might default to using <code>mustache</code> to render console output from text templates.  That said, without changing any code in the application, the end user can simply pass the <code>-o json</code> command line option and output the same data that is rendered to template, out in pure JSON.</p>\n<p>The only built-in handler override that Cement includes is for the above mentioned example, but you can add any that your application requires.</p>\n<p>The following example shows this in action… note that the following is already setup by Cement, but we’re putting it here for clarity:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># define what extensions we want to load</span></div><div class=\"line\">        extensions = [<span class=\"string\">'mustache'</span>, <span class=\"string\">'json'</span>, <span class=\"string\">'yaml'</span>]</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># define our default output handler</span></div><div class=\"line\">        output_handler = <span class=\"string\">'mustache'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># define our handler override options</span></div><div class=\"line\">        handler_override_options = dict(</div><div class=\"line\">            output = ([<span class=\"string\">'-o'</span>], dict(help=<span class=\"string\">'output format'</span>)),</div><div class=\"line\">            )</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># run the application</span></div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># define some data for the output handler</span></div><div class=\"line\">    data = dict(foo=<span class=\"string\">'bar'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># render something using out output handlers, using mustache by</span></div><div class=\"line\">    <span class=\"comment\"># default which will use the default.m templae</span></div><div class=\"line\">    app.render(data, <span class=\"string\">'default.m'</span>)</div></pre></td></tr></table></figure>\n<p>Note what we see at command line:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py [-h] [--debug] [--quiet] [-o &#123;yaml,json&#125;]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help      show this help message and exit</div><div class=\"line\">  --debug         toggle debug output</div><div class=\"line\">  --quiet         suppress all output</div><div class=\"line\">  -o &#123;yaml,json&#125;  output format</div></pre></td></tr></table></figure>\n<p>Notice the <code>-o</code> command line option, that includes the choices: <code>yaml</code> and <code>json</code>.  This feature will include all Output Handlers that have the <code>overridable</code> meta-data option set to <code>True</code>.  The MustacheOutputHandler does not set this option, therefore it does not show up as a valid choice.</p>\n<p>Now what happens when we run it?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">This text is being rendered via Mustache.</div><div class=\"line\">The value of the &apos;foo&apos; variable is =&gt; &apos;bar&apos;</div></pre></td></tr></table></figure>\n<p>The above is the default output, using <code>mustache</code> as our <code>output_handler</code>, and rendering the output text from a template called <code>default.m</code>.  We can now override the output handler using the <code>-o</code> option and modify the output format:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py -o json</div><div class=\"line\">&#123;&quot;foo&quot;: &quot;bar&quot;&#125;</div></pre></td></tr></table></figure>\n<p>Again, any handler can be overridden in this fashion.</p>\n","excerpt":"","more":"<p>Cement has a unique interface and handler system that is used to break up pieces of the framework and allow customization of how Cement handles everything from logging to config file parsing, and almost every action in between.</p>\n<p>The Cement Interface code is loosely modeled after <a href=\"http://old.zope.org/Products/ZopeInterface\">Zope Interface</a> which allows a developer to define an interface that other developers can then create implementations for.  For example, an interface might define that a class have a function called <code>_setup()</code>.  Any implementation of that interface must provide a function called <code>_setup()</code>, and perform the expected actions when called.</p>\n<p>In Cement, we call the implementation of interfaces <code>handlers</code> and provide the ability to easily register, and retrieve them via the app.</p>\n<p>API References:</p>\n<ul>\n<li><a href=\"/2.10/api/cement.core.interface\">Cement Interface Module</a></li>\n<li><a href=\"/2.10/api/cement.core.handler\">Cement Handler Module</a></li>\n</ul>\n<h2 id=\"Defining-an-Interface\"><a href=\"#Defining-an-Interface\" class=\"headerlink\" title=\"Defining an Interface\"></a>Defining an Interface</h2><p>Cement uses interfaces and handlers extensively to manage the framework, however developers can also make use of this system to provide a clean, and standardized way of allowing other developers to customize their application.</p>\n<p>The following defines a basic interface:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.interface <span class=\"keyword\">import</span> Interface, Attribute</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInterface</span><span class=\"params\">(Interface)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IMeta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myinterface'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Must be provided by the implementation</span></div><div class=\"line\">    Meta = Attribute(<span class=\"string\">'Handler Meta-data'</span>)</div><div class=\"line\">    my_var = Attribute(<span class=\"string\">'A variable of epic proportions.'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_setup</span><span class=\"params\">(app_obj)</span>:</span></div><div class=\"line\">        <span class=\"string\">\"\"\"</div><div class=\"line\">        The setup function is called during application initialization and</div><div class=\"line\">        must 'setup' the handler object making it ready for the framework</div><div class=\"line\">        or the application to make further calls to it.</div><div class=\"line\"></div><div class=\"line\">        Required Arguments:</div><div class=\"line\"></div><div class=\"line\">            app_obj</div><div class=\"line\">                The application object.</div><div class=\"line\"></div><div class=\"line\">        Returns: n/a</div><div class=\"line\"></div><div class=\"line\">        \"\"\"</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_something</span><span class=\"params\">()</span>:</span></div><div class=\"line\">        <span class=\"string\">\"\"\"</div><div class=\"line\">        This function does something.</div><div class=\"line\"></div><div class=\"line\">        \"\"\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        define_handlers = [MyInterface]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">Alternatively, <span class=\"keyword\">if</span> you need more control you might define a handler this way:</div><div class=\"line\"></div><div class=\"line\">```python</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># define interfaces after app is created</span></div><div class=\"line\">    app.handler.define(MyInterface)</div><div class=\"line\"></div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>The above simply defines the interface.  It does <em>not</em> implement any functionality, and can’t be used directly.  This is why the class functions do not have an argument of <code>self</code>, nor do they contain any code other than comments.</p>\n<p>That said, what is required is an <code>IMeta</code> class that is used to interact with the interface.  At the very least, this must include a unique <code>label</code> to identify the interface.  This can also be considered the ‘handler type’. For example, the <code>ILog</code> interface has a label of <code>log</code> and any handlers registered to that interface are stored in <code>HandlerManager.__handlers__[&#39;log&#39;]</code>.</p>\n<p>Notice that we defined <code>Meta</code> and <code>my_var</code> as Interface Attributes.  This is a simple identifier that describes an attribute that an implementation is expected to provide.</p>\n<h2 id=\"Validating-Interfaces\"><a href=\"#Validating-Interfaces\" class=\"headerlink\" title=\"Validating Interfaces\"></a>Validating Interfaces</h2><p>A validator call back function can be defined in the interfaces IMeta class like this:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> interface</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_validator</span><span class=\"params\">(klass, obj)</span>:</span></div><div class=\"line\">    members = [</div><div class=\"line\">        <span class=\"string\">'_setup'</span>,</div><div class=\"line\">        <span class=\"string\">'do_something'</span>,</div><div class=\"line\">        <span class=\"string\">'my_var'</span>,</div><div class=\"line\">        ]</div><div class=\"line\">    interface.validate(MyInterface, obj, members)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInterface</span><span class=\"params\">(interface.Interface)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IMeta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myinterface'</span></div><div class=\"line\">        validator = my_validator</div></pre></td></tr></table></figure>\n<p>When <code>CementApp.handler.register()</code> is called to register a handler to an interface, the validator is called and the handler object is passed to the  validator.  In the above example, we simply define what members we want to validate for and then call <code>interface.validate()</code> which will raise <code>cement.core.exc.InterfaceError</code> if validation fails.  It is not necessary to use <code>interface.validate()</code> but it is useful and recommended. In general, the key thing to note is that a validator either raises <code>InterfaceError</code> or does nothing if validation passes.</p>\n<h2 id=\"Registering-Handlers-to-an-Interface\"><a href=\"#Registering-Handlers-to-an-Interface\" class=\"headerlink\" title=\"Registering Handlers to an Interface\"></a>Registering Handlers to an Interface</h2><p>An interface simply defines what an implementation is expected to provide, where a handler actually implements the interface.  The following example is a handler that implements the MyInterface above:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.handler <span class=\"keyword\">import</span> CementBaseHandler</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.interfaces <span class=\"keyword\">import</span> MyInterface</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span><span class=\"params\">(CementBaseHandler)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        interface = MyInterface</div><div class=\"line\">        label = <span class=\"string\">'my_handler'</span></div><div class=\"line\">        description = <span class=\"string\">'This handler implements MyInterface'</span></div><div class=\"line\">        config_defaults = dict(</div><div class=\"line\">            foo=<span class=\"string\">'bar'</span></div><div class=\"line\">            )</div><div class=\"line\"></div><div class=\"line\">    my_var = <span class=\"string\">'This is my var'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app = <span class=\"keyword\">None</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_setup</span><span class=\"params\">(self, app_obj)</span>:</span></div><div class=\"line\">        self.app = app_obj</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_something</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Doing work!\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        handlers = [MyHandler]</div></pre></td></tr></table></figure>\n<p>Alternatively, if you need more control you might use this approach:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># register handler after the app is created</span></div><div class=\"line\">    app.handler.register(MyHandler)</div><div class=\"line\"></div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>The above is a simple class that meets all the expectations of the interface. When calling <code>CementApp.handler.register()</code>, <code>MyHandler</code> is passed to the validator (if defined in the interface) and if it passes validation will be registered into <code>HandlerManager.__handlers__</code>.</p>\n<h2 id=\"Using-Handlers\"><a href=\"#Using-Handlers\" class=\"headerlink\" title=\"Using Handlers\"></a>Using Handlers</h2><p>The following are a few examples of working with handlers:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># Get a log handler called 'logging'</span></div><div class=\"line\">    lh = app.handler.get(<span class=\"string\">'log'</span>, <span class=\"string\">'logging'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Instantiate the handler class, passing any keyword arguments that </span></div><div class=\"line\">    <span class=\"comment\"># the handler supports.</span></div><div class=\"line\">    log = log_handler()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Setup the handler, passing it the app object.</span></div><div class=\"line\">    log._setup(app)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># List all handlers of type 'config'</span></div><div class=\"line\">    app.handler.list(<span class=\"string\">'config'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Check if an interface called 'output' is defined</span></div><div class=\"line\">    app.handler.defined(<span class=\"string\">'output'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Check if the handler 'argparse' is registered to the 'argument' </span></div><div class=\"line\">    <span class=\"comment\"># interface</span></div><div class=\"line\">    app.handler.registered(<span class=\"string\">'argument'</span>, <span class=\"string\">'argparse'</span>)</div></pre></td></tr></table></figure>\n<p>It is important to note that handlers are stored with the app as uninstantiated objects.  Meaning you must instantiate them after retrieval, and call <code>_setup(app)</code> when using handlers directly (as in the above example).</p>\n<h2 id=\"Overriding-Default-Handlers\"><a href=\"#Overriding-Default-Handlers\" class=\"headerlink\" title=\"Overriding Default Handlers\"></a>Overriding Default Handlers</h2><p>Cement sets up a number of default handlers for logging, config parsing, etc. These can be overridden in a number of ways.  The first way is by passing them as keyword arguments to <code>CementApp</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.log <span class=\"keyword\">import</span> MyLogHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Create the application</span></div><div class=\"line\">app = CementApp(<span class=\"string\">'myapp'</span>, log_handler=MyLogHandler)</div><div class=\"line\">app.setup()</div><div class=\"line\">app.run()</div><div class=\"line\">app.close()</div></pre></td></tr></table></figure>\n<p>The second way to override a handler is by setting it directly in the <code>CementApp</code> meta data:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.log <span class=\"keyword\">import</span> MyLogHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        log_handler = MyLogHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>There are times that you may want to pre-instantiate handlers before passing them to CementApp().  The following works just the same:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.log <span class=\"keyword\">import</span> MyLogHandler</div><div class=\"line\"></div><div class=\"line\">my_log = MyLogHandler(some_param=<span class=\"string\">'some_value'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        log_handler = my_log</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>To see what default handlers can be overridden, see the <a href=\"/2.10/api/cement.core.foundation\">cement.core.foundation</a> documentation.</p>\n<h2 id=\"Multiple-Registered-Handlers\"><a href=\"#Multiple-Registered-Handlers\" class=\"headerlink\" title=\"Multiple Registered Handlers\"></a>Multiple Registered Handlers</h2><p>All handlers and interfaces are unique.  In most cases, where the framework is concerned, only one handler is used.  For example, whatever is configured for the <code>log_handler</code> will be used and setup as <code>app.log</code>.  However, take for example an Output Handler.  You might have a default <code>output_handler</code> of <code>mustache</code>‘ (a text templating language) but may also want to override that handler with the <code>json</code> output handler when <code>-o json</code> is passed at command line.  In order to allow this functionality, both the <code>mustache</code> and <code>json</code> output handlers must be registered.</p>\n<p>Any number of handlers can be registered to an interface.  You might have a use case for an Interface/Handler that may provide different compatibility base on the operating system, or perhaps based on simply how the application is called.  A good example would be an application that automates building packages for Linux distributions.  An interface would define what a build handler needs to provide, but the build handler would be different based on the OS.  The application might have an <code>rpm</code> build handler, or a <code>dpkg</code> build handler to perform the build process differently.</p>\n<h2 id=\"Customizing-Handlers\"><a href=\"#Customizing-Handlers\" class=\"headerlink\" title=\"Customizing Handlers\"></a>Customizing Handlers</h2><p>The most common way to customize a handler is to subclass it, and then pass it to <code>CementApp</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.lib.ext_logging <span class=\"keyword\">import</span> LoggingLogHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyLogHandler</span><span class=\"params\">(LoggingLogHandler)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'mylog'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">info</span><span class=\"params\">(self, msg)</span>:</span></div><div class=\"line\">        <span class=\"comment\"># do something to customize this function, here...</span></div><div class=\"line\">        super(MyLogHandler, self).info(msg)</div><div class=\"line\"></div><div class=\"line\">app = CementApp(<span class=\"string\">'myapp'</span>, log_handler=MyLogHandler)</div></pre></td></tr></table></figure>\n<h2 id=\"Handler-Default-Configuration-Settings\"><a href=\"#Handler-Default-Configuration-Settings\" class=\"headerlink\" title=\"Handler Default Configuration Settings\"></a>Handler Default Configuration Settings</h2><p>All handlers can define default config file settings via their <code>config_defaults</code> meta option.  These will be merged into the <code>app.config</code> under the <code>[handler_interface].[handler_label]</code> section.  These settings are overridden in the following order.</p>\n<ul>\n<li>The config_defaults dictionary passed to <code>CementApp</code></li>\n<li>Via any application config files with a <code>[handler_interface].[handler_type]</code> block (i.e. <code>cache.memcached</code>)</li>\n</ul>\n<p>The following shows how to override defaults by passing them with the defaults dictionary to <code>CementApp</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myinterface.myhandler'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'myinterface.myhandler'</span>] = dict(foo=<span class=\"string\">'bar'</span>)</div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>, config_defaults=defaults)</div></pre></td></tr></table></figure>\n<p>Cement will use all defaults set via <code>MyHandler.Meta.config_defaults</code> (for this example), and then override just what is passed via <code>config_defaults[&#39;myinterface.myhandler&#39;]</code>.  You should use this approach only to modify the global defaults for your application.  The second way is to then set configuration file defaults under the <code>[myinterface.myhandler]</code> section.  For example:</p>\n<p><strong>my.config</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myinterface.myhandler]</div><div class=\"line\">foo = bar</div></pre></td></tr></table></figure>\n<p>In the real world this may look like <code>[cache.memcached]</code>, or <code>[database.mysql]</code> depending on what the interface label, and handler label’s are.  Additionally, individual handlers can override their config section by setting <code>Meta.config_section</code>.</p>\n<h2 id=\"Overriding-Handlers-Via-Command-Line\"><a href=\"#Overriding-Handlers-Via-Command-Line\" class=\"headerlink\" title=\"Overriding Handlers Via Command Line\"></a>Overriding Handlers Via Command Line</h2><p>In some use cases, you will want the end user to have access to override the default handler of a particular interface.  For example, Cement ships with multiple Output Handlers including <code>json</code>, <code>yaml</code>, and <code>mustache</code>.  A typical application might default to using <code>mustache</code> to render console output from text templates.  That said, without changing any code in the application, the end user can simply pass the <code>-o json</code> command line option and output the same data that is rendered to template, out in pure JSON.</p>\n<p>The only built-in handler override that Cement includes is for the above mentioned example, but you can add any that your application requires.</p>\n<p>The following example shows this in action… note that the following is already setup by Cement, but we’re putting it here for clarity:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># define what extensions we want to load</span></div><div class=\"line\">        extensions = [<span class=\"string\">'mustache'</span>, <span class=\"string\">'json'</span>, <span class=\"string\">'yaml'</span>]</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># define our default output handler</span></div><div class=\"line\">        output_handler = <span class=\"string\">'mustache'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># define our handler override options</span></div><div class=\"line\">        handler_override_options = dict(</div><div class=\"line\">            output = ([<span class=\"string\">'-o'</span>], dict(help=<span class=\"string\">'output format'</span>)),</div><div class=\"line\">            )</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># run the application</span></div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># define some data for the output handler</span></div><div class=\"line\">    data = dict(foo=<span class=\"string\">'bar'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># render something using out output handlers, using mustache by</span></div><div class=\"line\">    <span class=\"comment\"># default which will use the default.m templae</span></div><div class=\"line\">    app.render(data, <span class=\"string\">'default.m'</span>)</div></pre></td></tr></table></figure>\n<p>Note what we see at command line:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py [-h] [--debug] [--quiet] [-o &#123;yaml,json&#125;]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help      show this help message and exit</div><div class=\"line\">  --debug         toggle debug output</div><div class=\"line\">  --quiet         suppress all output</div><div class=\"line\">  -o &#123;yaml,json&#125;  output format</div></pre></td></tr></table></figure>\n<p>Notice the <code>-o</code> command line option, that includes the choices: <code>yaml</code> and <code>json</code>.  This feature will include all Output Handlers that have the <code>overridable</code> meta-data option set to <code>True</code>.  The MustacheOutputHandler does not set this option, therefore it does not show up as a valid choice.</p>\n<p>Now what happens when we run it?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">This text is being rendered via Mustache.</div><div class=\"line\">The value of the &apos;foo&apos; variable is =&gt; &apos;bar&apos;</div></pre></td></tr></table></figure>\n<p>The above is the default output, using <code>mustache</code> as our <code>output_handler</code>, and rendering the output text from a template called <code>default.m</code>.  We can now override the output handler using the <code>-o</code> option and modify the output format:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py -o json</div><div class=\"line\">&#123;&quot;foo&quot;: &quot;bar&quot;&#125;</div></pre></td></tr></table></figure>\n<p>Again, any handler can be overridden in this fashion.</p>\n"},{"title":"Quickstart","type":"guide","version":"2.10","order":3,"_content":"\n## Hello World\n\nThe following creates and runs a sample 'helloworld' application.\n\n**helloworld.py**\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('helloworld') as app:\n    app.run()\n    print('Hello World')\n```\n\nThe above is equivalent to (should you need more control over setup and closing an application):\n\n```python\nfrom cement.core.foundation import CementApp\n\napp = CementApp('helloworld')\napp.setup()\napp.run()\nprint('Hello World')\napp.close()\n```\n\nRunning the application looks like:\n\n```\n$ python helloworld.py\nHello World\n```\n\nOh, I can just hear you saying, \"Whoa whoa... hang on a minute.  This is a joke right, all you did was print 'Hello World' to STDOUT.  What kind of framework is this?\".  Well obviously this is just an introduction to show that the creation of an application is dead simple.  Lets take a look further:\n\n```\n$ python helloworld.py --help\nusage: helloworld.py [-h] [--debug] [--quiet]\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n```\n\nOh nice, ok... ArgParse is already setup with a few options I see.  What else?\n\n```\n$ python helloworld.py --debug\n2014-04-15 12:28:24,705 (DEBUG) cement.core.foundation : laying cement for the 'helloworld' application\n2014-04-15 12:28:24,705 (DEBUG) cement.core.hook : defining hook 'pre_setup'\n2014-04-15 12:28:24,705 (DEBUG) cement.core.hook : defining hook 'post_setup'\n2014-04-15 12:28:24,705 (DEBUG) cement.core.hook : defining hook 'pre_run'\n2014-04-15 12:28:24,705 (DEBUG) cement.core.hook : defining hook 'post_run'\n2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook 'pre_argument_parsing'\n2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook 'post_argument_parsing'\n2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook 'pre_close'\n2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook 'post_close'\n2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook 'signal'\n2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook 'pre_render'\n2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook 'post_render'\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type 'extension' (IExtension)\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type 'log' (ILog)\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type 'config' (IConfig)\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type 'plugin' (IPlugin)\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type 'output' (IOutput)\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type 'argument' (IArgument)\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type 'controller' (IController)\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type 'cache' (ICache)\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : registering handler '<class 'cement.core.extension.CementExtensionHandler'>' into handlers['extension']['cement']\n2014-04-15 12:28:24,706 (DEBUG) cement.core.foundation : now setting up the 'helloworld' application\n2014-04-15 12:28:24,706 (DEBUG) cement.core.foundation : adding signal handler for signal 15\n2014-04-15 12:28:24,712 (DEBUG) cement.core.foundation : adding signal handler for signal 2\n2014-04-15 12:28:24,712 (DEBUG) cement.core.foundation : setting up helloworld.extension handler\n2014-04-15 12:28:24,712 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_dummy' framework extension\n2014-04-15 12:28:24,712 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_dummy.DummyOutputHandler'>' into handlers['output']['null']\n2014-04-15 12:28:24,712 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_plugin' framework extension\n2014-04-15 12:28:24,713 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_plugin.CementPluginHandler'>' into handlers['plugin']['cement']\n2014-04-15 12:28:24,713 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_configparser' framework extension\n2014-04-15 12:28:24,713 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_configparser.ConfigParserConfigHandler'>' into handlers['config']['configparser']\n2014-04-15 12:28:24,713 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_logging' framework extension\n2014-04-15 12:28:24,713 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_logging.LoggingLogHandler'>' into handlers['log']['logging']\n2014-04-15 12:28:24,713 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_argparse' framework extension\n2014-04-15 12:28:24,714 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_argparse.ArgParseArgumentHandler'>' into handlers['argument']['argparse']\n2014-04-15 12:28:24,714 (DEBUG) cement.core.foundation : setting up helloworld.config handler\n2014-04-15 12:28:24,714 (DEBUG) cement.ext.ext_configparser : config file '/etc/helloworld/helloworld.conf' does not exist, skipping...\n2014-04-15 12:28:24,714 (DEBUG) cement.ext.ext_configparser : config file '/Users/derks/.helloworld/config' does not exist, skipping...\n2014-04-15 12:28:24,715 (DEBUG) cement.core.foundation : no cache handler defined, skipping.\n2014-04-15 12:28:24,715 (DEBUG) cement.core.foundation : setting up helloworld.log handler\n2014-04-15 12:28:24,715 (DEBUG) cement.core.handler : merging config defaults from '<cement.ext.ext_logging.LoggingLogHandler object at 0x1015c4ed0>' into section 'log.logging'\n2014-04-15 12:28:24,715 (DEBUG) helloworld:None : logging initialized for 'helloworld:None' using LoggingLogHandler\n2014-04-15 12:28:24,715 (DEBUG) cement.core.foundation : setting up helloworld.plugin handler\n2014-04-15 12:28:24,715 (DEBUG) cement.ext.ext_plugin : plugin config dir /Users/derks/Development/boss/tmp/helloworld/config/plugins.d does not exist.\n2014-04-15 12:28:24,716 (DEBUG) cement.core.foundation : setting up helloworld.arg handler\n2014-04-15 12:28:24,716 (DEBUG) cement.core.foundation : setting up helloworld.output handler\n2014-04-15 12:28:24,716 (DEBUG) cement.core.foundation : setting up application controllers\nHello World\n2014-04-15 12:28:24,716 (DEBUG) cement.core.foundation : closing the application\n```\n\nDamn son, WTF?  Don't worry, we'll explain everything in the rest of the doc.\n\n\n## Getting Warmer\n\n\nThe following is a more advanced example that showcases some of the default application features.  Notice the creation of command line arguments, default config creation, and logging.\n\n**myapp.py**\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core import hook\nfrom cement.utils.misc import init_defaults\n\n# define our default configuration options\ndefaults = init_defaults('myapp')\ndefaults['myapp']['debug'] = False\ndefaults['myapp']['some_param'] = 'some value'\n\n# define any hook functions here\ndef my_cleanup_hook(app):\n    pass\n\n# define the application class\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        config_defaults = defaults\n        extensions = ['memcached', 'json', 'yaml']\n        hooks = [\n            ('pre_close', my_cleanup_hook),\n        ]\n\nwith MyApp() as app:\n    # add arguments to the parser\n    app.args.add_argument('-f', '--foo', action='store', metavar='STR',\n                          help='the notorious foo option')\n\n    # log stuff\n    app.log.debug(\"About to run my myapp application!\")\n\n    # run the application\n    app.run()\n\n    # continue with additional application logic\n    if app.pargs.foo:\n        app.log.info(\"Received option: foo => %s\" % app.pargs.foo)\n```\n\nAnd execution:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\noptional arguments:\n  -h, --help         show this help message and exit\n  --debug            toggle debug output\n  --quiet            suppress all output\n  -f STR, --foo STR  the notorious foo option\n\n$ python myapp.py --foo=bar\nINFO: Received option: foo => bar\n```\n\n## Diving Right In\n\nThis final example demonstrates the use of application controllers that handle command dispatch and rapid development.\n\n**myapp.py**\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\nclass MyBaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n        description = \"My Application does amazing things!\"\n        arguments = [\n            ( ['-f', '--foo'],\n              dict(action='store', help='the notorious foo option') ),\n            ( ['-C'],\n              dict(action='store_true', help='the big C option') ),\n            ]\n\n    @expose(hide=True)\n    def default(self):\n        self.app.log.info('Inside MyBaseController.default()')\n        if self.app.pargs.foo:\n            print(\"Recieved option: foo => %s\" % self.app.pargs.foo)\n\n    @expose(help=\"this command does relatively nothing useful\")\n    def command1(self):\n        self.app.log.info(\"Inside MyBaseController.command1()\")\n\n    @expose(aliases=['cmd2'], help=\"more of nothing\")\n    def command2(self):\n        self.app.log.info(\"Inside MyBaseController.command2()\")\n\n\nclass MySecondController(CementBaseController):\n    class Meta:\n        label = 'second'\n        stacked_on = 'base'\n\n    @expose(help='this is some command', aliases=['some-cmd'])\n    def second_cmd1(self):\n        self.app.log.info(\"Inside MySecondController.second_cmd1\")\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        base_controller = 'base'\n        handlers = [MyBaseController, MySecondController]\n\n\n\nwith MyApp() as app:\n    app.run()\n```\n\nAs you can see, we're able to build out the core functionality of our app such as arguments and sub-commands via controller classes.\n\nLets see what this looks like:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nMy Application does amazing things!\n\ncommands:\n\n  command1\n    this command does relatively nothing useful\n\n  command2 (aliases: cmd2)\n    more of nothing\n\n  second-cmd1 (aliases: some-cmd)\n    this is some command\n\noptional arguments:\n  -h, --help         show this help message and exit\n  --debug            toggle debug output\n  --quiet            suppress all output\n  -f FOO, --foo FOO  the notorious foo option\n  -C                 the big C option\n\n$ python myapp.py\nINFO: Inside MyBaseController.default()\n\n$ python myapp.py command1\nINFO: Inside MyBaseController.command1()\n\n$ python myapp.py command2\nINFO: Inside MyBaseController.command2()\n\n$ python myapp.py second-cmd1\nINFO: Inside MySecondController.second_cmd1()\n```\n","source":"2.10/dev/quickstart.md","raw":"---\ntitle: Quickstart\ntype: guide\nversion: \"2.10\"\norder: 3\n---\n\n## Hello World\n\nThe following creates and runs a sample 'helloworld' application.\n\n**helloworld.py**\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('helloworld') as app:\n    app.run()\n    print('Hello World')\n```\n\nThe above is equivalent to (should you need more control over setup and closing an application):\n\n```python\nfrom cement.core.foundation import CementApp\n\napp = CementApp('helloworld')\napp.setup()\napp.run()\nprint('Hello World')\napp.close()\n```\n\nRunning the application looks like:\n\n```\n$ python helloworld.py\nHello World\n```\n\nOh, I can just hear you saying, \"Whoa whoa... hang on a minute.  This is a joke right, all you did was print 'Hello World' to STDOUT.  What kind of framework is this?\".  Well obviously this is just an introduction to show that the creation of an application is dead simple.  Lets take a look further:\n\n```\n$ python helloworld.py --help\nusage: helloworld.py [-h] [--debug] [--quiet]\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n```\n\nOh nice, ok... ArgParse is already setup with a few options I see.  What else?\n\n```\n$ python helloworld.py --debug\n2014-04-15 12:28:24,705 (DEBUG) cement.core.foundation : laying cement for the 'helloworld' application\n2014-04-15 12:28:24,705 (DEBUG) cement.core.hook : defining hook 'pre_setup'\n2014-04-15 12:28:24,705 (DEBUG) cement.core.hook : defining hook 'post_setup'\n2014-04-15 12:28:24,705 (DEBUG) cement.core.hook : defining hook 'pre_run'\n2014-04-15 12:28:24,705 (DEBUG) cement.core.hook : defining hook 'post_run'\n2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook 'pre_argument_parsing'\n2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook 'post_argument_parsing'\n2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook 'pre_close'\n2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook 'post_close'\n2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook 'signal'\n2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook 'pre_render'\n2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook 'post_render'\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type 'extension' (IExtension)\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type 'log' (ILog)\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type 'config' (IConfig)\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type 'plugin' (IPlugin)\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type 'output' (IOutput)\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type 'argument' (IArgument)\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type 'controller' (IController)\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type 'cache' (ICache)\n2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : registering handler '<class 'cement.core.extension.CementExtensionHandler'>' into handlers['extension']['cement']\n2014-04-15 12:28:24,706 (DEBUG) cement.core.foundation : now setting up the 'helloworld' application\n2014-04-15 12:28:24,706 (DEBUG) cement.core.foundation : adding signal handler for signal 15\n2014-04-15 12:28:24,712 (DEBUG) cement.core.foundation : adding signal handler for signal 2\n2014-04-15 12:28:24,712 (DEBUG) cement.core.foundation : setting up helloworld.extension handler\n2014-04-15 12:28:24,712 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_dummy' framework extension\n2014-04-15 12:28:24,712 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_dummy.DummyOutputHandler'>' into handlers['output']['null']\n2014-04-15 12:28:24,712 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_plugin' framework extension\n2014-04-15 12:28:24,713 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_plugin.CementPluginHandler'>' into handlers['plugin']['cement']\n2014-04-15 12:28:24,713 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_configparser' framework extension\n2014-04-15 12:28:24,713 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_configparser.ConfigParserConfigHandler'>' into handlers['config']['configparser']\n2014-04-15 12:28:24,713 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_logging' framework extension\n2014-04-15 12:28:24,713 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_logging.LoggingLogHandler'>' into handlers['log']['logging']\n2014-04-15 12:28:24,713 (DEBUG) cement.core.extension : loading the 'cement.ext.ext_argparse' framework extension\n2014-04-15 12:28:24,714 (DEBUG) cement.core.handler : registering handler '<class 'cement.ext.ext_argparse.ArgParseArgumentHandler'>' into handlers['argument']['argparse']\n2014-04-15 12:28:24,714 (DEBUG) cement.core.foundation : setting up helloworld.config handler\n2014-04-15 12:28:24,714 (DEBUG) cement.ext.ext_configparser : config file '/etc/helloworld/helloworld.conf' does not exist, skipping...\n2014-04-15 12:28:24,714 (DEBUG) cement.ext.ext_configparser : config file '/Users/derks/.helloworld/config' does not exist, skipping...\n2014-04-15 12:28:24,715 (DEBUG) cement.core.foundation : no cache handler defined, skipping.\n2014-04-15 12:28:24,715 (DEBUG) cement.core.foundation : setting up helloworld.log handler\n2014-04-15 12:28:24,715 (DEBUG) cement.core.handler : merging config defaults from '<cement.ext.ext_logging.LoggingLogHandler object at 0x1015c4ed0>' into section 'log.logging'\n2014-04-15 12:28:24,715 (DEBUG) helloworld:None : logging initialized for 'helloworld:None' using LoggingLogHandler\n2014-04-15 12:28:24,715 (DEBUG) cement.core.foundation : setting up helloworld.plugin handler\n2014-04-15 12:28:24,715 (DEBUG) cement.ext.ext_plugin : plugin config dir /Users/derks/Development/boss/tmp/helloworld/config/plugins.d does not exist.\n2014-04-15 12:28:24,716 (DEBUG) cement.core.foundation : setting up helloworld.arg handler\n2014-04-15 12:28:24,716 (DEBUG) cement.core.foundation : setting up helloworld.output handler\n2014-04-15 12:28:24,716 (DEBUG) cement.core.foundation : setting up application controllers\nHello World\n2014-04-15 12:28:24,716 (DEBUG) cement.core.foundation : closing the application\n```\n\nDamn son, WTF?  Don't worry, we'll explain everything in the rest of the doc.\n\n\n## Getting Warmer\n\n\nThe following is a more advanced example that showcases some of the default application features.  Notice the creation of command line arguments, default config creation, and logging.\n\n**myapp.py**\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core import hook\nfrom cement.utils.misc import init_defaults\n\n# define our default configuration options\ndefaults = init_defaults('myapp')\ndefaults['myapp']['debug'] = False\ndefaults['myapp']['some_param'] = 'some value'\n\n# define any hook functions here\ndef my_cleanup_hook(app):\n    pass\n\n# define the application class\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        config_defaults = defaults\n        extensions = ['memcached', 'json', 'yaml']\n        hooks = [\n            ('pre_close', my_cleanup_hook),\n        ]\n\nwith MyApp() as app:\n    # add arguments to the parser\n    app.args.add_argument('-f', '--foo', action='store', metavar='STR',\n                          help='the notorious foo option')\n\n    # log stuff\n    app.log.debug(\"About to run my myapp application!\")\n\n    # run the application\n    app.run()\n\n    # continue with additional application logic\n    if app.pargs.foo:\n        app.log.info(\"Received option: foo => %s\" % app.pargs.foo)\n```\n\nAnd execution:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\noptional arguments:\n  -h, --help         show this help message and exit\n  --debug            toggle debug output\n  --quiet            suppress all output\n  -f STR, --foo STR  the notorious foo option\n\n$ python myapp.py --foo=bar\nINFO: Received option: foo => bar\n```\n\n## Diving Right In\n\nThis final example demonstrates the use of application controllers that handle command dispatch and rapid development.\n\n**myapp.py**\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\nclass MyBaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n        description = \"My Application does amazing things!\"\n        arguments = [\n            ( ['-f', '--foo'],\n              dict(action='store', help='the notorious foo option') ),\n            ( ['-C'],\n              dict(action='store_true', help='the big C option') ),\n            ]\n\n    @expose(hide=True)\n    def default(self):\n        self.app.log.info('Inside MyBaseController.default()')\n        if self.app.pargs.foo:\n            print(\"Recieved option: foo => %s\" % self.app.pargs.foo)\n\n    @expose(help=\"this command does relatively nothing useful\")\n    def command1(self):\n        self.app.log.info(\"Inside MyBaseController.command1()\")\n\n    @expose(aliases=['cmd2'], help=\"more of nothing\")\n    def command2(self):\n        self.app.log.info(\"Inside MyBaseController.command2()\")\n\n\nclass MySecondController(CementBaseController):\n    class Meta:\n        label = 'second'\n        stacked_on = 'base'\n\n    @expose(help='this is some command', aliases=['some-cmd'])\n    def second_cmd1(self):\n        self.app.log.info(\"Inside MySecondController.second_cmd1\")\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        base_controller = 'base'\n        handlers = [MyBaseController, MySecondController]\n\n\n\nwith MyApp() as app:\n    app.run()\n```\n\nAs you can see, we're able to build out the core functionality of our app such as arguments and sub-commands via controller classes.\n\nLets see what this looks like:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nMy Application does amazing things!\n\ncommands:\n\n  command1\n    this command does relatively nothing useful\n\n  command2 (aliases: cmd2)\n    more of nothing\n\n  second-cmd1 (aliases: some-cmd)\n    this is some command\n\noptional arguments:\n  -h, --help         show this help message and exit\n  --debug            toggle debug output\n  --quiet            suppress all output\n  -f FOO, --foo FOO  the notorious foo option\n  -C                 the big C option\n\n$ python myapp.py\nINFO: Inside MyBaseController.default()\n\n$ python myapp.py command1\nINFO: Inside MyBaseController.command1()\n\n$ python myapp.py command2\nINFO: Inside MyBaseController.command2()\n\n$ python myapp.py second-cmd1\nINFO: Inside MySecondController.second_cmd1()\n```\n","date":"2018-01-17T03:39:13.626Z","updated":"2018-01-17T03:39:13.626Z","path":"2.10/dev/quickstart.html","_id":"cj5dg8qrx000ch6pw0acsfx20","comments":1,"layout":"page","content":"<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h2><p>The following creates and runs a sample ‘helloworld’ application.</p>\n<p><strong>helloworld.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'helloworld'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\">    print(<span class=\"string\">'Hello World'</span>)</div></pre></td></tr></table></figure>\n<p>The above is equivalent to (should you need more control over setup and closing an application):</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\">app = CementApp(<span class=\"string\">'helloworld'</span>)</div><div class=\"line\">app.setup()</div><div class=\"line\">app.run()</div><div class=\"line\">print(<span class=\"string\">'Hello World'</span>)</div><div class=\"line\">app.close()</div></pre></td></tr></table></figure>\n<p>Running the application looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python helloworld.py</div><div class=\"line\">Hello World</div></pre></td></tr></table></figure>\n<p>Oh, I can just hear you saying, “Whoa whoa… hang on a minute.  This is a joke right, all you did was print ‘Hello World’ to STDOUT.  What kind of framework is this?”.  Well obviously this is just an introduction to show that the creation of an application is dead simple.  Lets take a look further:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python helloworld.py --help</div><div class=\"line\">usage: helloworld.py [-h] [--debug] [--quiet]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div></pre></td></tr></table></figure>\n<p>Oh nice, ok… ArgParse is already setup with a few options I see.  What else?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python helloworld.py --debug</div><div class=\"line\">2014-04-15 12:28:24,705 (DEBUG) cement.core.foundation : laying cement for the &apos;helloworld&apos; application</div><div class=\"line\">2014-04-15 12:28:24,705 (DEBUG) cement.core.hook : defining hook &apos;pre_setup&apos;</div><div class=\"line\">2014-04-15 12:28:24,705 (DEBUG) cement.core.hook : defining hook &apos;post_setup&apos;</div><div class=\"line\">2014-04-15 12:28:24,705 (DEBUG) cement.core.hook : defining hook &apos;pre_run&apos;</div><div class=\"line\">2014-04-15 12:28:24,705 (DEBUG) cement.core.hook : defining hook &apos;post_run&apos;</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook &apos;pre_argument_parsing&apos;</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook &apos;post_argument_parsing&apos;</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook &apos;pre_close&apos;</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook &apos;post_close&apos;</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook &apos;signal&apos;</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook &apos;pre_render&apos;</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook &apos;post_render&apos;</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type &apos;extension&apos; (IExtension)</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type &apos;log&apos; (ILog)</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type &apos;config&apos; (IConfig)</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type &apos;plugin&apos; (IPlugin)</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type &apos;output&apos; (IOutput)</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type &apos;argument&apos; (IArgument)</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type &apos;controller&apos; (IController)</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type &apos;cache&apos; (ICache)</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.core.extension.CementExtensionHandler&apos;&gt;&apos; into handlers[&apos;extension&apos;][&apos;cement&apos;]</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.foundation : now setting up the &apos;helloworld&apos; application</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.foundation : adding signal handler for signal 15</div><div class=\"line\">2014-04-15 12:28:24,712 (DEBUG) cement.core.foundation : adding signal handler for signal 2</div><div class=\"line\">2014-04-15 12:28:24,712 (DEBUG) cement.core.foundation : setting up helloworld.extension handler</div><div class=\"line\">2014-04-15 12:28:24,712 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_dummy&apos; framework extension</div><div class=\"line\">2014-04-15 12:28:24,712 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_dummy.DummyOutputHandler&apos;&gt;&apos; into handlers[&apos;output&apos;][&apos;null&apos;]</div><div class=\"line\">2014-04-15 12:28:24,712 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_plugin&apos; framework extension</div><div class=\"line\">2014-04-15 12:28:24,713 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_plugin.CementPluginHandler&apos;&gt;&apos; into handlers[&apos;plugin&apos;][&apos;cement&apos;]</div><div class=\"line\">2014-04-15 12:28:24,713 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_configparser&apos; framework extension</div><div class=\"line\">2014-04-15 12:28:24,713 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_configparser.ConfigParserConfigHandler&apos;&gt;&apos; into handlers[&apos;config&apos;][&apos;configparser&apos;]</div><div class=\"line\">2014-04-15 12:28:24,713 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_logging&apos; framework extension</div><div class=\"line\">2014-04-15 12:28:24,713 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_logging.LoggingLogHandler&apos;&gt;&apos; into handlers[&apos;log&apos;][&apos;logging&apos;]</div><div class=\"line\">2014-04-15 12:28:24,713 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_argparse&apos; framework extension</div><div class=\"line\">2014-04-15 12:28:24,714 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_argparse.ArgParseArgumentHandler&apos;&gt;&apos; into handlers[&apos;argument&apos;][&apos;argparse&apos;]</div><div class=\"line\">2014-04-15 12:28:24,714 (DEBUG) cement.core.foundation : setting up helloworld.config handler</div><div class=\"line\">2014-04-15 12:28:24,714 (DEBUG) cement.ext.ext_configparser : config file &apos;/etc/helloworld/helloworld.conf&apos; does not exist, skipping...</div><div class=\"line\">2014-04-15 12:28:24,714 (DEBUG) cement.ext.ext_configparser : config file &apos;/Users/derks/.helloworld/config&apos; does not exist, skipping...</div><div class=\"line\">2014-04-15 12:28:24,715 (DEBUG) cement.core.foundation : no cache handler defined, skipping.</div><div class=\"line\">2014-04-15 12:28:24,715 (DEBUG) cement.core.foundation : setting up helloworld.log handler</div><div class=\"line\">2014-04-15 12:28:24,715 (DEBUG) cement.core.handler : merging config defaults from &apos;&lt;cement.ext.ext_logging.LoggingLogHandler object at 0x1015c4ed0&gt;&apos; into section &apos;log.logging&apos;</div><div class=\"line\">2014-04-15 12:28:24,715 (DEBUG) helloworld:None : logging initialized for &apos;helloworld:None&apos; using LoggingLogHandler</div><div class=\"line\">2014-04-15 12:28:24,715 (DEBUG) cement.core.foundation : setting up helloworld.plugin handler</div><div class=\"line\">2014-04-15 12:28:24,715 (DEBUG) cement.ext.ext_plugin : plugin config dir /Users/derks/Development/boss/tmp/helloworld/config/plugins.d does not exist.</div><div class=\"line\">2014-04-15 12:28:24,716 (DEBUG) cement.core.foundation : setting up helloworld.arg handler</div><div class=\"line\">2014-04-15 12:28:24,716 (DEBUG) cement.core.foundation : setting up helloworld.output handler</div><div class=\"line\">2014-04-15 12:28:24,716 (DEBUG) cement.core.foundation : setting up application controllers</div><div class=\"line\">Hello World</div><div class=\"line\">2014-04-15 12:28:24,716 (DEBUG) cement.core.foundation : closing the application</div></pre></td></tr></table></figure>\n<p>Damn son, WTF?  Don’t worry, we’ll explain everything in the rest of the doc.</p>\n<h2 id=\"Getting-Warmer\"><a href=\"#Getting-Warmer\" class=\"headerlink\" title=\"Getting Warmer\"></a>Getting Warmer</h2><p>The following is a more advanced example that showcases some of the default application features.  Notice the creation of command line arguments, default config creation, and logging.</p>\n<p><strong>myapp.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> hook</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># define our default configuration options</span></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'myapp'</span>][<span class=\"string\">'debug'</span>] = <span class=\"keyword\">False</span></div><div class=\"line\">defaults[<span class=\"string\">'myapp'</span>][<span class=\"string\">'some_param'</span>] = <span class=\"string\">'some value'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># define any hook functions here</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_cleanup_hook</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># define the application class</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        config_defaults = defaults</div><div class=\"line\">        extensions = [<span class=\"string\">'memcached'</span>, <span class=\"string\">'json'</span>, <span class=\"string\">'yaml'</span>]</div><div class=\"line\">        hooks = [</div><div class=\"line\">            (<span class=\"string\">'pre_close'</span>, my_cleanup_hook),</div><div class=\"line\">        ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># add arguments to the parser</span></div><div class=\"line\">    app.args.add_argument(<span class=\"string\">'-f'</span>, <span class=\"string\">'--foo'</span>, action=<span class=\"string\">'store'</span>, metavar=<span class=\"string\">'STR'</span>,</div><div class=\"line\">                          help=<span class=\"string\">'the notorious foo option'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># log stuff</span></div><div class=\"line\">    app.log.debug(<span class=\"string\">\"About to run my myapp application!\"</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># run the application</span></div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># continue with additional application logic</span></div><div class=\"line\">    <span class=\"keyword\">if</span> app.pargs.foo:</div><div class=\"line\">        app.log.info(<span class=\"string\">\"Received option: foo =&gt; %s\"</span> % app.pargs.foo)</div></pre></td></tr></table></figure>\n<p>And execution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help         show this help message and exit</div><div class=\"line\">  --debug            toggle debug output</div><div class=\"line\">  --quiet            suppress all output</div><div class=\"line\">  -f STR, --foo STR  the notorious foo option</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py --foo=bar</div><div class=\"line\">INFO: Received option: foo =&gt; bar</div></pre></td></tr></table></figure>\n<h2 id=\"Diving-Right-In\"><a href=\"#Diving-Right-In\" class=\"headerlink\" title=\"Diving Right In\"></a>Diving Right In</h2><p>This final example demonstrates the use of application controllers that handle command dispatch and rapid development.</p>\n<p><strong>myapp.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\">        description = <span class=\"string\">\"My Application does amazing things!\"</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ( [<span class=\"string\">'-f'</span>, <span class=\"string\">'--foo'</span>],</div><div class=\"line\">              dict(action=<span class=\"string\">'store'</span>, help=<span class=\"string\">'the notorious foo option'</span>) ),</div><div class=\"line\">            ( [<span class=\"string\">'-C'</span>],</div><div class=\"line\">              dict(action=<span class=\"string\">'store_true'</span>, help=<span class=\"string\">'the big C option'</span>) ),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app.log.info(<span class=\"string\">'Inside MyBaseController.default()'</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> self.app.pargs.foo:</div><div class=\"line\">            print(<span class=\"string\">\"Recieved option: foo =&gt; %s\"</span> % self.app.pargs.foo)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"this command does relatively nothing useful\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app.log.info(<span class=\"string\">\"Inside MyBaseController.command1()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(aliases=['cmd2'], help=\"more of nothing\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command2</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app.log.info(<span class=\"string\">\"Inside MyBaseController.command2()\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MySecondController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'second'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help='this is some command', aliases=['some-cmd'])</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">second_cmd1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app.log.info(<span class=\"string\">\"Inside MySecondController.second_cmd1\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        base_controller = <span class=\"string\">'base'</span></div><div class=\"line\">        handlers = [MyBaseController, MySecondController]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>As you can see, we’re able to build out the core functionality of our app such as arguments and sub-commands via controller classes.</p>\n<p>Lets see what this looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">My Application does amazing things!</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  command1</div><div class=\"line\">    this command does relatively nothing useful</div><div class=\"line\"></div><div class=\"line\">  command2 (aliases: cmd2)</div><div class=\"line\">    more of nothing</div><div class=\"line\"></div><div class=\"line\">  second-cmd1 (aliases: some-cmd)</div><div class=\"line\">    this is some command</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help         show this help message and exit</div><div class=\"line\">  --debug            toggle debug output</div><div class=\"line\">  --quiet            suppress all output</div><div class=\"line\">  -f FOO, --foo FOO  the notorious foo option</div><div class=\"line\">  -C                 the big C option</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py</div><div class=\"line\">INFO: Inside MyBaseController.default()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py command1</div><div class=\"line\">INFO: Inside MyBaseController.command1()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py command2</div><div class=\"line\">INFO: Inside MyBaseController.command2()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py second-cmd1</div><div class=\"line\">INFO: Inside MySecondController.second_cmd1()</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<h2 id=\"Hello-World\"><a href=\"#Hello-World\" class=\"headerlink\" title=\"Hello World\"></a>Hello World</h2><p>The following creates and runs a sample ‘helloworld’ application.</p>\n<p><strong>helloworld.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'helloworld'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\">    print(<span class=\"string\">'Hello World'</span>)</div></pre></td></tr></table></figure>\n<p>The above is equivalent to (should you need more control over setup and closing an application):</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\">app = CementApp(<span class=\"string\">'helloworld'</span>)</div><div class=\"line\">app.setup()</div><div class=\"line\">app.run()</div><div class=\"line\">print(<span class=\"string\">'Hello World'</span>)</div><div class=\"line\">app.close()</div></pre></td></tr></table></figure>\n<p>Running the application looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python helloworld.py</div><div class=\"line\">Hello World</div></pre></td></tr></table></figure>\n<p>Oh, I can just hear you saying, “Whoa whoa… hang on a minute.  This is a joke right, all you did was print ‘Hello World’ to STDOUT.  What kind of framework is this?”.  Well obviously this is just an introduction to show that the creation of an application is dead simple.  Lets take a look further:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python helloworld.py --help</div><div class=\"line\">usage: helloworld.py [-h] [--debug] [--quiet]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div></pre></td></tr></table></figure>\n<p>Oh nice, ok… ArgParse is already setup with a few options I see.  What else?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python helloworld.py --debug</div><div class=\"line\">2014-04-15 12:28:24,705 (DEBUG) cement.core.foundation : laying cement for the &apos;helloworld&apos; application</div><div class=\"line\">2014-04-15 12:28:24,705 (DEBUG) cement.core.hook : defining hook &apos;pre_setup&apos;</div><div class=\"line\">2014-04-15 12:28:24,705 (DEBUG) cement.core.hook : defining hook &apos;post_setup&apos;</div><div class=\"line\">2014-04-15 12:28:24,705 (DEBUG) cement.core.hook : defining hook &apos;pre_run&apos;</div><div class=\"line\">2014-04-15 12:28:24,705 (DEBUG) cement.core.hook : defining hook &apos;post_run&apos;</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook &apos;pre_argument_parsing&apos;</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook &apos;post_argument_parsing&apos;</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook &apos;pre_close&apos;</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook &apos;post_close&apos;</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook &apos;signal&apos;</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook &apos;pre_render&apos;</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.hook : defining hook &apos;post_render&apos;</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type &apos;extension&apos; (IExtension)</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type &apos;log&apos; (ILog)</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type &apos;config&apos; (IConfig)</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type &apos;plugin&apos; (IPlugin)</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type &apos;output&apos; (IOutput)</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type &apos;argument&apos; (IArgument)</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type &apos;controller&apos; (IController)</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : defining handler type &apos;cache&apos; (ICache)</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.core.extension.CementExtensionHandler&apos;&gt;&apos; into handlers[&apos;extension&apos;][&apos;cement&apos;]</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.foundation : now setting up the &apos;helloworld&apos; application</div><div class=\"line\">2014-04-15 12:28:24,706 (DEBUG) cement.core.foundation : adding signal handler for signal 15</div><div class=\"line\">2014-04-15 12:28:24,712 (DEBUG) cement.core.foundation : adding signal handler for signal 2</div><div class=\"line\">2014-04-15 12:28:24,712 (DEBUG) cement.core.foundation : setting up helloworld.extension handler</div><div class=\"line\">2014-04-15 12:28:24,712 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_dummy&apos; framework extension</div><div class=\"line\">2014-04-15 12:28:24,712 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_dummy.DummyOutputHandler&apos;&gt;&apos; into handlers[&apos;output&apos;][&apos;null&apos;]</div><div class=\"line\">2014-04-15 12:28:24,712 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_plugin&apos; framework extension</div><div class=\"line\">2014-04-15 12:28:24,713 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_plugin.CementPluginHandler&apos;&gt;&apos; into handlers[&apos;plugin&apos;][&apos;cement&apos;]</div><div class=\"line\">2014-04-15 12:28:24,713 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_configparser&apos; framework extension</div><div class=\"line\">2014-04-15 12:28:24,713 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_configparser.ConfigParserConfigHandler&apos;&gt;&apos; into handlers[&apos;config&apos;][&apos;configparser&apos;]</div><div class=\"line\">2014-04-15 12:28:24,713 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_logging&apos; framework extension</div><div class=\"line\">2014-04-15 12:28:24,713 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_logging.LoggingLogHandler&apos;&gt;&apos; into handlers[&apos;log&apos;][&apos;logging&apos;]</div><div class=\"line\">2014-04-15 12:28:24,713 (DEBUG) cement.core.extension : loading the &apos;cement.ext.ext_argparse&apos; framework extension</div><div class=\"line\">2014-04-15 12:28:24,714 (DEBUG) cement.core.handler : registering handler &apos;&lt;class &apos;cement.ext.ext_argparse.ArgParseArgumentHandler&apos;&gt;&apos; into handlers[&apos;argument&apos;][&apos;argparse&apos;]</div><div class=\"line\">2014-04-15 12:28:24,714 (DEBUG) cement.core.foundation : setting up helloworld.config handler</div><div class=\"line\">2014-04-15 12:28:24,714 (DEBUG) cement.ext.ext_configparser : config file &apos;/etc/helloworld/helloworld.conf&apos; does not exist, skipping...</div><div class=\"line\">2014-04-15 12:28:24,714 (DEBUG) cement.ext.ext_configparser : config file &apos;/Users/derks/.helloworld/config&apos; does not exist, skipping...</div><div class=\"line\">2014-04-15 12:28:24,715 (DEBUG) cement.core.foundation : no cache handler defined, skipping.</div><div class=\"line\">2014-04-15 12:28:24,715 (DEBUG) cement.core.foundation : setting up helloworld.log handler</div><div class=\"line\">2014-04-15 12:28:24,715 (DEBUG) cement.core.handler : merging config defaults from &apos;&lt;cement.ext.ext_logging.LoggingLogHandler object at 0x1015c4ed0&gt;&apos; into section &apos;log.logging&apos;</div><div class=\"line\">2014-04-15 12:28:24,715 (DEBUG) helloworld:None : logging initialized for &apos;helloworld:None&apos; using LoggingLogHandler</div><div class=\"line\">2014-04-15 12:28:24,715 (DEBUG) cement.core.foundation : setting up helloworld.plugin handler</div><div class=\"line\">2014-04-15 12:28:24,715 (DEBUG) cement.ext.ext_plugin : plugin config dir /Users/derks/Development/boss/tmp/helloworld/config/plugins.d does not exist.</div><div class=\"line\">2014-04-15 12:28:24,716 (DEBUG) cement.core.foundation : setting up helloworld.arg handler</div><div class=\"line\">2014-04-15 12:28:24,716 (DEBUG) cement.core.foundation : setting up helloworld.output handler</div><div class=\"line\">2014-04-15 12:28:24,716 (DEBUG) cement.core.foundation : setting up application controllers</div><div class=\"line\">Hello World</div><div class=\"line\">2014-04-15 12:28:24,716 (DEBUG) cement.core.foundation : closing the application</div></pre></td></tr></table></figure>\n<p>Damn son, WTF?  Don’t worry, we’ll explain everything in the rest of the doc.</p>\n<h2 id=\"Getting-Warmer\"><a href=\"#Getting-Warmer\" class=\"headerlink\" title=\"Getting Warmer\"></a>Getting Warmer</h2><p>The following is a more advanced example that showcases some of the default application features.  Notice the creation of command line arguments, default config creation, and logging.</p>\n<p><strong>myapp.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> hook</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># define our default configuration options</span></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'myapp'</span>][<span class=\"string\">'debug'</span>] = <span class=\"keyword\">False</span></div><div class=\"line\">defaults[<span class=\"string\">'myapp'</span>][<span class=\"string\">'some_param'</span>] = <span class=\"string\">'some value'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># define any hook functions here</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_cleanup_hook</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># define the application class</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        config_defaults = defaults</div><div class=\"line\">        extensions = [<span class=\"string\">'memcached'</span>, <span class=\"string\">'json'</span>, <span class=\"string\">'yaml'</span>]</div><div class=\"line\">        hooks = [</div><div class=\"line\">            (<span class=\"string\">'pre_close'</span>, my_cleanup_hook),</div><div class=\"line\">        ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># add arguments to the parser</span></div><div class=\"line\">    app.args.add_argument(<span class=\"string\">'-f'</span>, <span class=\"string\">'--foo'</span>, action=<span class=\"string\">'store'</span>, metavar=<span class=\"string\">'STR'</span>,</div><div class=\"line\">                          help=<span class=\"string\">'the notorious foo option'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># log stuff</span></div><div class=\"line\">    app.log.debug(<span class=\"string\">\"About to run my myapp application!\"</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># run the application</span></div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># continue with additional application logic</span></div><div class=\"line\">    <span class=\"keyword\">if</span> app.pargs.foo:</div><div class=\"line\">        app.log.info(<span class=\"string\">\"Received option: foo =&gt; %s\"</span> % app.pargs.foo)</div></pre></td></tr></table></figure>\n<p>And execution:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help         show this help message and exit</div><div class=\"line\">  --debug            toggle debug output</div><div class=\"line\">  --quiet            suppress all output</div><div class=\"line\">  -f STR, --foo STR  the notorious foo option</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py --foo=bar</div><div class=\"line\">INFO: Received option: foo =&gt; bar</div></pre></td></tr></table></figure>\n<h2 id=\"Diving-Right-In\"><a href=\"#Diving-Right-In\" class=\"headerlink\" title=\"Diving Right In\"></a>Diving Right In</h2><p>This final example demonstrates the use of application controllers that handle command dispatch and rapid development.</p>\n<p><strong>myapp.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\">        description = <span class=\"string\">\"My Application does amazing things!\"</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ( [<span class=\"string\">'-f'</span>, <span class=\"string\">'--foo'</span>],</div><div class=\"line\">              dict(action=<span class=\"string\">'store'</span>, help=<span class=\"string\">'the notorious foo option'</span>) ),</div><div class=\"line\">            ( [<span class=\"string\">'-C'</span>],</div><div class=\"line\">              dict(action=<span class=\"string\">'store_true'</span>, help=<span class=\"string\">'the big C option'</span>) ),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app.log.info(<span class=\"string\">'Inside MyBaseController.default()'</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> self.app.pargs.foo:</div><div class=\"line\">            print(<span class=\"string\">\"Recieved option: foo =&gt; %s\"</span> % self.app.pargs.foo)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"this command does relatively nothing useful\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app.log.info(<span class=\"string\">\"Inside MyBaseController.command1()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(aliases=['cmd2'], help=\"more of nothing\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command2</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app.log.info(<span class=\"string\">\"Inside MyBaseController.command2()\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MySecondController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'second'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help='this is some command', aliases=['some-cmd'])</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">second_cmd1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app.log.info(<span class=\"string\">\"Inside MySecondController.second_cmd1\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        base_controller = <span class=\"string\">'base'</span></div><div class=\"line\">        handlers = [MyBaseController, MySecondController]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>As you can see, we’re able to build out the core functionality of our app such as arguments and sub-commands via controller classes.</p>\n<p>Lets see what this looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">My Application does amazing things!</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  command1</div><div class=\"line\">    this command does relatively nothing useful</div><div class=\"line\"></div><div class=\"line\">  command2 (aliases: cmd2)</div><div class=\"line\">    more of nothing</div><div class=\"line\"></div><div class=\"line\">  second-cmd1 (aliases: some-cmd)</div><div class=\"line\">    this is some command</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help         show this help message and exit</div><div class=\"line\">  --debug            toggle debug output</div><div class=\"line\">  --quiet            suppress all output</div><div class=\"line\">  -f FOO, --foo FOO  the notorious foo option</div><div class=\"line\">  -C                 the big C option</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py</div><div class=\"line\">INFO: Inside MyBaseController.default()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py command1</div><div class=\"line\">INFO: Inside MyBaseController.command1()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py command2</div><div class=\"line\">INFO: Inside MyBaseController.command2()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py second-cmd1</div><div class=\"line\">INFO: Inside MySecondController.second_cmd1()</div></pre></td></tr></table></figure>\n"},{"title":"Introduction","type":"guide","version":"portland","order":2,"_content":"\n\n<p class=\"tip-warn\">\nPortland is a complete fork of Cement 2, and will eventually become Cement 3. It is guaranteed to be broken! Please use Cement 2 in production until stable/3.0.0 is released.\n</p>\n\n\n## What is Cement?\n\nCement is an advanced Application Framework for Python, with a primary focus on Command Line Interfaces (CLI).  Its goal is to introduce a standard, and feature-full platform for both simple and complex command line applications as well as support rapid development needs without sacrificing quality.  Cement is flexible, and it's use cases span from the simplicity of a micro-framework to the complexity of a mega-framework. Whether it's a single file script, or a multi-tier application, Cement is the foundation you've been looking for.\n\nThe first commit to Git was on Dec 4, 2009.  Since then, the framework has seen several iterations in design, and has continued to grow and improve since it's inception.  Cement is the most stable, and complete framework for command line and backend application development.\n\n## Core Features\n\nCement core features include (but are not limited to):\n\n- Core pieces of the framework are customizable via handlers/interfaces\n- Handler system connects implementation classes with Interfaces\n- Extension handler interface to easily extend framework functionality\n- Config handler supports parsing multiple config files into one config\n- Argument handler parses command line arguments and merges with config\n- Log handler supports console and file logging\n- Plugin handler provides an interface to easily extend your application\n- Output handler interface renders return dictionaries to console\n- Cache handler interface adds caching support for improved performance\n- Controller handler supports sub-commands, and nested controllers\n- Hook support adds a bit of magic to apps and also ties into framework\n- Zero external dependencies* (not including optional extensions)\n- 100% test coverage using `nose` and `coverage`\n- 100% PEP8 and style compliant using `flake8`\n- Extensive Sphinx documentation\n- Tested on Python 3.5+\n- Does not support Python 2.x\n\n<p class=\"tip-warn\">Some optional extensions that are shipped with the mainline Cement sources do require external dependencies.  It is the responsibility of the application developer to include these dependencies along with their application, as Cement explicitly does not include them.</p>\n\n## License\n\nThe Cement Framework is Open Source and is distributed under the BSD License (three clause).\n\n```\nCopyright (c) 2009-2017 Data Folk Labs, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of Data Folk Labs, LLC. nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n```\n\n## Installation\n\nStable versions are available via PyPi:\n\n```\n$ pip install cement\n```\n\nDevelopment versions are available via Github:\n\n```\n$ git clone git://github.com/datafolklabs/cement.git\n\n$ cd cement/\n\n$ python setup.py install\n```\n\n## Getting Started\n\n<p class=\"tip-warn\">The developer guide assumes intermediate level knowledge of Python. If you are totally new to Python development, you might want to get more familiar with the language before jumping into a framework.</p>\n\nEx: Hello World:\n\n```python\nfrom cement import App\n\nwith App('myapp') as app:\n    app.run()\n    print('Hello World!')\n```\n\nCLI Usage:\n\n```\n$ python myapp.py --help\nusage: myapp [-h] [--debug] [--quiet]\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n\n$ python myapp.py\nHello World!\n```\n\n\n","source":"portland/dev/index.md","raw":"---\ntitle: Introduction\ntype: guide\nversion: \"portland\"\norder: 2\n---\n\n\n<p class=\"tip-warn\">\nPortland is a complete fork of Cement 2, and will eventually become Cement 3. It is guaranteed to be broken! Please use Cement 2 in production until stable/3.0.0 is released.\n</p>\n\n\n## What is Cement?\n\nCement is an advanced Application Framework for Python, with a primary focus on Command Line Interfaces (CLI).  Its goal is to introduce a standard, and feature-full platform for both simple and complex command line applications as well as support rapid development needs without sacrificing quality.  Cement is flexible, and it's use cases span from the simplicity of a micro-framework to the complexity of a mega-framework. Whether it's a single file script, or a multi-tier application, Cement is the foundation you've been looking for.\n\nThe first commit to Git was on Dec 4, 2009.  Since then, the framework has seen several iterations in design, and has continued to grow and improve since it's inception.  Cement is the most stable, and complete framework for command line and backend application development.\n\n## Core Features\n\nCement core features include (but are not limited to):\n\n- Core pieces of the framework are customizable via handlers/interfaces\n- Handler system connects implementation classes with Interfaces\n- Extension handler interface to easily extend framework functionality\n- Config handler supports parsing multiple config files into one config\n- Argument handler parses command line arguments and merges with config\n- Log handler supports console and file logging\n- Plugin handler provides an interface to easily extend your application\n- Output handler interface renders return dictionaries to console\n- Cache handler interface adds caching support for improved performance\n- Controller handler supports sub-commands, and nested controllers\n- Hook support adds a bit of magic to apps and also ties into framework\n- Zero external dependencies* (not including optional extensions)\n- 100% test coverage using `nose` and `coverage`\n- 100% PEP8 and style compliant using `flake8`\n- Extensive Sphinx documentation\n- Tested on Python 3.5+\n- Does not support Python 2.x\n\n<p class=\"tip-warn\">Some optional extensions that are shipped with the mainline Cement sources do require external dependencies.  It is the responsibility of the application developer to include these dependencies along with their application, as Cement explicitly does not include them.</p>\n\n## License\n\nThe Cement Framework is Open Source and is distributed under the BSD License (three clause).\n\n```\nCopyright (c) 2009-2017 Data Folk Labs, LLC\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright notice,\n      this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of Data Folk Labs, LLC. nor the names of its\n      contributors may be used to endorse or promote products derived from\n      this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n```\n\n## Installation\n\nStable versions are available via PyPi:\n\n```\n$ pip install cement\n```\n\nDevelopment versions are available via Github:\n\n```\n$ git clone git://github.com/datafolklabs/cement.git\n\n$ cd cement/\n\n$ python setup.py install\n```\n\n## Getting Started\n\n<p class=\"tip-warn\">The developer guide assumes intermediate level knowledge of Python. If you are totally new to Python development, you might want to get more familiar with the language before jumping into a framework.</p>\n\nEx: Hello World:\n\n```python\nfrom cement import App\n\nwith App('myapp') as app:\n    app.run()\n    print('Hello World!')\n```\n\nCLI Usage:\n\n```\n$ python myapp.py --help\nusage: myapp [-h] [--debug] [--quiet]\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n\n$ python myapp.py\nHello World!\n```\n\n\n","date":"2017-06-25T00:16:13.000Z","updated":"2017-06-25T00:16:13.000Z","path":"portland/dev/index.html","comments":1,"layout":"page","_id":"cj5dg8qsr000fh6pwsg5dki8f","content":"<p class=\"tip-warn\"><br>Portland is a complete fork of Cement 2, and will eventually become Cement 3. It is guaranteed to be broken! Please use Cement 2 in production until stable/3.0.0 is released.<br></p>\n\n\n<h2 id=\"What-is-Cement\"><a href=\"#What-is-Cement\" class=\"headerlink\" title=\"What is Cement?\"></a>What is Cement?</h2><p>Cement is an advanced Application Framework for Python, with a primary focus on Command Line Interfaces (CLI).  Its goal is to introduce a standard, and feature-full platform for both simple and complex command line applications as well as support rapid development needs without sacrificing quality.  Cement is flexible, and it’s use cases span from the simplicity of a micro-framework to the complexity of a mega-framework. Whether it’s a single file script, or a multi-tier application, Cement is the foundation you’ve been looking for.</p>\n<p>The first commit to Git was on Dec 4, 2009.  Since then, the framework has seen several iterations in design, and has continued to grow and improve since it’s inception.  Cement is the most stable, and complete framework for command line and backend application development.</p>\n<h2 id=\"Core-Features\"><a href=\"#Core-Features\" class=\"headerlink\" title=\"Core Features\"></a>Core Features</h2><p>Cement core features include (but are not limited to):</p>\n<ul>\n<li>Core pieces of the framework are customizable via handlers/interfaces</li>\n<li>Handler system connects implementation classes with Interfaces</li>\n<li>Extension handler interface to easily extend framework functionality</li>\n<li>Config handler supports parsing multiple config files into one config</li>\n<li>Argument handler parses command line arguments and merges with config</li>\n<li>Log handler supports console and file logging</li>\n<li>Plugin handler provides an interface to easily extend your application</li>\n<li>Output handler interface renders return dictionaries to console</li>\n<li>Cache handler interface adds caching support for improved performance</li>\n<li>Controller handler supports sub-commands, and nested controllers</li>\n<li>Hook support adds a bit of magic to apps and also ties into framework</li>\n<li>Zero external dependencies* (not including optional extensions)</li>\n<li>100% test coverage using <code>nose</code> and <code>coverage</code></li>\n<li>100% PEP8 and style compliant using <code>flake8</code></li>\n<li>Extensive Sphinx documentation</li>\n<li>Tested on Python 3.5+</li>\n<li>Does not support Python 2.x</li>\n</ul>\n<p class=\"tip-warn\">Some optional extensions that are shipped with the mainline Cement sources do require external dependencies.  It is the responsibility of the application developer to include these dependencies along with their application, as Cement explicitly does not include them.</p>\n\n<h2 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h2><p>The Cement Framework is Open Source and is distributed under the BSD License (three clause).</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Copyright (c) 2009-2017 Data Folk Labs, LLC</div><div class=\"line\">All rights reserved.</div><div class=\"line\"></div><div class=\"line\">Redistribution and use in source and binary forms, with or without</div><div class=\"line\">modification, are permitted provided that the following conditions are met:</div><div class=\"line\"></div><div class=\"line\">    * Redistributions of source code must retain the above copyright notice,</div><div class=\"line\">      this list of conditions and the following disclaimer.</div><div class=\"line\">    * Redistributions in binary form must reproduce the above copyright</div><div class=\"line\">      notice, this list of conditions and the following disclaimer in the</div><div class=\"line\">      documentation and/or other materials provided with the distribution.</div><div class=\"line\">    * Neither the name of Data Folk Labs, LLC. nor the names of its</div><div class=\"line\">      contributors may be used to endorse or promote products derived from</div><div class=\"line\">      this software without specific prior written permission.</div><div class=\"line\"></div><div class=\"line\">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</div><div class=\"line\">AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</div><div class=\"line\">IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</div><div class=\"line\">DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</div><div class=\"line\">FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</div><div class=\"line\">DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</div><div class=\"line\">SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</div><div class=\"line\">CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</div><div class=\"line\">OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</div><div class=\"line\">OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</div></pre></td></tr></table></figure>\n<h2 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"></a>Installation</h2><p>Stable versions are available via PyPi:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ pip install cement</div></pre></td></tr></table></figure>\n<p>Development versions are available via Github:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git clone git://github.com/datafolklabs/cement.git</div><div class=\"line\"></div><div class=\"line\">$ cd cement/</div><div class=\"line\"></div><div class=\"line\">$ python setup.py install</div></pre></td></tr></table></figure>\n<h2 id=\"Getting-Started\"><a href=\"#Getting-Started\" class=\"headerlink\" title=\"Getting Started\"></a>Getting Started</h2><p class=\"tip-warn\">The developer guide assumes intermediate level knowledge of Python. If you are totally new to Python development, you might want to get more familiar with the language before jumping into a framework.</p>\n\n<p>Ex: Hello World:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> App(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\">    print(<span class=\"string\">'Hello World!'</span>)</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py</div><div class=\"line\">Hello World!</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p class=\"tip-warn\"><br>Portland is a complete fork of Cement 2, and will eventually become Cement 3. It is guaranteed to be broken! Please use Cement 2 in production until stable/3.0.0 is released.<br></p>\n\n\n<h2 id=\"What-is-Cement\"><a href=\"#What-is-Cement\" class=\"headerlink\" title=\"What is Cement?\"></a>What is Cement?</h2><p>Cement is an advanced Application Framework for Python, with a primary focus on Command Line Interfaces (CLI).  Its goal is to introduce a standard, and feature-full platform for both simple and complex command line applications as well as support rapid development needs without sacrificing quality.  Cement is flexible, and it’s use cases span from the simplicity of a micro-framework to the complexity of a mega-framework. Whether it’s a single file script, or a multi-tier application, Cement is the foundation you’ve been looking for.</p>\n<p>The first commit to Git was on Dec 4, 2009.  Since then, the framework has seen several iterations in design, and has continued to grow and improve since it’s inception.  Cement is the most stable, and complete framework for command line and backend application development.</p>\n<h2 id=\"Core-Features\"><a href=\"#Core-Features\" class=\"headerlink\" title=\"Core Features\"></a>Core Features</h2><p>Cement core features include (but are not limited to):</p>\n<ul>\n<li>Core pieces of the framework are customizable via handlers/interfaces</li>\n<li>Handler system connects implementation classes with Interfaces</li>\n<li>Extension handler interface to easily extend framework functionality</li>\n<li>Config handler supports parsing multiple config files into one config</li>\n<li>Argument handler parses command line arguments and merges with config</li>\n<li>Log handler supports console and file logging</li>\n<li>Plugin handler provides an interface to easily extend your application</li>\n<li>Output handler interface renders return dictionaries to console</li>\n<li>Cache handler interface adds caching support for improved performance</li>\n<li>Controller handler supports sub-commands, and nested controllers</li>\n<li>Hook support adds a bit of magic to apps and also ties into framework</li>\n<li>Zero external dependencies* (not including optional extensions)</li>\n<li>100% test coverage using <code>nose</code> and <code>coverage</code></li>\n<li>100% PEP8 and style compliant using <code>flake8</code></li>\n<li>Extensive Sphinx documentation</li>\n<li>Tested on Python 3.5+</li>\n<li>Does not support Python 2.x</li>\n</ul>\n<p class=\"tip-warn\">Some optional extensions that are shipped with the mainline Cement sources do require external dependencies.  It is the responsibility of the application developer to include these dependencies along with their application, as Cement explicitly does not include them.</p>\n\n<h2 id=\"License\"><a href=\"#License\" class=\"headerlink\" title=\"License\"></a>License</h2><p>The Cement Framework is Open Source and is distributed under the BSD License (three clause).</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Copyright (c) 2009-2017 Data Folk Labs, LLC</div><div class=\"line\">All rights reserved.</div><div class=\"line\"></div><div class=\"line\">Redistribution and use in source and binary forms, with or without</div><div class=\"line\">modification, are permitted provided that the following conditions are met:</div><div class=\"line\"></div><div class=\"line\">    * Redistributions of source code must retain the above copyright notice,</div><div class=\"line\">      this list of conditions and the following disclaimer.</div><div class=\"line\">    * Redistributions in binary form must reproduce the above copyright</div><div class=\"line\">      notice, this list of conditions and the following disclaimer in the</div><div class=\"line\">      documentation and/or other materials provided with the distribution.</div><div class=\"line\">    * Neither the name of Data Folk Labs, LLC. nor the names of its</div><div class=\"line\">      contributors may be used to endorse or promote products derived from</div><div class=\"line\">      this software without specific prior written permission.</div><div class=\"line\"></div><div class=\"line\">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</div><div class=\"line\">AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</div><div class=\"line\">IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</div><div class=\"line\">DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE</div><div class=\"line\">FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</div><div class=\"line\">DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</div><div class=\"line\">SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</div><div class=\"line\">CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</div><div class=\"line\">OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</div><div class=\"line\">OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</div></pre></td></tr></table></figure>\n<h2 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"></a>Installation</h2><p>Stable versions are available via PyPi:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ pip install cement</div></pre></td></tr></table></figure>\n<p>Development versions are available via Github:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ git clone git://github.com/datafolklabs/cement.git</div><div class=\"line\"></div><div class=\"line\">$ cd cement/</div><div class=\"line\"></div><div class=\"line\">$ python setup.py install</div></pre></td></tr></table></figure>\n<h2 id=\"Getting-Started\"><a href=\"#Getting-Started\" class=\"headerlink\" title=\"Getting Started\"></a>Getting Started</h2><p class=\"tip-warn\">The developer guide assumes intermediate level knowledge of Python. If you are totally new to Python development, you might want to get more familiar with the language before jumping into a framework.</p>\n\n<p>Ex: Hello World:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> App(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\">    print(<span class=\"string\">'Hello World!'</span>)</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py</div><div class=\"line\">Hello World!</div></pre></td></tr></table></figure>\n"},{"title":"Interfaces and Handlers","type":"guide","version":"portland","order":4,"_content":"\nCement has a unique interface and handler system that is used to break up\npieces of the framework and allow customization of how Cement handles\neverything from logging to config file parsing, and almost every action in\nbetween.\n\nThe Cement Interface code is loosely modeled after `Zope Interface <http://old.zope.org/Products/ZopeInterface>`_\nwhich allows a developer to define an interface that other developers can then\ncreate implementations for.  For example, an interface might define that a\nclass have a function called `_setup()`.  Any implementation of that\ninterface must provide a function called `_setup()`, and perform the\nexpected actions when called.\n\nIn Cement, we call the implementation of interfaces `handlers` and provide\nthe ability to easily register, and retrieve them via the app.\n\nAPI References:\n\n    * :ref:`Cement Interface Module <cement.core.interface>`\n    * :ref:`Cement Handler Module <cement.core.handler>`\n\n\n## Defining an Interface\n\nCement uses interfaces and handlers extensively to manage the framework,\nhowever developers can also make use of this system to provide a clean, and\nstandardized way of allowing other developers to customize their application.\n\nThe following defines a basic interface:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.interface import Interface, Attribute\n\nclass MyInterface(Interface):\n    class IMeta:\n        label = 'myinterface'\n\n    # Must be provided by the implementation\n    Meta = Attribute('Handler Meta-data')\n    my_var = Attribute('A variable of epic proportions.')\n\n    def _setup(app_obj):\n        \"\"\"\n        The setup function is called during application initialization and\n        must 'setup' the handler object making it ready for the framework\n        or the application to make further calls to it.\n\n        Required Arguments:\n\n            app_obj\n                The application object.\n\n        Returns: n/a\n\n        \"\"\"\n\n    def do_something():\n        \"\"\"\n        This function does something.\n\n        \"\"\"\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        define_handlers = [MyInterface]\n\n\nAlternatively, if you need more control you might define a handler this \nway:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    # define interfaces after app is created\n    app.handler.define(MyInterface)\n\n    app.run()\n```\n\nThe above simply defines the interface.  It does *not* implement any\nfunctionality, and can't be used directly.  This is why the class\nfunctions do not have an argument of `self`, nor do they contain any code\nother than comments.\n\nThat said, what is required is an `IMeta` class that is used to interact\nwith the interface.  At the very least, this must include a unique `label`\nto identify the interface.  This can also be considered the 'handler type'.\nFor example, the `ILog` interface has a label of `log` and any handlers\nregistered to that interface are stored in \n`HandlerManager.__handlers__['log']`.\n\nNotice that we defined `Meta` and `my_var` as Interface Attributes.  This\nis a simple identifier that describes an attribute that an implementation is\nexpected to provide.\n\n\n## Validating Interfaces\n\nA validator call back function can be defined in the interfaces IMeta class\nlike this:\n\n```python\nfrom cement.core import interface\n\ndef my_validator(klass, obj):\n    members = [\n        '_setup',\n        'do_something',\n        'my_var',\n        ]\n    interface.validate(MyInterface, obj, members)\n\nclass MyInterface(interface.Interface):\n    class IMeta:\n        label = 'myinterface'\n        validator = my_validator\n```\n\nWhen `CementApp.handler.register()` is called to register a handler to an \ninterface, the validator is called and the handler object is passed to the \nvalidator.  In the above example, we simply define what members we want to \nvalidate for and then call `interface.validate()` which will raise\n`cement.core.exc.InterfaceError` if validation fails.  It is not\nnecessary to use `interface.validate()` but it is useful and recommended.\nIn general, the key thing to note is that a validator either raises\n`InterfaceError` or does nothing if validation passes.\n\n\n## Registering Handlers to an Interface\n\nAn interface simply defines what an implementation is expected to provide,\nwhere a handler actually implements the interface.  The following example\nis a handler that implements the MyInterface above:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.handler import CementBaseHandler\nfrom myapp.interfaces import MyInterface\n\nclass MyHandler(CementBaseHandler):\n    class Meta:\n        interface = MyInterface\n        label = 'my_handler'\n        description = 'This handler implements MyInterface'\n        config_defaults = dict(\n            foo='bar'\n            )\n\n    my_var = 'This is my var'\n\n    def __init__(self):\n        self.app = None\n\n    def _setup(self, app_obj):\n        self.app = app_obj\n\n    def do_something(self):\n        print \"Doing work!\"\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        handlers = [MyHandler]\n```\n\nAlternatively, if you need more control you might use this approach:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    # register handler after the app is created\n    app.handler.register(MyHandler)\n\n    app.run()\n```\n\n\nThe above is a simple class that meets all the expectations of the interface.\nWhen calling `CementApp.handler.register()`, `MyHandler` is passed to the \nvalidator (if defined in the interface) and if it passes validation will be \nregistered into `HandlerManager.__handlers__`.\n\n\n## Using Handlers\n\nThe following are a few examples of working with handlers:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    # Get a log handler called 'logging'\n    lh = app.handler.get('log', 'logging')\n\n    # Instantiate the handler class, passing any keyword arguments that \n    # the handler supports.\n    log = log_handler()\n\n    # Setup the handler, passing it the app object.\n    log._setup(app)\n\n    # List all handlers of type 'config'\n    app.handler.list('config')\n\n    # Check if an interface called 'output' is defined\n    app.handler.defined('output')\n\n    # Check if the handler 'argparse' is registered to the 'argument' \n    # interface\n    app.handler.registered('argument', 'argparse')\n```\n\nIt is important to note that handlers are stored with the app as \nuninstantiated objects.  Meaning you must instantiate them after retrieval,\nand call `_setup(app)` when using handlers directly (as in the above\nexample).\n\n\n## Overriding Default Handlers\n\nCement sets up a number of default handlers for logging, config parsing, etc.\nThese can be overridden in a number of ways.  The first way is by passing\nthem as keyword arguments to `CementApp`:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom myapp.log import MyLogHandler\n\n# Create the application\napp = CementApp('myapp', log_handler=MyLogHandler)\napp.setup()\napp.run()\napp.close()\n```\n\nThe second way to override a handler is by setting it directly in the\n`CementApp` meta data:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom myapp.log import MyLogHandler\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        log_handler = MyLogHandler\n\nwith MyApp() as app:\n    app.run()\n```\n\n\nThere are times that you may want to pre-instantiate handlers before\npassing them to CementApp().  The following works just the same:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom myapp.log import MyLogHandler\n\nmy_log = MyLogHandler(some_param='some_value')\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        log_handler = my_log\n\nwith MyApp() as app:\n    app.run()\n```\n\nTo see what default handlers can be overridden, see the\n:ref:`cement.core.foundation <cement.core.foundation>` documentation.\n\n\n## Multiple Registered Handlers\n\nAll handlers and interfaces are unique.  In most cases, where the framework\nis concerned, only one handler is used.  For example, whatever is configured\nfor the `log_handler` will be used and setup as `app.log`.  However, take\nfor example an Output Handler.  You might have a default `output_handler` of\n`mustache`' (a text templating language) but may also want to override that\nhandler with the `json` output handler when `-o json` is passed at command\nline.  In order to allow this functionality, both the `mustache` and\n`json` output handlers must be registered.\n\nAny number of handlers can be registered to an interface.  You might have a\nuse case for an Interface/Handler that may provide different compatibility\nbase on the operating system, or perhaps based on simply how the application\nis called.  A good example would be an application that automates building\npackages for Linux distributions.  An interface would define what a build\nhandler needs to provide, but the build handler would be different based on\nthe OS.  The application might have an `rpm` build handler, or a `dpkg`\nbuild handler to perform the build process differently.\n\n\n## Customizing Handlers\n\nThe most common way to customize a handler is to subclass it, and then pass\nit to `CementApp`:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.lib.ext_logging import LoggingLogHandler\n\nclass MyLogHandler(LoggingLogHandler):\n    class Meta:\n        label = 'mylog'\n\n    def info(self, msg):\n        # do something to customize this function, here...\n        super(MyLogHandler, self).info(msg)\n\napp = CementApp('myapp', log_handler=MyLogHandler)\n```\n\n## Handler Default Configuration Settings\n\nAll handlers can define default config file settings via their\n`config_defaults` meta option.  These will be merged into the `app.config`\nunder the `[handler_interface].[handler_label]` section.  These settings are\noverridden in the following order.\n\n * The config_defaults dictionary passed to `CementApp`\n * Via any application config files with a\n   `[handler_interface].[handler_type]` block (i.e. `cache.memcached`)\n\n\nThe following shows how to override defaults by passing them with the defaults\ndictionary to `CementApp`:\n\n```python\nfrom cement.core import foundation\nfrom cement.utils.misc import init_defaults\n\ndefaults = init_defaults('myinterface.myhandler')\ndefaults['myinterface.myhandler'] = dict(foo='bar')\napp = foundation.CementApp('myapp', config_defaults=defaults)\n```\n\nCement will use all defaults set via `MyHandler.Meta.config_defaults` (for\nthis example), and then override just what is passed via\n`config_defaults['myinterface.myhandler']`.  You should use this approach\nonly to modify the global defaults for your application.  The second way is to\nthen set configuration file defaults under the `[myinterface.myhandler]`\nsection.  For example:\n\n**my.config**\n\n```\n[myinterface.myhandler]\nfoo = bar\n```\n\nIn the real world this may look like `[cache.memcached]`, or\n`[database.mysql]` depending on what the interface label, and handler\nlabel's are.  Additionally, individual handlers can override their config\nsection by setting `Meta.config_section`.\n\n\n## Overriding Handlers Via Command Line\n\nIn some use cases, you will want the end user to have access to override the\ndefault handler of a particular interface.  For example, Cement ships with\nmultiple Output Handlers including `json`, `yaml`, and `mustache`.  A\ntypical application might default to using `mustache` to render console\noutput from text templates.  That said, without changing any code in the\napplication, the end user can simply pass the `-o json` command line\noption and output the same data that is rendered to template, out in pure\nJSON.\n\nThe only built-in handler override that Cement includes is for the above\nmentioned example, but you can add any that your application requires.\n\nThe following example shows this in action... note that the following is\nalready setup by Cement, but we're putting it here for clarity:\n\n```python\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n\n        # define what extensions we want to load\n        extensions = ['mustache', 'json', 'yaml']\n\n        # define our default output handler\n        output_handler = 'mustache'\n\n        # define our handler override options\n        handler_override_options = dict(\n            output = (['-o'], dict(help='output format')),\n            )\n\n\nwith MyApp() as app:\n    # run the application\n    app.run()\n\n    # define some data for the output handler\n    data = dict(foo='bar')\n\n    # render something using out output handlers, using mustache by\n    # default which will use the default.m templae\n    app.render(data, 'default.m')\n```\n\n\nNote what we see at command line:\n\n```\n$ python myapp.py --help\nusage: myapp.py [-h] [--debug] [--quiet] [-o {yaml,json}]\n\noptional arguments:\n  -h, --help      show this help message and exit\n  --debug         toggle debug output\n  --quiet         suppress all output\n  -o {yaml,json}  output format\n\n```\n\nNotice the `-o` command line option, that includes the choices: `yaml`\nand `json`.  This feature will include all Output Handlers that have the\n`overridable` meta-data option set to `True`.  The MustacheOutputHandler\ndoes not set this option, therefore it does not show up as a valid choice.\n\nNow what happens when we run it?\n\n```\n$ python myapp.py\nThis text is being rendered via Mustache.\nThe value of the 'foo' variable is => 'bar'\n```\n\nThe above is the default output, using `mustache` as our `output_handler`,\nand rendering the output text from a template called `default.m`.  We can\nnow override the output handler using the `-o` option and modify the output\nformat:\n\n```\n$ python myapp.py -o json\n{\"foo\": \"bar\"}\n```\n\nAgain, any handler can be overridden in this fashion.\n","source":"portland/dev/interfaces_and_handlers.md","raw":"---\ntitle: Interfaces and Handlers\ntype: guide\nversion: \"portland\"\norder: 4\n---\n\nCement has a unique interface and handler system that is used to break up\npieces of the framework and allow customization of how Cement handles\neverything from logging to config file parsing, and almost every action in\nbetween.\n\nThe Cement Interface code is loosely modeled after `Zope Interface <http://old.zope.org/Products/ZopeInterface>`_\nwhich allows a developer to define an interface that other developers can then\ncreate implementations for.  For example, an interface might define that a\nclass have a function called `_setup()`.  Any implementation of that\ninterface must provide a function called `_setup()`, and perform the\nexpected actions when called.\n\nIn Cement, we call the implementation of interfaces `handlers` and provide\nthe ability to easily register, and retrieve them via the app.\n\nAPI References:\n\n    * :ref:`Cement Interface Module <cement.core.interface>`\n    * :ref:`Cement Handler Module <cement.core.handler>`\n\n\n## Defining an Interface\n\nCement uses interfaces and handlers extensively to manage the framework,\nhowever developers can also make use of this system to provide a clean, and\nstandardized way of allowing other developers to customize their application.\n\nThe following defines a basic interface:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.interface import Interface, Attribute\n\nclass MyInterface(Interface):\n    class IMeta:\n        label = 'myinterface'\n\n    # Must be provided by the implementation\n    Meta = Attribute('Handler Meta-data')\n    my_var = Attribute('A variable of epic proportions.')\n\n    def _setup(app_obj):\n        \"\"\"\n        The setup function is called during application initialization and\n        must 'setup' the handler object making it ready for the framework\n        or the application to make further calls to it.\n\n        Required Arguments:\n\n            app_obj\n                The application object.\n\n        Returns: n/a\n\n        \"\"\"\n\n    def do_something():\n        \"\"\"\n        This function does something.\n\n        \"\"\"\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        define_handlers = [MyInterface]\n\n\nAlternatively, if you need more control you might define a handler this \nway:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    # define interfaces after app is created\n    app.handler.define(MyInterface)\n\n    app.run()\n```\n\nThe above simply defines the interface.  It does *not* implement any\nfunctionality, and can't be used directly.  This is why the class\nfunctions do not have an argument of `self`, nor do they contain any code\nother than comments.\n\nThat said, what is required is an `IMeta` class that is used to interact\nwith the interface.  At the very least, this must include a unique `label`\nto identify the interface.  This can also be considered the 'handler type'.\nFor example, the `ILog` interface has a label of `log` and any handlers\nregistered to that interface are stored in \n`HandlerManager.__handlers__['log']`.\n\nNotice that we defined `Meta` and `my_var` as Interface Attributes.  This\nis a simple identifier that describes an attribute that an implementation is\nexpected to provide.\n\n\n## Validating Interfaces\n\nA validator call back function can be defined in the interfaces IMeta class\nlike this:\n\n```python\nfrom cement.core import interface\n\ndef my_validator(klass, obj):\n    members = [\n        '_setup',\n        'do_something',\n        'my_var',\n        ]\n    interface.validate(MyInterface, obj, members)\n\nclass MyInterface(interface.Interface):\n    class IMeta:\n        label = 'myinterface'\n        validator = my_validator\n```\n\nWhen `CementApp.handler.register()` is called to register a handler to an \ninterface, the validator is called and the handler object is passed to the \nvalidator.  In the above example, we simply define what members we want to \nvalidate for and then call `interface.validate()` which will raise\n`cement.core.exc.InterfaceError` if validation fails.  It is not\nnecessary to use `interface.validate()` but it is useful and recommended.\nIn general, the key thing to note is that a validator either raises\n`InterfaceError` or does nothing if validation passes.\n\n\n## Registering Handlers to an Interface\n\nAn interface simply defines what an implementation is expected to provide,\nwhere a handler actually implements the interface.  The following example\nis a handler that implements the MyInterface above:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.handler import CementBaseHandler\nfrom myapp.interfaces import MyInterface\n\nclass MyHandler(CementBaseHandler):\n    class Meta:\n        interface = MyInterface\n        label = 'my_handler'\n        description = 'This handler implements MyInterface'\n        config_defaults = dict(\n            foo='bar'\n            )\n\n    my_var = 'This is my var'\n\n    def __init__(self):\n        self.app = None\n\n    def _setup(self, app_obj):\n        self.app = app_obj\n\n    def do_something(self):\n        print \"Doing work!\"\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        handlers = [MyHandler]\n```\n\nAlternatively, if you need more control you might use this approach:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    # register handler after the app is created\n    app.handler.register(MyHandler)\n\n    app.run()\n```\n\n\nThe above is a simple class that meets all the expectations of the interface.\nWhen calling `CementApp.handler.register()`, `MyHandler` is passed to the \nvalidator (if defined in the interface) and if it passes validation will be \nregistered into `HandlerManager.__handlers__`.\n\n\n## Using Handlers\n\nThe following are a few examples of working with handlers:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    # Get a log handler called 'logging'\n    lh = app.handler.get('log', 'logging')\n\n    # Instantiate the handler class, passing any keyword arguments that \n    # the handler supports.\n    log = log_handler()\n\n    # Setup the handler, passing it the app object.\n    log._setup(app)\n\n    # List all handlers of type 'config'\n    app.handler.list('config')\n\n    # Check if an interface called 'output' is defined\n    app.handler.defined('output')\n\n    # Check if the handler 'argparse' is registered to the 'argument' \n    # interface\n    app.handler.registered('argument', 'argparse')\n```\n\nIt is important to note that handlers are stored with the app as \nuninstantiated objects.  Meaning you must instantiate them after retrieval,\nand call `_setup(app)` when using handlers directly (as in the above\nexample).\n\n\n## Overriding Default Handlers\n\nCement sets up a number of default handlers for logging, config parsing, etc.\nThese can be overridden in a number of ways.  The first way is by passing\nthem as keyword arguments to `CementApp`:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom myapp.log import MyLogHandler\n\n# Create the application\napp = CementApp('myapp', log_handler=MyLogHandler)\napp.setup()\napp.run()\napp.close()\n```\n\nThe second way to override a handler is by setting it directly in the\n`CementApp` meta data:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom myapp.log import MyLogHandler\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        log_handler = MyLogHandler\n\nwith MyApp() as app:\n    app.run()\n```\n\n\nThere are times that you may want to pre-instantiate handlers before\npassing them to CementApp().  The following works just the same:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom myapp.log import MyLogHandler\n\nmy_log = MyLogHandler(some_param='some_value')\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        log_handler = my_log\n\nwith MyApp() as app:\n    app.run()\n```\n\nTo see what default handlers can be overridden, see the\n:ref:`cement.core.foundation <cement.core.foundation>` documentation.\n\n\n## Multiple Registered Handlers\n\nAll handlers and interfaces are unique.  In most cases, where the framework\nis concerned, only one handler is used.  For example, whatever is configured\nfor the `log_handler` will be used and setup as `app.log`.  However, take\nfor example an Output Handler.  You might have a default `output_handler` of\n`mustache`' (a text templating language) but may also want to override that\nhandler with the `json` output handler when `-o json` is passed at command\nline.  In order to allow this functionality, both the `mustache` and\n`json` output handlers must be registered.\n\nAny number of handlers can be registered to an interface.  You might have a\nuse case for an Interface/Handler that may provide different compatibility\nbase on the operating system, or perhaps based on simply how the application\nis called.  A good example would be an application that automates building\npackages for Linux distributions.  An interface would define what a build\nhandler needs to provide, but the build handler would be different based on\nthe OS.  The application might have an `rpm` build handler, or a `dpkg`\nbuild handler to perform the build process differently.\n\n\n## Customizing Handlers\n\nThe most common way to customize a handler is to subclass it, and then pass\nit to `CementApp`:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.lib.ext_logging import LoggingLogHandler\n\nclass MyLogHandler(LoggingLogHandler):\n    class Meta:\n        label = 'mylog'\n\n    def info(self, msg):\n        # do something to customize this function, here...\n        super(MyLogHandler, self).info(msg)\n\napp = CementApp('myapp', log_handler=MyLogHandler)\n```\n\n## Handler Default Configuration Settings\n\nAll handlers can define default config file settings via their\n`config_defaults` meta option.  These will be merged into the `app.config`\nunder the `[handler_interface].[handler_label]` section.  These settings are\noverridden in the following order.\n\n * The config_defaults dictionary passed to `CementApp`\n * Via any application config files with a\n   `[handler_interface].[handler_type]` block (i.e. `cache.memcached`)\n\n\nThe following shows how to override defaults by passing them with the defaults\ndictionary to `CementApp`:\n\n```python\nfrom cement.core import foundation\nfrom cement.utils.misc import init_defaults\n\ndefaults = init_defaults('myinterface.myhandler')\ndefaults['myinterface.myhandler'] = dict(foo='bar')\napp = foundation.CementApp('myapp', config_defaults=defaults)\n```\n\nCement will use all defaults set via `MyHandler.Meta.config_defaults` (for\nthis example), and then override just what is passed via\n`config_defaults['myinterface.myhandler']`.  You should use this approach\nonly to modify the global defaults for your application.  The second way is to\nthen set configuration file defaults under the `[myinterface.myhandler]`\nsection.  For example:\n\n**my.config**\n\n```\n[myinterface.myhandler]\nfoo = bar\n```\n\nIn the real world this may look like `[cache.memcached]`, or\n`[database.mysql]` depending on what the interface label, and handler\nlabel's are.  Additionally, individual handlers can override their config\nsection by setting `Meta.config_section`.\n\n\n## Overriding Handlers Via Command Line\n\nIn some use cases, you will want the end user to have access to override the\ndefault handler of a particular interface.  For example, Cement ships with\nmultiple Output Handlers including `json`, `yaml`, and `mustache`.  A\ntypical application might default to using `mustache` to render console\noutput from text templates.  That said, without changing any code in the\napplication, the end user can simply pass the `-o json` command line\noption and output the same data that is rendered to template, out in pure\nJSON.\n\nThe only built-in handler override that Cement includes is for the above\nmentioned example, but you can add any that your application requires.\n\nThe following example shows this in action... note that the following is\nalready setup by Cement, but we're putting it here for clarity:\n\n```python\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n\n        # define what extensions we want to load\n        extensions = ['mustache', 'json', 'yaml']\n\n        # define our default output handler\n        output_handler = 'mustache'\n\n        # define our handler override options\n        handler_override_options = dict(\n            output = (['-o'], dict(help='output format')),\n            )\n\n\nwith MyApp() as app:\n    # run the application\n    app.run()\n\n    # define some data for the output handler\n    data = dict(foo='bar')\n\n    # render something using out output handlers, using mustache by\n    # default which will use the default.m templae\n    app.render(data, 'default.m')\n```\n\n\nNote what we see at command line:\n\n```\n$ python myapp.py --help\nusage: myapp.py [-h] [--debug] [--quiet] [-o {yaml,json}]\n\noptional arguments:\n  -h, --help      show this help message and exit\n  --debug         toggle debug output\n  --quiet         suppress all output\n  -o {yaml,json}  output format\n\n```\n\nNotice the `-o` command line option, that includes the choices: `yaml`\nand `json`.  This feature will include all Output Handlers that have the\n`overridable` meta-data option set to `True`.  The MustacheOutputHandler\ndoes not set this option, therefore it does not show up as a valid choice.\n\nNow what happens when we run it?\n\n```\n$ python myapp.py\nThis text is being rendered via Mustache.\nThe value of the 'foo' variable is => 'bar'\n```\n\nThe above is the default output, using `mustache` as our `output_handler`,\nand rendering the output text from a template called `default.m`.  We can\nnow override the output handler using the `-o` option and modify the output\nformat:\n\n```\n$ python myapp.py -o json\n{\"foo\": \"bar\"}\n```\n\nAgain, any handler can be overridden in this fashion.\n","date":"2017-06-24T23:08:27.000Z","updated":"2017-06-24T23:08:27.000Z","path":"portland/dev/interfaces_and_handlers.html","comments":1,"layout":"page","_id":"cj5dg8qss000hh6pwsts16i2w","content":"<p>Cement has a unique interface and handler system that is used to break up<br>pieces of the framework and allow customization of how Cement handles<br>everything from logging to config file parsing, and almost every action in<br>between.</p>\n<p>The Cement Interface code is loosely modeled after <code>Zope Interface &lt;http://old.zope.org/Products/ZopeInterface&gt;</code>_<br>which allows a developer to define an interface that other developers can then<br>create implementations for.  For example, an interface might define that a<br>class have a function called <code>_setup()</code>.  Any implementation of that<br>interface must provide a function called <code>_setup()</code>, and perform the<br>expected actions when called.</p>\n<p>In Cement, we call the implementation of interfaces <code>handlers</code> and provide<br>the ability to easily register, and retrieve them via the app.</p>\n<p>API References:</p>\n<pre><code>* :ref:`Cement Interface Module &lt;cement.core.interface&gt;`\n* :ref:`Cement Handler Module &lt;cement.core.handler&gt;`\n</code></pre><h2 id=\"Defining-an-Interface\"><a href=\"#Defining-an-Interface\" class=\"headerlink\" title=\"Defining an Interface\"></a>Defining an Interface</h2><p>Cement uses interfaces and handlers extensively to manage the framework,<br>however developers can also make use of this system to provide a clean, and<br>standardized way of allowing other developers to customize their application.</p>\n<p>The following defines a basic interface:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.interface <span class=\"keyword\">import</span> Interface, Attribute</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInterface</span><span class=\"params\">(Interface)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IMeta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myinterface'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Must be provided by the implementation</span></div><div class=\"line\">    Meta = Attribute(<span class=\"string\">'Handler Meta-data'</span>)</div><div class=\"line\">    my_var = Attribute(<span class=\"string\">'A variable of epic proportions.'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_setup</span><span class=\"params\">(app_obj)</span>:</span></div><div class=\"line\">        <span class=\"string\">\"\"\"</span></div><div class=\"line\">        The setup function is called during application initialization and</div><div class=\"line\">        must 'setup' the handler object making it ready for the framework</div><div class=\"line\">        or the application to make further calls to it.</div><div class=\"line\"></div><div class=\"line\">        Required Arguments:</div><div class=\"line\"></div><div class=\"line\">            app_obj</div><div class=\"line\">                The application object.</div><div class=\"line\"></div><div class=\"line\">        Returns: n/a</div><div class=\"line\"></div><div class=\"line\">        \"\"\"</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_something</span><span class=\"params\">()</span>:</span></div><div class=\"line\">        <span class=\"string\">\"\"\"</span></div><div class=\"line\">        This function does something.</div><div class=\"line\"></div><div class=\"line\">        \"\"\"</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        define_handlers = [MyInterface]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">Alternatively, <span class=\"keyword\">if</span> you need more control you might define a handler this </div><div class=\"line\">way:</div><div class=\"line\"></div><div class=\"line\">```python</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># define interfaces after app is created</span></div><div class=\"line\">    app.handler.define(MyInterface)</div><div class=\"line\"></div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>The above simply defines the interface.  It does <em>not</em> implement any<br>functionality, and can’t be used directly.  This is why the class<br>functions do not have an argument of <code>self</code>, nor do they contain any code<br>other than comments.</p>\n<p>That said, what is required is an <code>IMeta</code> class that is used to interact<br>with the interface.  At the very least, this must include a unique <code>label</code><br>to identify the interface.  This can also be considered the ‘handler type’.<br>For example, the <code>ILog</code> interface has a label of <code>log</code> and any handlers<br>registered to that interface are stored in<br><code>HandlerManager.__handlers__[&#39;log&#39;]</code>.</p>\n<p>Notice that we defined <code>Meta</code> and <code>my_var</code> as Interface Attributes.  This<br>is a simple identifier that describes an attribute that an implementation is<br>expected to provide.</p>\n<h2 id=\"Validating-Interfaces\"><a href=\"#Validating-Interfaces\" class=\"headerlink\" title=\"Validating Interfaces\"></a>Validating Interfaces</h2><p>A validator call back function can be defined in the interfaces IMeta class<br>like this:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> interface</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_validator</span><span class=\"params\">(klass, obj)</span>:</span></div><div class=\"line\">    members = [</div><div class=\"line\">        <span class=\"string\">'_setup'</span>,</div><div class=\"line\">        <span class=\"string\">'do_something'</span>,</div><div class=\"line\">        <span class=\"string\">'my_var'</span>,</div><div class=\"line\">        ]</div><div class=\"line\">    interface.validate(MyInterface, obj, members)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInterface</span><span class=\"params\">(interface.Interface)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IMeta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myinterface'</span></div><div class=\"line\">        validator = my_validator</div></pre></td></tr></table></figure>\n<p>When <code>CementApp.handler.register()</code> is called to register a handler to an<br>interface, the validator is called and the handler object is passed to the<br>validator.  In the above example, we simply define what members we want to<br>validate for and then call <code>interface.validate()</code> which will raise<br><code>cement.core.exc.InterfaceError</code> if validation fails.  It is not<br>necessary to use <code>interface.validate()</code> but it is useful and recommended.<br>In general, the key thing to note is that a validator either raises<br><code>InterfaceError</code> or does nothing if validation passes.</p>\n<h2 id=\"Registering-Handlers-to-an-Interface\"><a href=\"#Registering-Handlers-to-an-Interface\" class=\"headerlink\" title=\"Registering Handlers to an Interface\"></a>Registering Handlers to an Interface</h2><p>An interface simply defines what an implementation is expected to provide,<br>where a handler actually implements the interface.  The following example<br>is a handler that implements the MyInterface above:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.handler <span class=\"keyword\">import</span> CementBaseHandler</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.interfaces <span class=\"keyword\">import</span> MyInterface</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span><span class=\"params\">(CementBaseHandler)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        interface = MyInterface</div><div class=\"line\">        label = <span class=\"string\">'my_handler'</span></div><div class=\"line\">        description = <span class=\"string\">'This handler implements MyInterface'</span></div><div class=\"line\">        config_defaults = dict(</div><div class=\"line\">            foo=<span class=\"string\">'bar'</span></div><div class=\"line\">            )</div><div class=\"line\"></div><div class=\"line\">    my_var = <span class=\"string\">'This is my var'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app = <span class=\"keyword\">None</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_setup</span><span class=\"params\">(self, app_obj)</span>:</span></div><div class=\"line\">        self.app = app_obj</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_something</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Doing work!\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        handlers = [MyHandler]</div></pre></td></tr></table></figure>\n<p>Alternatively, if you need more control you might use this approach:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># register handler after the app is created</span></div><div class=\"line\">    app.handler.register(MyHandler)</div><div class=\"line\"></div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>The above is a simple class that meets all the expectations of the interface.<br>When calling <code>CementApp.handler.register()</code>, <code>MyHandler</code> is passed to the<br>validator (if defined in the interface) and if it passes validation will be<br>registered into <code>HandlerManager.__handlers__</code>.</p>\n<h2 id=\"Using-Handlers\"><a href=\"#Using-Handlers\" class=\"headerlink\" title=\"Using Handlers\"></a>Using Handlers</h2><p>The following are a few examples of working with handlers:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># Get a log handler called 'logging'</span></div><div class=\"line\">    lh = app.handler.get(<span class=\"string\">'log'</span>, <span class=\"string\">'logging'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Instantiate the handler class, passing any keyword arguments that </span></div><div class=\"line\">    <span class=\"comment\"># the handler supports.</span></div><div class=\"line\">    log = log_handler()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Setup the handler, passing it the app object.</span></div><div class=\"line\">    log._setup(app)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># List all handlers of type 'config'</span></div><div class=\"line\">    app.handler.list(<span class=\"string\">'config'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Check if an interface called 'output' is defined</span></div><div class=\"line\">    app.handler.defined(<span class=\"string\">'output'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Check if the handler 'argparse' is registered to the 'argument' </span></div><div class=\"line\">    <span class=\"comment\"># interface</span></div><div class=\"line\">    app.handler.registered(<span class=\"string\">'argument'</span>, <span class=\"string\">'argparse'</span>)</div></pre></td></tr></table></figure>\n<p>It is important to note that handlers are stored with the app as<br>uninstantiated objects.  Meaning you must instantiate them after retrieval,<br>and call <code>_setup(app)</code> when using handlers directly (as in the above<br>example).</p>\n<h2 id=\"Overriding-Default-Handlers\"><a href=\"#Overriding-Default-Handlers\" class=\"headerlink\" title=\"Overriding Default Handlers\"></a>Overriding Default Handlers</h2><p>Cement sets up a number of default handlers for logging, config parsing, etc.<br>These can be overridden in a number of ways.  The first way is by passing<br>them as keyword arguments to <code>CementApp</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.log <span class=\"keyword\">import</span> MyLogHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Create the application</span></div><div class=\"line\">app = CementApp(<span class=\"string\">'myapp'</span>, log_handler=MyLogHandler)</div><div class=\"line\">app.setup()</div><div class=\"line\">app.run()</div><div class=\"line\">app.close()</div></pre></td></tr></table></figure>\n<p>The second way to override a handler is by setting it directly in the<br><code>CementApp</code> meta data:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.log <span class=\"keyword\">import</span> MyLogHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        log_handler = MyLogHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>There are times that you may want to pre-instantiate handlers before<br>passing them to CementApp().  The following works just the same:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.log <span class=\"keyword\">import</span> MyLogHandler</div><div class=\"line\"></div><div class=\"line\">my_log = MyLogHandler(some_param=<span class=\"string\">'some_value'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        log_handler = my_log</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>To see what default handlers can be overridden, see the<br>:ref:<code>cement.core.foundation &lt;cement.core.foundation&gt;</code> documentation.</p>\n<h2 id=\"Multiple-Registered-Handlers\"><a href=\"#Multiple-Registered-Handlers\" class=\"headerlink\" title=\"Multiple Registered Handlers\"></a>Multiple Registered Handlers</h2><p>All handlers and interfaces are unique.  In most cases, where the framework<br>is concerned, only one handler is used.  For example, whatever is configured<br>for the <code>log_handler</code> will be used and setup as <code>app.log</code>.  However, take<br>for example an Output Handler.  You might have a default <code>output_handler</code> of<br><code>mustache</code>‘ (a text templating language) but may also want to override that<br>handler with the <code>json</code> output handler when <code>-o json</code> is passed at command<br>line.  In order to allow this functionality, both the <code>mustache</code> and<br><code>json</code> output handlers must be registered.</p>\n<p>Any number of handlers can be registered to an interface.  You might have a<br>use case for an Interface/Handler that may provide different compatibility<br>base on the operating system, or perhaps based on simply how the application<br>is called.  A good example would be an application that automates building<br>packages for Linux distributions.  An interface would define what a build<br>handler needs to provide, but the build handler would be different based on<br>the OS.  The application might have an <code>rpm</code> build handler, or a <code>dpkg</code><br>build handler to perform the build process differently.</p>\n<h2 id=\"Customizing-Handlers\"><a href=\"#Customizing-Handlers\" class=\"headerlink\" title=\"Customizing Handlers\"></a>Customizing Handlers</h2><p>The most common way to customize a handler is to subclass it, and then pass<br>it to <code>CementApp</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.lib.ext_logging <span class=\"keyword\">import</span> LoggingLogHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyLogHandler</span><span class=\"params\">(LoggingLogHandler)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'mylog'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">info</span><span class=\"params\">(self, msg)</span>:</span></div><div class=\"line\">        <span class=\"comment\"># do something to customize this function, here...</span></div><div class=\"line\">        super(MyLogHandler, self).info(msg)</div><div class=\"line\"></div><div class=\"line\">app = CementApp(<span class=\"string\">'myapp'</span>, log_handler=MyLogHandler)</div></pre></td></tr></table></figure>\n<h2 id=\"Handler-Default-Configuration-Settings\"><a href=\"#Handler-Default-Configuration-Settings\" class=\"headerlink\" title=\"Handler Default Configuration Settings\"></a>Handler Default Configuration Settings</h2><p>All handlers can define default config file settings via their<br><code>config_defaults</code> meta option.  These will be merged into the <code>app.config</code><br>under the <code>[handler_interface].[handler_label]</code> section.  These settings are<br>overridden in the following order.</p>\n<ul>\n<li>The config_defaults dictionary passed to <code>CementApp</code></li>\n<li>Via any application config files with a<br><code>[handler_interface].[handler_type]</code> block (i.e. <code>cache.memcached</code>)</li>\n</ul>\n<p>The following shows how to override defaults by passing them with the defaults<br>dictionary to <code>CementApp</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myinterface.myhandler'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'myinterface.myhandler'</span>] = dict(foo=<span class=\"string\">'bar'</span>)</div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>, config_defaults=defaults)</div></pre></td></tr></table></figure>\n<p>Cement will use all defaults set via <code>MyHandler.Meta.config_defaults</code> (for<br>this example), and then override just what is passed via<br><code>config_defaults[&#39;myinterface.myhandler&#39;]</code>.  You should use this approach<br>only to modify the global defaults for your application.  The second way is to<br>then set configuration file defaults under the <code>[myinterface.myhandler]</code><br>section.  For example:</p>\n<p><strong>my.config</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myinterface.myhandler]</div><div class=\"line\">foo = bar</div></pre></td></tr></table></figure>\n<p>In the real world this may look like <code>[cache.memcached]</code>, or<br><code>[database.mysql]</code> depending on what the interface label, and handler<br>label’s are.  Additionally, individual handlers can override their config<br>section by setting <code>Meta.config_section</code>.</p>\n<h2 id=\"Overriding-Handlers-Via-Command-Line\"><a href=\"#Overriding-Handlers-Via-Command-Line\" class=\"headerlink\" title=\"Overriding Handlers Via Command Line\"></a>Overriding Handlers Via Command Line</h2><p>In some use cases, you will want the end user to have access to override the<br>default handler of a particular interface.  For example, Cement ships with<br>multiple Output Handlers including <code>json</code>, <code>yaml</code>, and <code>mustache</code>.  A<br>typical application might default to using <code>mustache</code> to render console<br>output from text templates.  That said, without changing any code in the<br>application, the end user can simply pass the <code>-o json</code> command line<br>option and output the same data that is rendered to template, out in pure<br>JSON.</p>\n<p>The only built-in handler override that Cement includes is for the above<br>mentioned example, but you can add any that your application requires.</p>\n<p>The following example shows this in action… note that the following is<br>already setup by Cement, but we’re putting it here for clarity:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># define what extensions we want to load</span></div><div class=\"line\">        extensions = [<span class=\"string\">'mustache'</span>, <span class=\"string\">'json'</span>, <span class=\"string\">'yaml'</span>]</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># define our default output handler</span></div><div class=\"line\">        output_handler = <span class=\"string\">'mustache'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># define our handler override options</span></div><div class=\"line\">        handler_override_options = dict(</div><div class=\"line\">            output = ([<span class=\"string\">'-o'</span>], dict(help=<span class=\"string\">'output format'</span>)),</div><div class=\"line\">            )</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># run the application</span></div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># define some data for the output handler</span></div><div class=\"line\">    data = dict(foo=<span class=\"string\">'bar'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># render something using out output handlers, using mustache by</span></div><div class=\"line\">    <span class=\"comment\"># default which will use the default.m templae</span></div><div class=\"line\">    app.render(data, <span class=\"string\">'default.m'</span>)</div></pre></td></tr></table></figure>\n<p>Note what we see at command line:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py [-h] [--debug] [--quiet] [-o &#123;yaml,json&#125;]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help      show this help message and exit</div><div class=\"line\">  --debug         toggle debug output</div><div class=\"line\">  --quiet         suppress all output</div><div class=\"line\">  -o &#123;yaml,json&#125;  output format</div></pre></td></tr></table></figure>\n<p>Notice the <code>-o</code> command line option, that includes the choices: <code>yaml</code><br>and <code>json</code>.  This feature will include all Output Handlers that have the<br><code>overridable</code> meta-data option set to <code>True</code>.  The MustacheOutputHandler<br>does not set this option, therefore it does not show up as a valid choice.</p>\n<p>Now what happens when we run it?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">This text is being rendered via Mustache.</div><div class=\"line\">The value of the &apos;foo&apos; variable is =&gt; &apos;bar&apos;</div></pre></td></tr></table></figure>\n<p>The above is the default output, using <code>mustache</code> as our <code>output_handler</code>,<br>and rendering the output text from a template called <code>default.m</code>.  We can<br>now override the output handler using the <code>-o</code> option and modify the output<br>format:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py -o json</div><div class=\"line\">&#123;&quot;foo&quot;: &quot;bar&quot;&#125;</div></pre></td></tr></table></figure>\n<p>Again, any handler can be overridden in this fashion.</p>\n","excerpt":"","more":"<p>Cement has a unique interface and handler system that is used to break up<br>pieces of the framework and allow customization of how Cement handles<br>everything from logging to config file parsing, and almost every action in<br>between.</p>\n<p>The Cement Interface code is loosely modeled after <code>Zope Interface &lt;http://old.zope.org/Products/ZopeInterface&gt;</code>_<br>which allows a developer to define an interface that other developers can then<br>create implementations for.  For example, an interface might define that a<br>class have a function called <code>_setup()</code>.  Any implementation of that<br>interface must provide a function called <code>_setup()</code>, and perform the<br>expected actions when called.</p>\n<p>In Cement, we call the implementation of interfaces <code>handlers</code> and provide<br>the ability to easily register, and retrieve them via the app.</p>\n<p>API References:</p>\n<pre><code>* :ref:`Cement Interface Module &lt;cement.core.interface&gt;`\n* :ref:`Cement Handler Module &lt;cement.core.handler&gt;`\n</code></pre><h2 id=\"Defining-an-Interface\"><a href=\"#Defining-an-Interface\" class=\"headerlink\" title=\"Defining an Interface\"></a>Defining an Interface</h2><p>Cement uses interfaces and handlers extensively to manage the framework,<br>however developers can also make use of this system to provide a clean, and<br>standardized way of allowing other developers to customize their application.</p>\n<p>The following defines a basic interface:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.interface <span class=\"keyword\">import</span> Interface, Attribute</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInterface</span><span class=\"params\">(Interface)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IMeta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myinterface'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Must be provided by the implementation</span></div><div class=\"line\">    Meta = Attribute(<span class=\"string\">'Handler Meta-data'</span>)</div><div class=\"line\">    my_var = Attribute(<span class=\"string\">'A variable of epic proportions.'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_setup</span><span class=\"params\">(app_obj)</span>:</span></div><div class=\"line\">        <span class=\"string\">\"\"\"</div><div class=\"line\">        The setup function is called during application initialization and</div><div class=\"line\">        must 'setup' the handler object making it ready for the framework</div><div class=\"line\">        or the application to make further calls to it.</div><div class=\"line\"></div><div class=\"line\">        Required Arguments:</div><div class=\"line\"></div><div class=\"line\">            app_obj</div><div class=\"line\">                The application object.</div><div class=\"line\"></div><div class=\"line\">        Returns: n/a</div><div class=\"line\"></div><div class=\"line\">        \"\"\"</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_something</span><span class=\"params\">()</span>:</span></div><div class=\"line\">        <span class=\"string\">\"\"\"</div><div class=\"line\">        This function does something.</div><div class=\"line\"></div><div class=\"line\">        \"\"\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        define_handlers = [MyInterface]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">Alternatively, <span class=\"keyword\">if</span> you need more control you might define a handler this </div><div class=\"line\">way:</div><div class=\"line\"></div><div class=\"line\">```python</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># define interfaces after app is created</span></div><div class=\"line\">    app.handler.define(MyInterface)</div><div class=\"line\"></div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>The above simply defines the interface.  It does <em>not</em> implement any<br>functionality, and can’t be used directly.  This is why the class<br>functions do not have an argument of <code>self</code>, nor do they contain any code<br>other than comments.</p>\n<p>That said, what is required is an <code>IMeta</code> class that is used to interact<br>with the interface.  At the very least, this must include a unique <code>label</code><br>to identify the interface.  This can also be considered the ‘handler type’.<br>For example, the <code>ILog</code> interface has a label of <code>log</code> and any handlers<br>registered to that interface are stored in<br><code>HandlerManager.__handlers__[&#39;log&#39;]</code>.</p>\n<p>Notice that we defined <code>Meta</code> and <code>my_var</code> as Interface Attributes.  This<br>is a simple identifier that describes an attribute that an implementation is<br>expected to provide.</p>\n<h2 id=\"Validating-Interfaces\"><a href=\"#Validating-Interfaces\" class=\"headerlink\" title=\"Validating Interfaces\"></a>Validating Interfaces</h2><p>A validator call back function can be defined in the interfaces IMeta class<br>like this:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> interface</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_validator</span><span class=\"params\">(klass, obj)</span>:</span></div><div class=\"line\">    members = [</div><div class=\"line\">        <span class=\"string\">'_setup'</span>,</div><div class=\"line\">        <span class=\"string\">'do_something'</span>,</div><div class=\"line\">        <span class=\"string\">'my_var'</span>,</div><div class=\"line\">        ]</div><div class=\"line\">    interface.validate(MyInterface, obj, members)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInterface</span><span class=\"params\">(interface.Interface)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IMeta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myinterface'</span></div><div class=\"line\">        validator = my_validator</div></pre></td></tr></table></figure>\n<p>When <code>CementApp.handler.register()</code> is called to register a handler to an<br>interface, the validator is called and the handler object is passed to the<br>validator.  In the above example, we simply define what members we want to<br>validate for and then call <code>interface.validate()</code> which will raise<br><code>cement.core.exc.InterfaceError</code> if validation fails.  It is not<br>necessary to use <code>interface.validate()</code> but it is useful and recommended.<br>In general, the key thing to note is that a validator either raises<br><code>InterfaceError</code> or does nothing if validation passes.</p>\n<h2 id=\"Registering-Handlers-to-an-Interface\"><a href=\"#Registering-Handlers-to-an-Interface\" class=\"headerlink\" title=\"Registering Handlers to an Interface\"></a>Registering Handlers to an Interface</h2><p>An interface simply defines what an implementation is expected to provide,<br>where a handler actually implements the interface.  The following example<br>is a handler that implements the MyInterface above:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.handler <span class=\"keyword\">import</span> CementBaseHandler</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.interfaces <span class=\"keyword\">import</span> MyInterface</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHandler</span><span class=\"params\">(CementBaseHandler)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        interface = MyInterface</div><div class=\"line\">        label = <span class=\"string\">'my_handler'</span></div><div class=\"line\">        description = <span class=\"string\">'This handler implements MyInterface'</span></div><div class=\"line\">        config_defaults = dict(</div><div class=\"line\">            foo=<span class=\"string\">'bar'</span></div><div class=\"line\">            )</div><div class=\"line\"></div><div class=\"line\">    my_var = <span class=\"string\">'This is my var'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app = <span class=\"keyword\">None</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_setup</span><span class=\"params\">(self, app_obj)</span>:</span></div><div class=\"line\">        self.app = app_obj</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_something</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Doing work!\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        handlers = [MyHandler]</div></pre></td></tr></table></figure>\n<p>Alternatively, if you need more control you might use this approach:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># register handler after the app is created</span></div><div class=\"line\">    app.handler.register(MyHandler)</div><div class=\"line\"></div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>The above is a simple class that meets all the expectations of the interface.<br>When calling <code>CementApp.handler.register()</code>, <code>MyHandler</code> is passed to the<br>validator (if defined in the interface) and if it passes validation will be<br>registered into <code>HandlerManager.__handlers__</code>.</p>\n<h2 id=\"Using-Handlers\"><a href=\"#Using-Handlers\" class=\"headerlink\" title=\"Using Handlers\"></a>Using Handlers</h2><p>The following are a few examples of working with handlers:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># Get a log handler called 'logging'</span></div><div class=\"line\">    lh = app.handler.get(<span class=\"string\">'log'</span>, <span class=\"string\">'logging'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Instantiate the handler class, passing any keyword arguments that </span></div><div class=\"line\">    <span class=\"comment\"># the handler supports.</span></div><div class=\"line\">    log = log_handler()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Setup the handler, passing it the app object.</span></div><div class=\"line\">    log._setup(app)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># List all handlers of type 'config'</span></div><div class=\"line\">    app.handler.list(<span class=\"string\">'config'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Check if an interface called 'output' is defined</span></div><div class=\"line\">    app.handler.defined(<span class=\"string\">'output'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># Check if the handler 'argparse' is registered to the 'argument' </span></div><div class=\"line\">    <span class=\"comment\"># interface</span></div><div class=\"line\">    app.handler.registered(<span class=\"string\">'argument'</span>, <span class=\"string\">'argparse'</span>)</div></pre></td></tr></table></figure>\n<p>It is important to note that handlers are stored with the app as<br>uninstantiated objects.  Meaning you must instantiate them after retrieval,<br>and call <code>_setup(app)</code> when using handlers directly (as in the above<br>example).</p>\n<h2 id=\"Overriding-Default-Handlers\"><a href=\"#Overriding-Default-Handlers\" class=\"headerlink\" title=\"Overriding Default Handlers\"></a>Overriding Default Handlers</h2><p>Cement sets up a number of default handlers for logging, config parsing, etc.<br>These can be overridden in a number of ways.  The first way is by passing<br>them as keyword arguments to <code>CementApp</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.log <span class=\"keyword\">import</span> MyLogHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Create the application</span></div><div class=\"line\">app = CementApp(<span class=\"string\">'myapp'</span>, log_handler=MyLogHandler)</div><div class=\"line\">app.setup()</div><div class=\"line\">app.run()</div><div class=\"line\">app.close()</div></pre></td></tr></table></figure>\n<p>The second way to override a handler is by setting it directly in the<br><code>CementApp</code> meta data:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.log <span class=\"keyword\">import</span> MyLogHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        log_handler = MyLogHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>There are times that you may want to pre-instantiate handlers before<br>passing them to CementApp().  The following works just the same:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.log <span class=\"keyword\">import</span> MyLogHandler</div><div class=\"line\"></div><div class=\"line\">my_log = MyLogHandler(some_param=<span class=\"string\">'some_value'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        log_handler = my_log</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>To see what default handlers can be overridden, see the<br>:ref:<code>cement.core.foundation &lt;cement.core.foundation&gt;</code> documentation.</p>\n<h2 id=\"Multiple-Registered-Handlers\"><a href=\"#Multiple-Registered-Handlers\" class=\"headerlink\" title=\"Multiple Registered Handlers\"></a>Multiple Registered Handlers</h2><p>All handlers and interfaces are unique.  In most cases, where the framework<br>is concerned, only one handler is used.  For example, whatever is configured<br>for the <code>log_handler</code> will be used and setup as <code>app.log</code>.  However, take<br>for example an Output Handler.  You might have a default <code>output_handler</code> of<br><code>mustache</code>‘ (a text templating language) but may also want to override that<br>handler with the <code>json</code> output handler when <code>-o json</code> is passed at command<br>line.  In order to allow this functionality, both the <code>mustache</code> and<br><code>json</code> output handlers must be registered.</p>\n<p>Any number of handlers can be registered to an interface.  You might have a<br>use case for an Interface/Handler that may provide different compatibility<br>base on the operating system, or perhaps based on simply how the application<br>is called.  A good example would be an application that automates building<br>packages for Linux distributions.  An interface would define what a build<br>handler needs to provide, but the build handler would be different based on<br>the OS.  The application might have an <code>rpm</code> build handler, or a <code>dpkg</code><br>build handler to perform the build process differently.</p>\n<h2 id=\"Customizing-Handlers\"><a href=\"#Customizing-Handlers\" class=\"headerlink\" title=\"Customizing Handlers\"></a>Customizing Handlers</h2><p>The most common way to customize a handler is to subclass it, and then pass<br>it to <code>CementApp</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.lib.ext_logging <span class=\"keyword\">import</span> LoggingLogHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyLogHandler</span><span class=\"params\">(LoggingLogHandler)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'mylog'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">info</span><span class=\"params\">(self, msg)</span>:</span></div><div class=\"line\">        <span class=\"comment\"># do something to customize this function, here...</span></div><div class=\"line\">        super(MyLogHandler, self).info(msg)</div><div class=\"line\"></div><div class=\"line\">app = CementApp(<span class=\"string\">'myapp'</span>, log_handler=MyLogHandler)</div></pre></td></tr></table></figure>\n<h2 id=\"Handler-Default-Configuration-Settings\"><a href=\"#Handler-Default-Configuration-Settings\" class=\"headerlink\" title=\"Handler Default Configuration Settings\"></a>Handler Default Configuration Settings</h2><p>All handlers can define default config file settings via their<br><code>config_defaults</code> meta option.  These will be merged into the <code>app.config</code><br>under the <code>[handler_interface].[handler_label]</code> section.  These settings are<br>overridden in the following order.</p>\n<ul>\n<li>The config_defaults dictionary passed to <code>CementApp</code></li>\n<li>Via any application config files with a<br><code>[handler_interface].[handler_type]</code> block (i.e. <code>cache.memcached</code>)</li>\n</ul>\n<p>The following shows how to override defaults by passing them with the defaults<br>dictionary to <code>CementApp</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> foundation</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myinterface.myhandler'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'myinterface.myhandler'</span>] = dict(foo=<span class=\"string\">'bar'</span>)</div><div class=\"line\">app = foundation.CementApp(<span class=\"string\">'myapp'</span>, config_defaults=defaults)</div></pre></td></tr></table></figure>\n<p>Cement will use all defaults set via <code>MyHandler.Meta.config_defaults</code> (for<br>this example), and then override just what is passed via<br><code>config_defaults[&#39;myinterface.myhandler&#39;]</code>.  You should use this approach<br>only to modify the global defaults for your application.  The second way is to<br>then set configuration file defaults under the <code>[myinterface.myhandler]</code><br>section.  For example:</p>\n<p><strong>my.config</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myinterface.myhandler]</div><div class=\"line\">foo = bar</div></pre></td></tr></table></figure>\n<p>In the real world this may look like <code>[cache.memcached]</code>, or<br><code>[database.mysql]</code> depending on what the interface label, and handler<br>label’s are.  Additionally, individual handlers can override their config<br>section by setting <code>Meta.config_section</code>.</p>\n<h2 id=\"Overriding-Handlers-Via-Command-Line\"><a href=\"#Overriding-Handlers-Via-Command-Line\" class=\"headerlink\" title=\"Overriding Handlers Via Command Line\"></a>Overriding Handlers Via Command Line</h2><p>In some use cases, you will want the end user to have access to override the<br>default handler of a particular interface.  For example, Cement ships with<br>multiple Output Handlers including <code>json</code>, <code>yaml</code>, and <code>mustache</code>.  A<br>typical application might default to using <code>mustache</code> to render console<br>output from text templates.  That said, without changing any code in the<br>application, the end user can simply pass the <code>-o json</code> command line<br>option and output the same data that is rendered to template, out in pure<br>JSON.</p>\n<p>The only built-in handler override that Cement includes is for the above<br>mentioned example, but you can add any that your application requires.</p>\n<p>The following example shows this in action… note that the following is<br>already setup by Cement, but we’re putting it here for clarity:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># define what extensions we want to load</span></div><div class=\"line\">        extensions = [<span class=\"string\">'mustache'</span>, <span class=\"string\">'json'</span>, <span class=\"string\">'yaml'</span>]</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># define our default output handler</span></div><div class=\"line\">        output_handler = <span class=\"string\">'mustache'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># define our handler override options</span></div><div class=\"line\">        handler_override_options = dict(</div><div class=\"line\">            output = ([<span class=\"string\">'-o'</span>], dict(help=<span class=\"string\">'output format'</span>)),</div><div class=\"line\">            )</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># run the application</span></div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># define some data for the output handler</span></div><div class=\"line\">    data = dict(foo=<span class=\"string\">'bar'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># render something using out output handlers, using mustache by</span></div><div class=\"line\">    <span class=\"comment\"># default which will use the default.m templae</span></div><div class=\"line\">    app.render(data, <span class=\"string\">'default.m'</span>)</div></pre></td></tr></table></figure>\n<p>Note what we see at command line:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py [-h] [--debug] [--quiet] [-o &#123;yaml,json&#125;]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help      show this help message and exit</div><div class=\"line\">  --debug         toggle debug output</div><div class=\"line\">  --quiet         suppress all output</div><div class=\"line\">  -o &#123;yaml,json&#125;  output format</div></pre></td></tr></table></figure>\n<p>Notice the <code>-o</code> command line option, that includes the choices: <code>yaml</code><br>and <code>json</code>.  This feature will include all Output Handlers that have the<br><code>overridable</code> meta-data option set to <code>True</code>.  The MustacheOutputHandler<br>does not set this option, therefore it does not show up as a valid choice.</p>\n<p>Now what happens when we run it?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">This text is being rendered via Mustache.</div><div class=\"line\">The value of the &apos;foo&apos; variable is =&gt; &apos;bar&apos;</div></pre></td></tr></table></figure>\n<p>The above is the default output, using <code>mustache</code> as our <code>output_handler</code>,<br>and rendering the output text from a template called <code>default.m</code>.  We can<br>now override the output handler using the <code>-o</code> option and modify the output<br>format:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py -o json</div><div class=\"line\">&#123;&quot;foo&quot;: &quot;bar&quot;&#125;</div></pre></td></tr></table></figure>\n<p>Again, any handler can be overridden in this fashion.</p>\n"},{"title":"Framework Overview","type":"guide","version":"portland","order":3,"_content":"\nThis section is intended to give a brief overview of some of the most commonly used core features of Cement.  Please do not be discouraged if you don't \"get it\" right away.  Please also do not think, \"is this it?\".  This is not intended to be an exhaustive end-all-be-all coverage of every feature of the framework.\n\nSome assumptions are being made here.  Primarily, we assume that you've used and are familiar with Python.  The overview is intended to give a high level look at using Cement.  Please dive deeper into the individual sections after the overview in order to gain a better understanding of each component.\n\n\n## The Application Object\n\nThe core of your application starts with the Cement `App` object, which we will refer to throughout this documentation in several ways:\n\n- `App` - The uninstantiated Cement `App` base class\n- `MyApp` - The uninstatiated/sub-classed Cement application you are creating\n- `app` - The instantiated application object\n\n\nTechnically, Cement `App` can be used direcly (as in the example), however in practice you will almost always sub-class `App` in order to configure it for your needs (I.e. `MyApp`).\n\n\nUsing Cement App Directly:\n\n```python\nfrom cement import App\n\nwith App('myapp') as app:\n    app.run()\n```\n\nSub-classing Cement App:\n\n```python\nfrom cement import App\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n\nwith MyApp() as app:\n    app.run()\n```\n\nCLI Usage:\n\n```bash\n$ python myapp.py --help\nusage: myapp [-h] [--debug] [--quiet]\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n```\n\n\n## MetaMixin\n\nCement uses `MetaMixin` classes everywhere, which allows the framework to define default functionality but also provides an easy mechanism for developers to override and customize.  \n\nThis is implemented by declaring a `Meta` class, under your application and/or other Cement Handler classes.  \n\nEx: Defining Meta Classes\n\n```python\nfrom cement import App\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        extensions = ['json']\n```\n\n\nAll Meta-options can also be overridden by any `**kwargs` that are passed to the parent class that is being instantiated. \n\nEx: Passing meta options via `**kwargs`:\n\n```python\nApp('myapp', config_defaults={'foo': 'bar'})\n```\n\nNearly every Cement class has an associated `Meta` class, which we often refer to as `App.Meta`, `SomeHandlerClass.Meta`, etc.  The instantiated object is refered to in code as `app._meta`, `some_handler._meta`, etc.\n\nEx: Sub-classing Cement App / Overriding Metadata Options:\n\n```python\nfrom cement import App, init_defaults\n\n# define default application configuration settings\ndefaults = init_defaults('myapp')\ndefaults['myapp']['foo'] = 'bar'\n\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        config_defaults = defaults\n\n\nwith MyApp() as app:\n    app.run()\n    print(\"Foo => %s\" % app.config.get('myapp', 'foo'))\n```\n\nCLI Usage\n\n```\n$ python myapp.py\nFoo => bar\n```\n\n\n## Interfaces and Handlers\n\n\nAll aspects of the framework are broken up into interfaces, and handlers. Interfaces define some functionality, and Handlers implement that functionality. Cement defines the following interfaces:\n\n- `extension` - Framework extensions loading\n- `log` - Logging to console/file\n- `config` - Application Configuration defaults, overrides by file, etc\n- `mail` - Mail sending (smtp, etc)\n- `plugin` - Application plugin loading\n- `output` - Output rendering (JSON, Yaml, Mustache Templates, etc)\n- `argument` - Command line argument parsing\n- `controller` - Command dispatch (sub-commands, sub-command arguments, etc)\n- `cache` - Key/Value data store (memcached, redis, etc)\n\nFor example, the builtin configuration handler `ConfigParserConfigHandler`, implements the `config` interface.  Handlers are referred to by the interfaces they implement, such as `config.configparser`, `config.json`, `config.yaml`, etc.\n\n<p class=\"tip\">Application developers can also define their own interfaces, allowing customization by plugins.</p>\n\n\nEx: Overriding Default Framework Handlers\n\n```python\nfrom cement import App\nfrom cement.ext.ext_configparser import ConfigParserConfigHandler\n\n\nclass MyConfigHandler(ConfigParserConfigHandler):\n    class Meta:\n        label = 'my_config_handler'\n\n    # do something to subclass/re-implement \n    # config handler here...\n\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        config_handler = 'my_config_handler'\n        handlers = [\n            MyConfigHandler\n        ]\n```\n\n\n**Overriding Via Configuration Files**\n\n`MyApp` defines and/or defaults to builtin handlers for all of the above listed core handlers.  Whatever the application code defines is the default,  however you can also override via the configuration file(s) as in the example to the right.  \n\nFor example, imagine that your default `mail_handler` is `smtp` for sending email via your local SMTP server.  This is a configuration that might very on a per-user/environment basis.  Via the application configuration, you could override this with an alternative mail handler like `mail_handler=some_other_mail_handler`\n\n\nEx: Overriding Via Configuration File\n\n```\n[myapp]\n\n### override App.Meta.mail_handler \nmail_handler = my_mail_handler\n\n```\n\n\n## Configuration\n\nCement supports loading multiple configuration files out-of-the-box. Configurations loaded from files are merged in, overriding the applications default settings (`App.Meta.config_defaults`).  The default configuration handler is `ConfigParserConfigHandler`, based on [ConfigParser](https://docs.python.org/3/library/configparser.html) in the standard library, and is instantiated as `app.config`.\n\nCement looks for configuration files in the most common places such as:\n\n- `/etc/myapp/myapp.conf`\n- `~/.myapp.conf`\n- `~/.myapp/config`\n- etc \n\nThe list of configuration file paths can be customized via the meta option `App.Meta.config_files` as well as their extension (i.e. `.conf`) can also be easily modified with `App.Meta.config_extension`.\n\nThe builtin configuration handler `ConfigParserConfigHandler` uses common unix-like config files where `blocks` or `sections` are defined with brackets; `[myapp]`, `[plugin.myplugin]`, `[interface.handler]`, etc.\n\nAdditional support for the following file formats is provided via optional extensions:\n\n- Json\n- Yaml\n\n<p class=\"tip\">Config handler's provide dropin replacements for the default `ConfigParserConfigHandler`, and are often based on it.  For example, the `JsonConfigHandler` and `YamlConfigHandler` hanlers do nothing more than support reading alternative file formats.  Accessing the config settings in the app is exactly the same.</p>\n\nAll extensions and application plugins can support customization loaded from the application configuration file under the section `[interface.handler]`. For example, the `ColorLogHandler` extension reads it's configuration from `[log.colorlog]`.\n\nEx: Application Configuration Settings\n\n```python\nfrom cement import App, init_defaults\n\ndefaults = init_defaults('myapp')\ndefaults['myapp']['foo'] = 'bar'\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        config_defaults = defaults\n\nwith MyApp() as app:\n    app.run()\n    print(\"Foo => %s\" % app.config.get('myapp', 'foo'))\n```\n\nConfiguration (`~/.myapp.conf`):\n\n```\n[myapp]\nfoo = not-bar\n```\n\nCLI Usage:\n\n```\n$ python myapp.py\nFoo => not-bar\n```\n\n**Alternative Configuration Handler Example**\n\nThe follow is an example of overriding the default config handler with an alternative, drop-in replacement `YamlConfighandler`:\n\nEx: Alternative Configuration Handler (Yaml):\n\n```python\nfrom cement import App\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        extensions = ['yaml']\n        config_handler = 'yaml'\n        config_extension = '.yml'\n```\n\nConfiguration (`~/.myapp.yml`):\n\n```yaml\nmyapp:\n    foo: not-bar\n```\n\n\n## Arguments\n\nArgument parsing is based on the standard [Argparse](https://docs.python.org/3/library/argparse.html) library, with the same usage that you're familiar with.  The argument handler `ArgparseArgumentHandler` is instantiated as `app.args`, arguments are defined with `app.args.add_argument()`, and parsed arguments are stored as `app.args.parsed_args` (or more conveniently `app.pargs` for easy reference).\n\n\nEx: Simple Arguments Defined With Cement App\n\n```python\n\nfrom cement import App\n\nwith App('myapp') as app:\n    app.args.add_argument('-f', '--foo', \n                          help='notorous foo option', \n                          dest='foo')\n    app.run()\n\n    # do something with parsed arguments\n    if app.pargs.foo is not None:\n        print(\"Foo Argument => %s\" % app.pargs.foo)\n\n```\n\nCLI Usage:\n\n```\n$ python myapp.py --help\nusage: myapp [-h] [--debug] [--quiet] [-f FOO]\n\noptional arguments:\n  -h, --help         show this help message and exit\n  --debug            toggle debug output\n  --quiet            suppress all output\n  -f FOO, --foo FOO  notorous foo option\n\n$ python myapp.py -f bar\nFoo Argument => bar\n```\n\n\n\n**Arguments Defined by Controllers**\n\nThe power of the framework comes into play when we start talking about application controllers that streamline the process of mapping arguments and sub-commands to actions/functions as in the example (more on that later).\n\nEx: Arguments Defined by Controllers\n\n```python\n\nfrom cement import App, Controller, ex\n\n\nclass Base(Controller):\n    class Meta:\n        label = 'base'\n\n        arguments = [\n            # list of tuples in the format `( [], {} )`\n            ( [ '-f', '--foo' ],\n              { 'help' : 'notorious foo option',\n                'dest' : 'foo' } ),\n        ]\n\n    @ex(hide=True)\n    def _default(self):\n        print('Inside BaseController._default()')\n\n        # do something with parsed arguments\n        if self.app.pargs.foo is not None:\n            print(\"Foo Argument => %s\" % self.app.pargs.foo)\n\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        handlers = [Base]\n\n\nwith MyApp() as app:\n    app.run()\n\n```\n\nCLI Usage:\n\n```\n$ python myapp.py --help\nusage: myapp [-h] [--debug] [--quiet] [-f FOO]\n\noptional arguments:\n  -h, --help         show this help message and exit\n  --debug            toggle debug output\n  --quiet            suppress all output\n  -f FOO, --foo FOO  notorous foo option\n\n$ python myapp.py -f bar\nFoo Argument => bar\n```\n\n\n## Logging\n\nLogging is based on the standard [Logging](https://docs.python.org/3/library/logging.html) library, with the same usage you're familiar with.  The logging facility is customizable via the `[log.logging]` section of an applications configuration:\n\n\n- `level` - The level at which to start logging (`INFO`, `WARNING`, `ERROR`,\n  `FATAL`, `DEBUG`, etc).\n- `file` (*path*) - File path to log to.\n- `to_console` (*bool*) - Whether or not to log to console.\n- `rotate` (*bool*) - Whether or not to rotate the log file when it hits \n  `max_bytes`\n- `max_bytes` (*int*) - Maximum file size in bytes before file gets rotated\n- `max_files` (*int*) - Maximum number of log files to keep after rotating\n\n\nCement also includes the following optional extensions that provide drop-in replacements for the default log handler:\n\n- `ColorlogHandler` - Provides colorized log output via the [Colorlog](https://github.com/borntyping/python-colorlog) library.\n\n\nEx: Logging Example\n\n```python\n\nfrom cement import App\n\nwith App('myapp') as app:\n    app.run()\n\n    # log messages to console and file\n    app.log.info('this is an info message')\n    app.log.warning('this is an warning message')\n    app.log.error('this is an error message')\n    app.log.fatal('this is an fatal message')\n    app.log.debug('this is an debug message')\n    \n\n```\n\nEx: Logging Configuration Example\n\n```\n[myapp]\nlog_handler = logging\n\n[log.logging]\nto_console = true\nfile = /path/to/myapp.log\nlevel = warning\n```\n\nCLI Usage:\n\n```\n$ python myapp.py\nINFO: this is an info message\nWARNING: this is an warning message\nERROR: this is an error message\nCRITICAL: this is an fatal message\n```\n\n## Output\n\nBy default, Cement does not define any output handlers.  Just like any other app, you are free to `print()` to console all you like or use the builtin  logging facility.  That said, more complex applications will benefit greatly by separating the output from the logic.  Think of output handling as the `view` in a traditional [MVC Framework](https://en.wikipedia.org/wiki/Model-view-controller).\n\nCement ships with several types of extensions that produce output in different forms, including the following:\n\n- Text Rendered From Template Files\n- Programatic Structures (JSON, Yaml, etc)\n- Tabulated (like MySQL, etc)\n- Etc\n\nThe following output handlers ship with Cement:\n\n- `Json` - Produces JSON output from dicts\n- `Yaml` - Produces Yaml output from dicts\n- `Mustache` - Produces text output rendered from [Mustache](http://mustache.github.io/) templates\n- `Handlebars` - Produces text output rendered from [Handlebars](https://github.com/wbond/pybars3) templates\n- `Jinja2` - Produces text output rendered from [Jinja2](http://jinja.pocoo.org/) templates\n- `Tabulated` - Produces tabulated text output rendered via the [Tabulate](https://pypi.python.org/pypi/tabulate) library.\n\n\nEx: Standard Output via Print Statements\n\n```python\nfrom cement import App\n\nwith App('myapp') as app:\n    print('About Run MyApp!')\n    app.run()\n```\n\n\n**Multiple Output Handler Support**\n\nOne of the unique features of Cement is that you can build your application to support multiple output handlers and formats.  Output handlers have a special attribute that allows them to be exposed via the CLI option `-o` (configurable via `App.Meta.core_handler_override_options`).  Therefore, you might have default text based output rendered from Mustache templates, but optionally output programatic structures *from the same dict* when necessary (i.e.`$ myapp -o json`).\n\n\nEx: Mixed Template/JSON Output Example\n\n```python\nfrom cement import App\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n\n        ### add optional extensions\n        extensions = ['json', 'mustache']\n\n        ### set the default output handler\n        output_handler = 'mustache'\n\n        ### external template directory\n        template_dir = '/path/to/templates'\n\n        ### internal template module (shipped with app code)\n        template_module = 'myapp.templates'\n\n\nwith MyApp() as app:\n    app.run()\n\n    ### create some data\n    data = {\n        'foo' : 'bar',\n    }\n\n    ### render data using mustache template (by default)\n    app.render(data, 'example.m')\n\n```\n\n\nEx: Mustache Template: /path/to/templates/example.m\n\n```\nThe value of foo={{foo}}.\n```\n\n\nCLI Usage:\n\n```\n$ python myapp.py --help\nusage: myapp [-h] [--debug] [--quiet] [-o {json}]\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n  -o {json}   output handler\n\n\n$ python myapp.py\nThe value of foo=bar\n\n\n$ python myapp.py -o json\n{\"foo\": \"bar\"}\n```\n\n\n[comment]: <> (--------------------------------------------------------------)\n\n## Controllers\n\nControllers provide a common means of organizing application logic into relevant chunks of code, as well as the ability for plugins and extensions to extend an applications capabilities. It is the `Controller` piece of the traditional  [MVC Framework](https://en.wikipedia.org/wiki/Model-view-controller).\n\nThe first controller is called `base`, and if registered will take over runtime control when `app.run()` is called.  What this means is, instead of Cement calling `app.args.parse_arguments()` directly, the application dispatch is handed over to the `base` controller, that is then responsible for parsing and handling arguments.  This is what we call `Runtime Dispatch`.\n\nThe most notable action of `Runtime Dispatch` is mapping arguments and sub-commands to their respective controllers and functions.  For example, the default action when running `$ myapp` without any arguments or sub-commands is to execute the `BaseController._default()` function.\n\nEx: Application Base Controller\n\n```python\nfrom cement import App, Controller, ex\n\n\nclass Base(Controller):\n    class Meta:\n        label = 'base'\n\n        arguments = [\n            # list of tuples in the format `( [], {} )`\n            ( [ '-a' ],\n              { 'help' : 'example a option',\n                'dest' : 'a' } ),\n        ]\n\n    def _default(self):\n        print('Inside Base._default()')\n        if self.app.pargs.a:\n            print('Received Option: -a')\n\n    @ex(\n        help='sub-command under base controller',\n        arguments=[\n            ( [ '-b' ],\n              { 'help' : 'cmd1 b option' } ),\n        ]\n    )\n    def cmd1(self):\n        print('Inside Base.cmd1()')\n        if self.app.pargs.b:\n            print('Recieved Option: -b')\n\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        handlers = [\n            Base,\n        ]\n\n\nwith MyApp() as app:\n    app.run()\n```\n\nCLI Usage:\n\n```bash\n### help output shows base namespace arguments and sub-commands\n\n$ python myapp.py --help\nusage: myapp [-h] [--debug] [--quiet] [-a A] {cmd1} ...\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n  -a A        example a option\n\nsub-commands:\n  {cmd1}\n    cmd1      sub-command under base controller\n\n\n$ python myapp.py -a foo\nInside Base._default()\nReceived Option: -a\n\n\n### sub-commands support their own arguments\n\n$ python myapp.py cmd1 --help\nusage: myapp cmd1 [-h] [-b B]\n\noptional arguments:\n  -h, --help  show this help message and exit\n  -b B        cmd1 b option\n\n\n$ python myapp.py cmd1 -b foo\nInside Base.cmd1()\nRecieved Option: -b\n```\n\n**Nested / Embedded Controllers**\n\nCement supports two types of controller `stacking`:\n\n- `nested` - The arguments and commands are nested under a sub-parser whose label is that of the controller.  For example, a nested controller with a label of `my-nested-controller` would be called as `$ myapp my-nested-controller sub-command`.\n- `embedded` - The arguments and commands are embedded within it's parent controller, therefore appearing as if they were defined by the parent itself.  A sub-command under an embedded controller would be called as `$ myapp sub-command`.\n\n\nControllers can be stacked on other controllers as many levels deep as necessary.  An `embedded` controller can be stacked on top of a `nested` controller, and vice versa.  There is little, if any, limitation.\n\n\n**Controller Arguments vs Command Arguments**\n\nBoth Controllers and their sub-commands can have arguments defined.  Think of controllers as the primary namespace.  It's arguments should be globally relevant within that namespace.  A sub-command within the namespace can have it's own arguments, but are only relevant to that sub-command.\n\nI.e. `$ myapp -a my-controller -b my-sub-command -c`\n\nIn the above example, `-a` is relevant to the global scope of the entire application because it is defined on the `base` controller.  Option `-b` is relevant to the scope of `my-controller` and all sub-commands under it. Finally, `-c` is only relevant to the `my-sub-command` and has no use elsewhere.\n\n\n**Exposing Sub-Commands**\n\nBy default, no commands are exposed to the CLI except that a `_default()` function will be called if no sub-command is passed (configurable by `Controller.Meta.default_func`).\n\nTo expose a function as a sub-command, you must decorate it with `@ex()`. It's usage is simple, and supports the following parameters:\n\n- `hide` (*bool*) - Whether or not to display in `--help` output.\n- `arguments` (*list*) - Argument list of tuples in the format `( [], {} )`, that are passed to `Argparse.add_argument(*args, **kwargs)`.\n- `**kwargs` - Additional keyword arguments are passed directly to Argparse when creating the sub-parser for this command.\n\n\n<p class='tip'>Why `ex`?  Well, `ex` is short for `expose`, and just so happens that `@ex(` is exactly `4` characters, making it lineup perfectly with indented parameters.  It makes things more readable, more-better.</p>\n\n\n\n## Framework Extensions\n\nCement's Interfaces and Handlers system makes extending the framework easy, and limitless.  Cement ships dozens of extensions that either alter existing funtionality, or add to it.  For example, the default logging facility provides basic logging capabilities, however with a single line of code an application can instead use the `colorlog` extension to enable colorized console logging.  \n\nThe example provides a quick look at using the `alarm` extension to handle application timeouts of long running operations\n\nEx: Using Framework Extensions:\n\n```python\nfrom time import sleep\nfrom cement import App\n\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        extensions = [\n            'alarm',\n        ]\n\n\nwith MyApp() as app:\n    app.run()\n\n    ### set an alarm based on the max allowed run time\n    app.alarm.set(3, \"The operation timed out after 3 seconds!\")\n\n    ### do something that takes time to operate\n    sleep(5)\n\n    ### stop the alarm if it ran within the time frame\n    app.alarm.stop()\n```\n\nCLI Usage:\n\n```bash\n$ python myapp.py\nERROR: The operation timed out after 3 seconds!\nTraceback (most recent call last):\n  File \"myapp.py\", line 20, in <module>\n    sleep(5)\n  File \"cement/core/foundation.py\", line 123, in cement_signal_handler\n    raise exc.CaughtSignal(signum, frame)\ncement.core.exc.CaughtSignal: Caught signal 14\n```\n\n\n**Included Extensions**\n\nCement includes (but is not limited to) the following extensions:\n\n- `alarm` - Provides easy access to setting an application alarm to handle timing out operations\n- `argparse` - Provides `ArgparseArgumentHandler` and `ArgparseController` handlers built on Argparse\n- `colorlog` - Provides `ColorLogHandler` that produces colorized console logging\n- `configparser` - Provides `ConfigParserConfigHandler` handler for application configuration built on on ConfigParser\n- `daemon` - Provides daemonization, pidfile management, user/group context switching, etc\n- `handlebars` - Provides `HandlebarsOutputHandler` to render text output from Handlerbars templates\n- `jinja2` - Provides `Jinja2OutputHandler` to render text output from Jinja2 templates\n- `json` - Provides `JsonConfigHandler` and `JsonOutputHandler` to read JSON configuration files, and produce JSON structured output.\n- `logging` - Provides `LoggingLogHandler` for standard application logging\n- `memcached` - Providers `MemcachedCacheHandler` for caching built on Memcached\n- `mustache` - Provides `MustacheOutputHandler` to render text output from Mustache templates\n- `plugin` - Provides `CementPluginHandler` for application plugin support\n- `redis` - Provides `RedisCacheHandler` for caching built on Redis\n- `smtp` - Provides `SMTPMailHandler` for email messaging\n- `tabulate` - Provides `TabulateOutputHandler` for text output tabularized like MySQL, etc\n- `watchdog` - Provides cross-platform directory/file monitoring in order to handle filesystem events as they occur.\n- `yaml` - Providers `YamlConfigHandler` and `YamlOutputHandler` to read Yaml configuration files, and produce Yaml structured output.\n\n\n## Application Plugins\n\nCement provides an interface that automatically handles the management, configuration, and loading of Application Plugins.  A Plugin is essentially the same as a Framework Extension, but is application specific where extensions are agnostic (can be used by any application).  \n\nA plugin can be anything, and provide any kind of functionality from defining runtime hooks, to extending an applications capabilities by adding nested/embedded controllers.  the only thing that a plugin must provide is a `load()` function that is called when the plugin is imported.\n\nEx: Basic Application\n\n```python\nfrom cement import App, Controller, ex\n\n\nclass Base(Controller):\n    class Meta:\n        label = 'base'\n\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        handlers = [\n            Base,\n        ]\n\n\nwith MyApp() as app:\n    app.run()\n```\n\nCLI Usage (without plugin enabled):\n\n```\n$ python test.py --help\nusage: myapp [-h] [--debug] [--quiet] {} ...\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n\nsub-commands:\n  {}\n```\n\nEx: Plugin\n\n```python\nfrom cement import Controller, ex\n\n\nclass MyPlugin(Controller):\n    class Meta:\n        label = 'myplugin'\n        stacked_on = 'base'\n        stacked_type = 'embedded'\n\n    @ex()\n    def cmd1(self):\n        print('Inside MyPlugin.cmd1()')\n\n\ndef load(app):\n    app.handler.register(MyPlugin)\n\n```\n\nConfiguration (`~/.myapp.conf`):\n\n```\n[myapp]\nplugin_dir = /path/to/myapp/plugins\n\n[plugin.myplugin]\nenabled = true\n```\n\nCLI Usage:\n\n```\n$ python myapp.py --help\nusage: myapp [-h] [--debug] [--quiet] {cmd1} ...\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n\nsub-commands:\n  {cmd1}\n\n\n$ python myapp.py cmd1\nInside MyPlugin.cmd1()\n```\n\n\n\n## Hooks\n\nHooks provide developers the ability to tie into the framework, and applications without direct access to the runtime.  For example, a plugin might need to execute some code after arguments have been parsed, but before controller sub-commands are dispatched.  As a plugin developer, you don't have direct access to the applications runtime code but you can still tie into it with the builtin `post_argument_parsing` hook.\n\nCement defines several hooks that tie in to specific points throughout the application life cycle, however application developers can also define their own hooks allowing others to tie elsewhere, when needed.\n\nEx: Executing Code Via Hooks\n\n```python\nfrom cement import App\n\n\ndef my_example_hook(app):\n    print('Inside my_example_hook()')\n\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        hooks = [\n            ('post_argument_parsing', my_example_hook),\n        ]\n\n\nwith MyApp() as app:\n    app.run()\n```\n\nCLI Usage:\n\n```bash\n$ python myapp.py\nInside my_example_hook()\n```\n\n","source":"portland/dev/overview.md","raw":"---\ntitle: Framework Overview\ntype: guide\nversion: \"portland\"\norder: 3\n---\n\nThis section is intended to give a brief overview of some of the most commonly used core features of Cement.  Please do not be discouraged if you don't \"get it\" right away.  Please also do not think, \"is this it?\".  This is not intended to be an exhaustive end-all-be-all coverage of every feature of the framework.\n\nSome assumptions are being made here.  Primarily, we assume that you've used and are familiar with Python.  The overview is intended to give a high level look at using Cement.  Please dive deeper into the individual sections after the overview in order to gain a better understanding of each component.\n\n\n## The Application Object\n\nThe core of your application starts with the Cement `App` object, which we will refer to throughout this documentation in several ways:\n\n- `App` - The uninstantiated Cement `App` base class\n- `MyApp` - The uninstatiated/sub-classed Cement application you are creating\n- `app` - The instantiated application object\n\n\nTechnically, Cement `App` can be used direcly (as in the example), however in practice you will almost always sub-class `App` in order to configure it for your needs (I.e. `MyApp`).\n\n\nUsing Cement App Directly:\n\n```python\nfrom cement import App\n\nwith App('myapp') as app:\n    app.run()\n```\n\nSub-classing Cement App:\n\n```python\nfrom cement import App\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n\nwith MyApp() as app:\n    app.run()\n```\n\nCLI Usage:\n\n```bash\n$ python myapp.py --help\nusage: myapp [-h] [--debug] [--quiet]\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n```\n\n\n## MetaMixin\n\nCement uses `MetaMixin` classes everywhere, which allows the framework to define default functionality but also provides an easy mechanism for developers to override and customize.  \n\nThis is implemented by declaring a `Meta` class, under your application and/or other Cement Handler classes.  \n\nEx: Defining Meta Classes\n\n```python\nfrom cement import App\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        extensions = ['json']\n```\n\n\nAll Meta-options can also be overridden by any `**kwargs` that are passed to the parent class that is being instantiated. \n\nEx: Passing meta options via `**kwargs`:\n\n```python\nApp('myapp', config_defaults={'foo': 'bar'})\n```\n\nNearly every Cement class has an associated `Meta` class, which we often refer to as `App.Meta`, `SomeHandlerClass.Meta`, etc.  The instantiated object is refered to in code as `app._meta`, `some_handler._meta`, etc.\n\nEx: Sub-classing Cement App / Overriding Metadata Options:\n\n```python\nfrom cement import App, init_defaults\n\n# define default application configuration settings\ndefaults = init_defaults('myapp')\ndefaults['myapp']['foo'] = 'bar'\n\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        config_defaults = defaults\n\n\nwith MyApp() as app:\n    app.run()\n    print(\"Foo => %s\" % app.config.get('myapp', 'foo'))\n```\n\nCLI Usage\n\n```\n$ python myapp.py\nFoo => bar\n```\n\n\n## Interfaces and Handlers\n\n\nAll aspects of the framework are broken up into interfaces, and handlers. Interfaces define some functionality, and Handlers implement that functionality. Cement defines the following interfaces:\n\n- `extension` - Framework extensions loading\n- `log` - Logging to console/file\n- `config` - Application Configuration defaults, overrides by file, etc\n- `mail` - Mail sending (smtp, etc)\n- `plugin` - Application plugin loading\n- `output` - Output rendering (JSON, Yaml, Mustache Templates, etc)\n- `argument` - Command line argument parsing\n- `controller` - Command dispatch (sub-commands, sub-command arguments, etc)\n- `cache` - Key/Value data store (memcached, redis, etc)\n\nFor example, the builtin configuration handler `ConfigParserConfigHandler`, implements the `config` interface.  Handlers are referred to by the interfaces they implement, such as `config.configparser`, `config.json`, `config.yaml`, etc.\n\n<p class=\"tip\">Application developers can also define their own interfaces, allowing customization by plugins.</p>\n\n\nEx: Overriding Default Framework Handlers\n\n```python\nfrom cement import App\nfrom cement.ext.ext_configparser import ConfigParserConfigHandler\n\n\nclass MyConfigHandler(ConfigParserConfigHandler):\n    class Meta:\n        label = 'my_config_handler'\n\n    # do something to subclass/re-implement \n    # config handler here...\n\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        config_handler = 'my_config_handler'\n        handlers = [\n            MyConfigHandler\n        ]\n```\n\n\n**Overriding Via Configuration Files**\n\n`MyApp` defines and/or defaults to builtin handlers for all of the above listed core handlers.  Whatever the application code defines is the default,  however you can also override via the configuration file(s) as in the example to the right.  \n\nFor example, imagine that your default `mail_handler` is `smtp` for sending email via your local SMTP server.  This is a configuration that might very on a per-user/environment basis.  Via the application configuration, you could override this with an alternative mail handler like `mail_handler=some_other_mail_handler`\n\n\nEx: Overriding Via Configuration File\n\n```\n[myapp]\n\n### override App.Meta.mail_handler \nmail_handler = my_mail_handler\n\n```\n\n\n## Configuration\n\nCement supports loading multiple configuration files out-of-the-box. Configurations loaded from files are merged in, overriding the applications default settings (`App.Meta.config_defaults`).  The default configuration handler is `ConfigParserConfigHandler`, based on [ConfigParser](https://docs.python.org/3/library/configparser.html) in the standard library, and is instantiated as `app.config`.\n\nCement looks for configuration files in the most common places such as:\n\n- `/etc/myapp/myapp.conf`\n- `~/.myapp.conf`\n- `~/.myapp/config`\n- etc \n\nThe list of configuration file paths can be customized via the meta option `App.Meta.config_files` as well as their extension (i.e. `.conf`) can also be easily modified with `App.Meta.config_extension`.\n\nThe builtin configuration handler `ConfigParserConfigHandler` uses common unix-like config files where `blocks` or `sections` are defined with brackets; `[myapp]`, `[plugin.myplugin]`, `[interface.handler]`, etc.\n\nAdditional support for the following file formats is provided via optional extensions:\n\n- Json\n- Yaml\n\n<p class=\"tip\">Config handler's provide dropin replacements for the default `ConfigParserConfigHandler`, and are often based on it.  For example, the `JsonConfigHandler` and `YamlConfigHandler` hanlers do nothing more than support reading alternative file formats.  Accessing the config settings in the app is exactly the same.</p>\n\nAll extensions and application plugins can support customization loaded from the application configuration file under the section `[interface.handler]`. For example, the `ColorLogHandler` extension reads it's configuration from `[log.colorlog]`.\n\nEx: Application Configuration Settings\n\n```python\nfrom cement import App, init_defaults\n\ndefaults = init_defaults('myapp')\ndefaults['myapp']['foo'] = 'bar'\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        config_defaults = defaults\n\nwith MyApp() as app:\n    app.run()\n    print(\"Foo => %s\" % app.config.get('myapp', 'foo'))\n```\n\nConfiguration (`~/.myapp.conf`):\n\n```\n[myapp]\nfoo = not-bar\n```\n\nCLI Usage:\n\n```\n$ python myapp.py\nFoo => not-bar\n```\n\n**Alternative Configuration Handler Example**\n\nThe follow is an example of overriding the default config handler with an alternative, drop-in replacement `YamlConfighandler`:\n\nEx: Alternative Configuration Handler (Yaml):\n\n```python\nfrom cement import App\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        extensions = ['yaml']\n        config_handler = 'yaml'\n        config_extension = '.yml'\n```\n\nConfiguration (`~/.myapp.yml`):\n\n```yaml\nmyapp:\n    foo: not-bar\n```\n\n\n## Arguments\n\nArgument parsing is based on the standard [Argparse](https://docs.python.org/3/library/argparse.html) library, with the same usage that you're familiar with.  The argument handler `ArgparseArgumentHandler` is instantiated as `app.args`, arguments are defined with `app.args.add_argument()`, and parsed arguments are stored as `app.args.parsed_args` (or more conveniently `app.pargs` for easy reference).\n\n\nEx: Simple Arguments Defined With Cement App\n\n```python\n\nfrom cement import App\n\nwith App('myapp') as app:\n    app.args.add_argument('-f', '--foo', \n                          help='notorous foo option', \n                          dest='foo')\n    app.run()\n\n    # do something with parsed arguments\n    if app.pargs.foo is not None:\n        print(\"Foo Argument => %s\" % app.pargs.foo)\n\n```\n\nCLI Usage:\n\n```\n$ python myapp.py --help\nusage: myapp [-h] [--debug] [--quiet] [-f FOO]\n\noptional arguments:\n  -h, --help         show this help message and exit\n  --debug            toggle debug output\n  --quiet            suppress all output\n  -f FOO, --foo FOO  notorous foo option\n\n$ python myapp.py -f bar\nFoo Argument => bar\n```\n\n\n\n**Arguments Defined by Controllers**\n\nThe power of the framework comes into play when we start talking about application controllers that streamline the process of mapping arguments and sub-commands to actions/functions as in the example (more on that later).\n\nEx: Arguments Defined by Controllers\n\n```python\n\nfrom cement import App, Controller, ex\n\n\nclass Base(Controller):\n    class Meta:\n        label = 'base'\n\n        arguments = [\n            # list of tuples in the format `( [], {} )`\n            ( [ '-f', '--foo' ],\n              { 'help' : 'notorious foo option',\n                'dest' : 'foo' } ),\n        ]\n\n    @ex(hide=True)\n    def _default(self):\n        print('Inside BaseController._default()')\n\n        # do something with parsed arguments\n        if self.app.pargs.foo is not None:\n            print(\"Foo Argument => %s\" % self.app.pargs.foo)\n\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        handlers = [Base]\n\n\nwith MyApp() as app:\n    app.run()\n\n```\n\nCLI Usage:\n\n```\n$ python myapp.py --help\nusage: myapp [-h] [--debug] [--quiet] [-f FOO]\n\noptional arguments:\n  -h, --help         show this help message and exit\n  --debug            toggle debug output\n  --quiet            suppress all output\n  -f FOO, --foo FOO  notorous foo option\n\n$ python myapp.py -f bar\nFoo Argument => bar\n```\n\n\n## Logging\n\nLogging is based on the standard [Logging](https://docs.python.org/3/library/logging.html) library, with the same usage you're familiar with.  The logging facility is customizable via the `[log.logging]` section of an applications configuration:\n\n\n- `level` - The level at which to start logging (`INFO`, `WARNING`, `ERROR`,\n  `FATAL`, `DEBUG`, etc).\n- `file` (*path*) - File path to log to.\n- `to_console` (*bool*) - Whether or not to log to console.\n- `rotate` (*bool*) - Whether or not to rotate the log file when it hits \n  `max_bytes`\n- `max_bytes` (*int*) - Maximum file size in bytes before file gets rotated\n- `max_files` (*int*) - Maximum number of log files to keep after rotating\n\n\nCement also includes the following optional extensions that provide drop-in replacements for the default log handler:\n\n- `ColorlogHandler` - Provides colorized log output via the [Colorlog](https://github.com/borntyping/python-colorlog) library.\n\n\nEx: Logging Example\n\n```python\n\nfrom cement import App\n\nwith App('myapp') as app:\n    app.run()\n\n    # log messages to console and file\n    app.log.info('this is an info message')\n    app.log.warning('this is an warning message')\n    app.log.error('this is an error message')\n    app.log.fatal('this is an fatal message')\n    app.log.debug('this is an debug message')\n    \n\n```\n\nEx: Logging Configuration Example\n\n```\n[myapp]\nlog_handler = logging\n\n[log.logging]\nto_console = true\nfile = /path/to/myapp.log\nlevel = warning\n```\n\nCLI Usage:\n\n```\n$ python myapp.py\nINFO: this is an info message\nWARNING: this is an warning message\nERROR: this is an error message\nCRITICAL: this is an fatal message\n```\n\n## Output\n\nBy default, Cement does not define any output handlers.  Just like any other app, you are free to `print()` to console all you like or use the builtin  logging facility.  That said, more complex applications will benefit greatly by separating the output from the logic.  Think of output handling as the `view` in a traditional [MVC Framework](https://en.wikipedia.org/wiki/Model-view-controller).\n\nCement ships with several types of extensions that produce output in different forms, including the following:\n\n- Text Rendered From Template Files\n- Programatic Structures (JSON, Yaml, etc)\n- Tabulated (like MySQL, etc)\n- Etc\n\nThe following output handlers ship with Cement:\n\n- `Json` - Produces JSON output from dicts\n- `Yaml` - Produces Yaml output from dicts\n- `Mustache` - Produces text output rendered from [Mustache](http://mustache.github.io/) templates\n- `Handlebars` - Produces text output rendered from [Handlebars](https://github.com/wbond/pybars3) templates\n- `Jinja2` - Produces text output rendered from [Jinja2](http://jinja.pocoo.org/) templates\n- `Tabulated` - Produces tabulated text output rendered via the [Tabulate](https://pypi.python.org/pypi/tabulate) library.\n\n\nEx: Standard Output via Print Statements\n\n```python\nfrom cement import App\n\nwith App('myapp') as app:\n    print('About Run MyApp!')\n    app.run()\n```\n\n\n**Multiple Output Handler Support**\n\nOne of the unique features of Cement is that you can build your application to support multiple output handlers and formats.  Output handlers have a special attribute that allows them to be exposed via the CLI option `-o` (configurable via `App.Meta.core_handler_override_options`).  Therefore, you might have default text based output rendered from Mustache templates, but optionally output programatic structures *from the same dict* when necessary (i.e.`$ myapp -o json`).\n\n\nEx: Mixed Template/JSON Output Example\n\n```python\nfrom cement import App\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n\n        ### add optional extensions\n        extensions = ['json', 'mustache']\n\n        ### set the default output handler\n        output_handler = 'mustache'\n\n        ### external template directory\n        template_dir = '/path/to/templates'\n\n        ### internal template module (shipped with app code)\n        template_module = 'myapp.templates'\n\n\nwith MyApp() as app:\n    app.run()\n\n    ### create some data\n    data = {\n        'foo' : 'bar',\n    }\n\n    ### render data using mustache template (by default)\n    app.render(data, 'example.m')\n\n```\n\n\nEx: Mustache Template: /path/to/templates/example.m\n\n```\nThe value of foo={{foo}}.\n```\n\n\nCLI Usage:\n\n```\n$ python myapp.py --help\nusage: myapp [-h] [--debug] [--quiet] [-o {json}]\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n  -o {json}   output handler\n\n\n$ python myapp.py\nThe value of foo=bar\n\n\n$ python myapp.py -o json\n{\"foo\": \"bar\"}\n```\n\n\n[comment]: <> (--------------------------------------------------------------)\n\n## Controllers\n\nControllers provide a common means of organizing application logic into relevant chunks of code, as well as the ability for plugins and extensions to extend an applications capabilities. It is the `Controller` piece of the traditional  [MVC Framework](https://en.wikipedia.org/wiki/Model-view-controller).\n\nThe first controller is called `base`, and if registered will take over runtime control when `app.run()` is called.  What this means is, instead of Cement calling `app.args.parse_arguments()` directly, the application dispatch is handed over to the `base` controller, that is then responsible for parsing and handling arguments.  This is what we call `Runtime Dispatch`.\n\nThe most notable action of `Runtime Dispatch` is mapping arguments and sub-commands to their respective controllers and functions.  For example, the default action when running `$ myapp` without any arguments or sub-commands is to execute the `BaseController._default()` function.\n\nEx: Application Base Controller\n\n```python\nfrom cement import App, Controller, ex\n\n\nclass Base(Controller):\n    class Meta:\n        label = 'base'\n\n        arguments = [\n            # list of tuples in the format `( [], {} )`\n            ( [ '-a' ],\n              { 'help' : 'example a option',\n                'dest' : 'a' } ),\n        ]\n\n    def _default(self):\n        print('Inside Base._default()')\n        if self.app.pargs.a:\n            print('Received Option: -a')\n\n    @ex(\n        help='sub-command under base controller',\n        arguments=[\n            ( [ '-b' ],\n              { 'help' : 'cmd1 b option' } ),\n        ]\n    )\n    def cmd1(self):\n        print('Inside Base.cmd1()')\n        if self.app.pargs.b:\n            print('Recieved Option: -b')\n\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        handlers = [\n            Base,\n        ]\n\n\nwith MyApp() as app:\n    app.run()\n```\n\nCLI Usage:\n\n```bash\n### help output shows base namespace arguments and sub-commands\n\n$ python myapp.py --help\nusage: myapp [-h] [--debug] [--quiet] [-a A] {cmd1} ...\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n  -a A        example a option\n\nsub-commands:\n  {cmd1}\n    cmd1      sub-command under base controller\n\n\n$ python myapp.py -a foo\nInside Base._default()\nReceived Option: -a\n\n\n### sub-commands support their own arguments\n\n$ python myapp.py cmd1 --help\nusage: myapp cmd1 [-h] [-b B]\n\noptional arguments:\n  -h, --help  show this help message and exit\n  -b B        cmd1 b option\n\n\n$ python myapp.py cmd1 -b foo\nInside Base.cmd1()\nRecieved Option: -b\n```\n\n**Nested / Embedded Controllers**\n\nCement supports two types of controller `stacking`:\n\n- `nested` - The arguments and commands are nested under a sub-parser whose label is that of the controller.  For example, a nested controller with a label of `my-nested-controller` would be called as `$ myapp my-nested-controller sub-command`.\n- `embedded` - The arguments and commands are embedded within it's parent controller, therefore appearing as if they were defined by the parent itself.  A sub-command under an embedded controller would be called as `$ myapp sub-command`.\n\n\nControllers can be stacked on other controllers as many levels deep as necessary.  An `embedded` controller can be stacked on top of a `nested` controller, and vice versa.  There is little, if any, limitation.\n\n\n**Controller Arguments vs Command Arguments**\n\nBoth Controllers and their sub-commands can have arguments defined.  Think of controllers as the primary namespace.  It's arguments should be globally relevant within that namespace.  A sub-command within the namespace can have it's own arguments, but are only relevant to that sub-command.\n\nI.e. `$ myapp -a my-controller -b my-sub-command -c`\n\nIn the above example, `-a` is relevant to the global scope of the entire application because it is defined on the `base` controller.  Option `-b` is relevant to the scope of `my-controller` and all sub-commands under it. Finally, `-c` is only relevant to the `my-sub-command` and has no use elsewhere.\n\n\n**Exposing Sub-Commands**\n\nBy default, no commands are exposed to the CLI except that a `_default()` function will be called if no sub-command is passed (configurable by `Controller.Meta.default_func`).\n\nTo expose a function as a sub-command, you must decorate it with `@ex()`. It's usage is simple, and supports the following parameters:\n\n- `hide` (*bool*) - Whether or not to display in `--help` output.\n- `arguments` (*list*) - Argument list of tuples in the format `( [], {} )`, that are passed to `Argparse.add_argument(*args, **kwargs)`.\n- `**kwargs` - Additional keyword arguments are passed directly to Argparse when creating the sub-parser for this command.\n\n\n<p class='tip'>Why `ex`?  Well, `ex` is short for `expose`, and just so happens that `@ex(` is exactly `4` characters, making it lineup perfectly with indented parameters.  It makes things more readable, more-better.</p>\n\n\n\n## Framework Extensions\n\nCement's Interfaces and Handlers system makes extending the framework easy, and limitless.  Cement ships dozens of extensions that either alter existing funtionality, or add to it.  For example, the default logging facility provides basic logging capabilities, however with a single line of code an application can instead use the `colorlog` extension to enable colorized console logging.  \n\nThe example provides a quick look at using the `alarm` extension to handle application timeouts of long running operations\n\nEx: Using Framework Extensions:\n\n```python\nfrom time import sleep\nfrom cement import App\n\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        extensions = [\n            'alarm',\n        ]\n\n\nwith MyApp() as app:\n    app.run()\n\n    ### set an alarm based on the max allowed run time\n    app.alarm.set(3, \"The operation timed out after 3 seconds!\")\n\n    ### do something that takes time to operate\n    sleep(5)\n\n    ### stop the alarm if it ran within the time frame\n    app.alarm.stop()\n```\n\nCLI Usage:\n\n```bash\n$ python myapp.py\nERROR: The operation timed out after 3 seconds!\nTraceback (most recent call last):\n  File \"myapp.py\", line 20, in <module>\n    sleep(5)\n  File \"cement/core/foundation.py\", line 123, in cement_signal_handler\n    raise exc.CaughtSignal(signum, frame)\ncement.core.exc.CaughtSignal: Caught signal 14\n```\n\n\n**Included Extensions**\n\nCement includes (but is not limited to) the following extensions:\n\n- `alarm` - Provides easy access to setting an application alarm to handle timing out operations\n- `argparse` - Provides `ArgparseArgumentHandler` and `ArgparseController` handlers built on Argparse\n- `colorlog` - Provides `ColorLogHandler` that produces colorized console logging\n- `configparser` - Provides `ConfigParserConfigHandler` handler for application configuration built on on ConfigParser\n- `daemon` - Provides daemonization, pidfile management, user/group context switching, etc\n- `handlebars` - Provides `HandlebarsOutputHandler` to render text output from Handlerbars templates\n- `jinja2` - Provides `Jinja2OutputHandler` to render text output from Jinja2 templates\n- `json` - Provides `JsonConfigHandler` and `JsonOutputHandler` to read JSON configuration files, and produce JSON structured output.\n- `logging` - Provides `LoggingLogHandler` for standard application logging\n- `memcached` - Providers `MemcachedCacheHandler` for caching built on Memcached\n- `mustache` - Provides `MustacheOutputHandler` to render text output from Mustache templates\n- `plugin` - Provides `CementPluginHandler` for application plugin support\n- `redis` - Provides `RedisCacheHandler` for caching built on Redis\n- `smtp` - Provides `SMTPMailHandler` for email messaging\n- `tabulate` - Provides `TabulateOutputHandler` for text output tabularized like MySQL, etc\n- `watchdog` - Provides cross-platform directory/file monitoring in order to handle filesystem events as they occur.\n- `yaml` - Providers `YamlConfigHandler` and `YamlOutputHandler` to read Yaml configuration files, and produce Yaml structured output.\n\n\n## Application Plugins\n\nCement provides an interface that automatically handles the management, configuration, and loading of Application Plugins.  A Plugin is essentially the same as a Framework Extension, but is application specific where extensions are agnostic (can be used by any application).  \n\nA plugin can be anything, and provide any kind of functionality from defining runtime hooks, to extending an applications capabilities by adding nested/embedded controllers.  the only thing that a plugin must provide is a `load()` function that is called when the plugin is imported.\n\nEx: Basic Application\n\n```python\nfrom cement import App, Controller, ex\n\n\nclass Base(Controller):\n    class Meta:\n        label = 'base'\n\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        handlers = [\n            Base,\n        ]\n\n\nwith MyApp() as app:\n    app.run()\n```\n\nCLI Usage (without plugin enabled):\n\n```\n$ python test.py --help\nusage: myapp [-h] [--debug] [--quiet] {} ...\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n\nsub-commands:\n  {}\n```\n\nEx: Plugin\n\n```python\nfrom cement import Controller, ex\n\n\nclass MyPlugin(Controller):\n    class Meta:\n        label = 'myplugin'\n        stacked_on = 'base'\n        stacked_type = 'embedded'\n\n    @ex()\n    def cmd1(self):\n        print('Inside MyPlugin.cmd1()')\n\n\ndef load(app):\n    app.handler.register(MyPlugin)\n\n```\n\nConfiguration (`~/.myapp.conf`):\n\n```\n[myapp]\nplugin_dir = /path/to/myapp/plugins\n\n[plugin.myplugin]\nenabled = true\n```\n\nCLI Usage:\n\n```\n$ python myapp.py --help\nusage: myapp [-h] [--debug] [--quiet] {cmd1} ...\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n\nsub-commands:\n  {cmd1}\n\n\n$ python myapp.py cmd1\nInside MyPlugin.cmd1()\n```\n\n\n\n## Hooks\n\nHooks provide developers the ability to tie into the framework, and applications without direct access to the runtime.  For example, a plugin might need to execute some code after arguments have been parsed, but before controller sub-commands are dispatched.  As a plugin developer, you don't have direct access to the applications runtime code but you can still tie into it with the builtin `post_argument_parsing` hook.\n\nCement defines several hooks that tie in to specific points throughout the application life cycle, however application developers can also define their own hooks allowing others to tie elsewhere, when needed.\n\nEx: Executing Code Via Hooks\n\n```python\nfrom cement import App\n\n\ndef my_example_hook(app):\n    print('Inside my_example_hook()')\n\n\nclass MyApp(App):\n    class Meta:\n        label = 'myapp'\n        hooks = [\n            ('post_argument_parsing', my_example_hook),\n        ]\n\n\nwith MyApp() as app:\n    app.run()\n```\n\nCLI Usage:\n\n```bash\n$ python myapp.py\nInside my_example_hook()\n```\n\n","date":"2017-06-24T23:08:02.000Z","updated":"2017-06-24T23:08:02.000Z","path":"portland/dev/overview.html","comments":1,"layout":"page","_id":"cj5dg8qst000ih6pwrktnrgbm","content":"<p>This section is intended to give a brief overview of some of the most commonly used core features of Cement.  Please do not be discouraged if you don’t “get it” right away.  Please also do not think, “is this it?”.  This is not intended to be an exhaustive end-all-be-all coverage of every feature of the framework.</p>\n<p>Some assumptions are being made here.  Primarily, we assume that you’ve used and are familiar with Python.  The overview is intended to give a high level look at using Cement.  Please dive deeper into the individual sections after the overview in order to gain a better understanding of each component.</p>\n<h2 id=\"The-Application-Object\"><a href=\"#The-Application-Object\" class=\"headerlink\" title=\"The Application Object\"></a>The Application Object</h2><p>The core of your application starts with the Cement <code>App</code> object, which we will refer to throughout this documentation in several ways:</p>\n<ul>\n<li><code>App</code> - The uninstantiated Cement <code>App</code> base class</li>\n<li><code>MyApp</code> - The uninstatiated/sub-classed Cement application you are creating</li>\n<li><code>app</code> - The instantiated application object</li>\n</ul>\n<p>Technically, Cement <code>App</code> can be used direcly (as in the example), however in practice you will almost always sub-class <code>App</code> in order to configure it for your needs (I.e. <code>MyApp</code>).</p>\n<p>Using Cement App Directly:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> App(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>Sub-classing Cement App:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --<span class=\"built_in\">help</span></div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --<span class=\"built_in\">help</span>  show this <span class=\"built_in\">help</span> message and <span class=\"built_in\">exit</span></div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div></pre></td></tr></table></figure>\n<h2 id=\"MetaMixin\"><a href=\"#MetaMixin\" class=\"headerlink\" title=\"MetaMixin\"></a>MetaMixin</h2><p>Cement uses <code>MetaMixin</code> classes everywhere, which allows the framework to define default functionality but also provides an easy mechanism for developers to override and customize.  </p>\n<p>This is implemented by declaring a <code>Meta</code> class, under your application and/or other Cement Handler classes.  </p>\n<p>Ex: Defining Meta Classes</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [<span class=\"string\">'json'</span>]</div></pre></td></tr></table></figure>\n<p>All Meta-options can also be overridden by any <code>**kwargs</code> that are passed to the parent class that is being instantiated. </p>\n<p>Ex: Passing meta options via <code>**kwargs</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">App(<span class=\"string\">'myapp'</span>, config_defaults=&#123;<span class=\"string\">'foo'</span>: <span class=\"string\">'bar'</span>&#125;)</div></pre></td></tr></table></figure>\n<p>Nearly every Cement class has an associated <code>Meta</code> class, which we often refer to as <code>App.Meta</code>, <code>SomeHandlerClass.Meta</code>, etc.  The instantiated object is refered to in code as <code>app._meta</code>, <code>some_handler._meta</code>, etc.</p>\n<p>Ex: Sub-classing Cement App / Overriding Metadata Options:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App, init_defaults</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># define default application configuration settings</span></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'myapp'</span>][<span class=\"string\">'foo'</span>] = <span class=\"string\">'bar'</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        config_defaults = defaults</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\">    print(<span class=\"string\">\"Foo =&gt; %s\"</span> % app.config.get(<span class=\"string\">'myapp'</span>, <span class=\"string\">'foo'</span>))</div></pre></td></tr></table></figure>\n<p>CLI Usage</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">Foo =&gt; bar</div></pre></td></tr></table></figure>\n<h2 id=\"Interfaces-and-Handlers\"><a href=\"#Interfaces-and-Handlers\" class=\"headerlink\" title=\"Interfaces and Handlers\"></a>Interfaces and Handlers</h2><p>All aspects of the framework are broken up into interfaces, and handlers. Interfaces define some functionality, and Handlers implement that functionality. Cement defines the following interfaces:</p>\n<ul>\n<li><code>extension</code> - Framework extensions loading</li>\n<li><code>log</code> - Logging to console/file</li>\n<li><code>config</code> - Application Configuration defaults, overrides by file, etc</li>\n<li><code>mail</code> - Mail sending (smtp, etc)</li>\n<li><code>plugin</code> - Application plugin loading</li>\n<li><code>output</code> - Output rendering (JSON, Yaml, Mustache Templates, etc)</li>\n<li><code>argument</code> - Command line argument parsing</li>\n<li><code>controller</code> - Command dispatch (sub-commands, sub-command arguments, etc)</li>\n<li><code>cache</code> - Key/Value data store (memcached, redis, etc)</li>\n</ul>\n<p>For example, the builtin configuration handler <code>ConfigParserConfigHandler</code>, implements the <code>config</code> interface.  Handlers are referred to by the interfaces they implement, such as <code>config.configparser</code>, <code>config.json</code>, <code>config.yaml</code>, etc.</p>\n<p class=\"tip\">Application developers can also define their own interfaces, allowing customization by plugins.</p>\n\n\n<p>Ex: Overriding Default Framework Handlers</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"><span class=\"keyword\">from</span> cement.ext.ext_configparser <span class=\"keyword\">import</span> ConfigParserConfigHandler</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfigHandler</span><span class=\"params\">(ConfigParserConfigHandler)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'my_config_handler'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># do something to subclass/re-implement </span></div><div class=\"line\">    <span class=\"comment\"># config handler here...</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        config_handler = <span class=\"string\">'my_config_handler'</span></div><div class=\"line\">        handlers = [</div><div class=\"line\">            MyConfigHandler</div><div class=\"line\">        ]</div></pre></td></tr></table></figure>\n<p><strong>Overriding Via Configuration Files</strong></p>\n<p><code>MyApp</code> defines and/or defaults to builtin handlers for all of the above listed core handlers.  Whatever the application code defines is the default,  however you can also override via the configuration file(s) as in the example to the right.  </p>\n<p>For example, imagine that your default <code>mail_handler</code> is <code>smtp</code> for sending email via your local SMTP server.  This is a configuration that might very on a per-user/environment basis.  Via the application configuration, you could override this with an alternative mail handler like <code>mail_handler=some_other_mail_handler</code></p>\n<p>Ex: Overriding Via Configuration File</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\"></div><div class=\"line\">### override App.Meta.mail_handler </div><div class=\"line\">mail_handler = my_mail_handler</div></pre></td></tr></table></figure>\n<h2 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"Configuration\"></a>Configuration</h2><p>Cement supports loading multiple configuration files out-of-the-box. Configurations loaded from files are merged in, overriding the applications default settings (<code>App.Meta.config_defaults</code>).  The default configuration handler is <code>ConfigParserConfigHandler</code>, based on <a href=\"https://docs.python.org/3/library/configparser.html\" target=\"_blank\" rel=\"external\">ConfigParser</a> in the standard library, and is instantiated as <code>app.config</code>.</p>\n<p>Cement looks for configuration files in the most common places such as:</p>\n<ul>\n<li><code>/etc/myapp/myapp.conf</code></li>\n<li><code>~/.myapp.conf</code></li>\n<li><code>~/.myapp/config</code></li>\n<li>etc </li>\n</ul>\n<p>The list of configuration file paths can be customized via the meta option <code>App.Meta.config_files</code> as well as their extension (i.e. <code>.conf</code>) can also be easily modified with <code>App.Meta.config_extension</code>.</p>\n<p>The builtin configuration handler <code>ConfigParserConfigHandler</code> uses common unix-like config files where <code>blocks</code> or <code>sections</code> are defined with brackets; <code>[myapp]</code>, <code>[plugin.myplugin]</code>, <code>[interface.handler]</code>, etc.</p>\n<p>Additional support for the following file formats is provided via optional extensions:</p>\n<ul>\n<li>Json</li>\n<li>Yaml</li>\n</ul>\n<p class=\"tip\">Config handler’s provide dropin replacements for the default <code>ConfigParserConfigHandler</code>, and are often based on it.  For example, the <code>JsonConfigHandler</code> and <code>YamlConfigHandler</code> hanlers do nothing more than support reading alternative file formats.  Accessing the config settings in the app is exactly the same.</p>\n\n<p>All extensions and application plugins can support customization loaded from the application configuration file under the section <code>[interface.handler]</code>. For example, the <code>ColorLogHandler</code> extension reads it’s configuration from <code>[log.colorlog]</code>.</p>\n<p>Ex: Application Configuration Settings</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App, init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'myapp'</span>][<span class=\"string\">'foo'</span>] = <span class=\"string\">'bar'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        config_defaults = defaults</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\">    print(<span class=\"string\">\"Foo =&gt; %s\"</span> % app.config.get(<span class=\"string\">'myapp'</span>, <span class=\"string\">'foo'</span>))</div></pre></td></tr></table></figure>\n<p>Configuration (<code>~/.myapp.conf</code>):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">foo = not-bar</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">Foo =&gt; not-bar</div></pre></td></tr></table></figure>\n<p><strong>Alternative Configuration Handler Example</strong></p>\n<p>The follow is an example of overriding the default config handler with an alternative, drop-in replacement <code>YamlConfighandler</code>:</p>\n<p>Ex: Alternative Configuration Handler (Yaml):</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [<span class=\"string\">'yaml'</span>]</div><div class=\"line\">        config_handler = <span class=\"string\">'yaml'</span></div><div class=\"line\">        config_extension = <span class=\"string\">'.yml'</span></div></pre></td></tr></table></figure>\n<p>Configuration (<code>~/.myapp.yml</code>):</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">myapp:</span></div><div class=\"line\"><span class=\"attr\">    foo:</span> <span class=\"string\">not-bar</span></div></pre></td></tr></table></figure>\n<h2 id=\"Arguments\"><a href=\"#Arguments\" class=\"headerlink\" title=\"Arguments\"></a>Arguments</h2><p>Argument parsing is based on the standard <a href=\"https://docs.python.org/3/library/argparse.html\" target=\"_blank\" rel=\"external\">Argparse</a> library, with the same usage that you’re familiar with.  The argument handler <code>ArgparseArgumentHandler</code> is instantiated as <code>app.args</code>, arguments are defined with <code>app.args.add_argument()</code>, and parsed arguments are stored as <code>app.args.parsed_args</code> (or more conveniently <code>app.pargs</code> for easy reference).</p>\n<p>Ex: Simple Arguments Defined With Cement App</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> App(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.args.add_argument(<span class=\"string\">'-f'</span>, <span class=\"string\">'--foo'</span>, </div><div class=\"line\">                          help=<span class=\"string\">'notorous foo option'</span>, </div><div class=\"line\">                          dest=<span class=\"string\">'foo'</span>)</div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># do something with parsed arguments</span></div><div class=\"line\">    <span class=\"keyword\">if</span> app.pargs.foo <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">        print(<span class=\"string\">\"Foo Argument =&gt; %s\"</span> % app.pargs.foo)</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet] [-f FOO]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help         show this help message and exit</div><div class=\"line\">  --debug            toggle debug output</div><div class=\"line\">  --quiet            suppress all output</div><div class=\"line\">  -f FOO, --foo FOO  notorous foo option</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py -f bar</div><div class=\"line\">Foo Argument =&gt; bar</div></pre></td></tr></table></figure>\n<p><strong>Arguments Defined by Controllers</strong></p>\n<p>The power of the framework comes into play when we start talking about application controllers that streamline the process of mapping arguments and sub-commands to actions/functions as in the example (more on that later).</p>\n<p>Ex: Arguments Defined by Controllers</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App, Controller, ex</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span><span class=\"params\">(Controller)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\">        arguments = [</div><div class=\"line\">            <span class=\"comment\"># list of tuples in the format `( [], &#123;&#125; )`</span></div><div class=\"line\">            ( [ <span class=\"string\">'-f'</span>, <span class=\"string\">'--foo'</span> ],</div><div class=\"line\">              &#123; <span class=\"string\">'help'</span> : <span class=\"string\">'notorious foo option'</span>,</div><div class=\"line\">                <span class=\"string\">'dest'</span> : <span class=\"string\">'foo'</span> &#125; ),</div><div class=\"line\">        ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @ex(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'Inside BaseController._default()'</span>)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># do something with parsed arguments</span></div><div class=\"line\">        <span class=\"keyword\">if</span> self.app.pargs.foo <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">            print(<span class=\"string\">\"Foo Argument =&gt; %s\"</span> % self.app.pargs.foo)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        handlers = [Base]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet] [-f FOO]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help         show this help message and exit</div><div class=\"line\">  --debug            toggle debug output</div><div class=\"line\">  --quiet            suppress all output</div><div class=\"line\">  -f FOO, --foo FOO  notorous foo option</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py -f bar</div><div class=\"line\">Foo Argument =&gt; bar</div></pre></td></tr></table></figure>\n<h2 id=\"Logging\"><a href=\"#Logging\" class=\"headerlink\" title=\"Logging\"></a>Logging</h2><p>Logging is based on the standard <a href=\"https://docs.python.org/3/library/logging.html\" target=\"_blank\" rel=\"external\">Logging</a> library, with the same usage you’re familiar with.  The logging facility is customizable via the <code>[log.logging]</code> section of an applications configuration:</p>\n<ul>\n<li><code>level</code> - The level at which to start logging (<code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>,<br><code>FATAL</code>, <code>DEBUG</code>, etc).</li>\n<li><code>file</code> (<em>path</em>) - File path to log to.</li>\n<li><code>to_console</code> (<em>bool</em>) - Whether or not to log to console.</li>\n<li><code>rotate</code> (<em>bool</em>) - Whether or not to rotate the log file when it hits<br><code>max_bytes</code></li>\n<li><code>max_bytes</code> (<em>int</em>) - Maximum file size in bytes before file gets rotated</li>\n<li><code>max_files</code> (<em>int</em>) - Maximum number of log files to keep after rotating</li>\n</ul>\n<p>Cement also includes the following optional extensions that provide drop-in replacements for the default log handler:</p>\n<ul>\n<li><code>ColorlogHandler</code> - Provides colorized log output via the <a href=\"https://github.com/borntyping/python-colorlog\" target=\"_blank\" rel=\"external\">Colorlog</a> library.</li>\n</ul>\n<p>Ex: Logging Example</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> App(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># log messages to console and file</span></div><div class=\"line\">    app.log.info(<span class=\"string\">'this is an info message'</span>)</div><div class=\"line\">    app.log.warning(<span class=\"string\">'this is an warning message'</span>)</div><div class=\"line\">    app.log.error(<span class=\"string\">'this is an error message'</span>)</div><div class=\"line\">    app.log.fatal(<span class=\"string\">'this is an fatal message'</span>)</div><div class=\"line\">    app.log.debug(<span class=\"string\">'this is an debug message'</span>)</div></pre></td></tr></table></figure>\n<p>Ex: Logging Configuration Example</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">log_handler = logging</div><div class=\"line\"></div><div class=\"line\">[log.logging]</div><div class=\"line\">to_console = true</div><div class=\"line\">file = /path/to/myapp.log</div><div class=\"line\">level = warning</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">INFO: this is an info message</div><div class=\"line\">WARNING: this is an warning message</div><div class=\"line\">ERROR: this is an error message</div><div class=\"line\">CRITICAL: this is an fatal message</div></pre></td></tr></table></figure>\n<h2 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h2><p>By default, Cement does not define any output handlers.  Just like any other app, you are free to <code>print()</code> to console all you like or use the builtin  logging facility.  That said, more complex applications will benefit greatly by separating the output from the logic.  Think of output handling as the <code>view</code> in a traditional <a href=\"https://en.wikipedia.org/wiki/Model-view-controller\" target=\"_blank\" rel=\"external\">MVC Framework</a>.</p>\n<p>Cement ships with several types of extensions that produce output in different forms, including the following:</p>\n<ul>\n<li>Text Rendered From Template Files</li>\n<li>Programatic Structures (JSON, Yaml, etc)</li>\n<li>Tabulated (like MySQL, etc)</li>\n<li>Etc</li>\n</ul>\n<p>The following output handlers ship with Cement:</p>\n<ul>\n<li><code>Json</code> - Produces JSON output from dicts</li>\n<li><code>Yaml</code> - Produces Yaml output from dicts</li>\n<li><code>Mustache</code> - Produces text output rendered from <a href=\"http://mustache.github.io/\" target=\"_blank\" rel=\"external\">Mustache</a> templates</li>\n<li><code>Handlebars</code> - Produces text output rendered from <a href=\"https://github.com/wbond/pybars3\" target=\"_blank\" rel=\"external\">Handlebars</a> templates</li>\n<li><code>Jinja2</code> - Produces text output rendered from <a href=\"http://jinja.pocoo.org/\" target=\"_blank\" rel=\"external\">Jinja2</a> templates</li>\n<li><code>Tabulated</code> - Produces tabulated text output rendered via the <a href=\"https://pypi.python.org/pypi/tabulate\" target=\"_blank\" rel=\"external\">Tabulate</a> library.</li>\n</ul>\n<p>Ex: Standard Output via Print Statements</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> App(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    print(<span class=\"string\">'About Run MyApp!'</span>)</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p><strong>Multiple Output Handler Support</strong></p>\n<p>One of the unique features of Cement is that you can build your application to support multiple output handlers and formats.  Output handlers have a special attribute that allows them to be exposed via the CLI option <code>-o</code> (configurable via <code>App.Meta.core_handler_override_options</code>).  Therefore, you might have default text based output rendered from Mustache templates, but optionally output programatic structures <em>from the same dict</em> when necessary (i.e.<code>$ myapp -o json</code>).</p>\n<p>Ex: Mixed Template/JSON Output Example</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">### add optional extensions</span></div><div class=\"line\">        extensions = [<span class=\"string\">'json'</span>, <span class=\"string\">'mustache'</span>]</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">### set the default output handler</span></div><div class=\"line\">        output_handler = <span class=\"string\">'mustache'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">### external template directory</span></div><div class=\"line\">        template_dir = <span class=\"string\">'/path/to/templates'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">### internal template module (shipped with app code)</span></div><div class=\"line\">        template_module = <span class=\"string\">'myapp.templates'</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">### create some data</span></div><div class=\"line\">    data = &#123;</div><div class=\"line\">        <span class=\"string\">'foo'</span> : <span class=\"string\">'bar'</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">### render data using mustache template (by default)</span></div><div class=\"line\">    app.render(data, <span class=\"string\">'example.m'</span>)</div></pre></td></tr></table></figure>\n<p>Ex: Mustache Template: /path/to/templates/example.m</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">The value of foo=&#123;&#123;foo&#125;&#125;.</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet] [-o &#123;json&#125;]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\">  -o &#123;json&#125;   output handler</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py</div><div class=\"line\">The value of foo=bar</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py -o json</div><div class=\"line\">&#123;&quot;foo&quot;: &quot;bar&quot;&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Controllers\"><a href=\"#Controllers\" class=\"headerlink\" title=\"Controllers\"></a>Controllers</h2><p>Controllers provide a common means of organizing application logic into relevant chunks of code, as well as the ability for plugins and extensions to extend an applications capabilities. It is the <code>Controller</code> piece of the traditional  <a href=\"https://en.wikipedia.org/wiki/Model-view-controller\" target=\"_blank\" rel=\"external\">MVC Framework</a>.</p>\n<p>The first controller is called <code>base</code>, and if registered will take over runtime control when <code>app.run()</code> is called.  What this means is, instead of Cement calling <code>app.args.parse_arguments()</code> directly, the application dispatch is handed over to the <code>base</code> controller, that is then responsible for parsing and handling arguments.  This is what we call <code>Runtime Dispatch</code>.</p>\n<p>The most notable action of <code>Runtime Dispatch</code> is mapping arguments and sub-commands to their respective controllers and functions.  For example, the default action when running <code>$ myapp</code> without any arguments or sub-commands is to execute the <code>BaseController._default()</code> function.</p>\n<p>Ex: Application Base Controller</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App, Controller, ex</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span><span class=\"params\">(Controller)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\">        arguments = [</div><div class=\"line\">            <span class=\"comment\"># list of tuples in the format `( [], &#123;&#125; )`</span></div><div class=\"line\">            ( [ <span class=\"string\">'-a'</span> ],</div><div class=\"line\">              &#123; <span class=\"string\">'help'</span> : <span class=\"string\">'example a option'</span>,</div><div class=\"line\">                <span class=\"string\">'dest'</span> : <span class=\"string\">'a'</span> &#125; ),</div><div class=\"line\">        ]</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'Inside Base._default()'</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> self.app.pargs.a:</div><div class=\"line\">            print(<span class=\"string\">'Received Option: -a'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @ex(</span></div><div class=\"line\">        help=<span class=\"string\">'sub-command under base controller'</span>,</div><div class=\"line\">        arguments=[</div><div class=\"line\">            ( [ <span class=\"string\">'-b'</span> ],</div><div class=\"line\">              &#123; <span class=\"string\">'help'</span> : <span class=\"string\">'cmd1 b option'</span> &#125; ),</div><div class=\"line\">        ]</div><div class=\"line\">    )</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cmd1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'Inside Base.cmd1()'</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> self.app.pargs.b:</div><div class=\"line\">            print(<span class=\"string\">'Recieved Option: -b'</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        handlers = [</div><div class=\"line\">            Base,</div><div class=\"line\">        ]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">### help output shows base namespace arguments and sub-commands</span></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py --<span class=\"built_in\">help</span></div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet] [-a A] &#123;cmd1&#125; ...</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --<span class=\"built_in\">help</span>  show this <span class=\"built_in\">help</span> message and <span class=\"built_in\">exit</span></div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\">  -a A        example a option</div><div class=\"line\"></div><div class=\"line\">sub-commands:</div><div class=\"line\">  &#123;cmd1&#125;</div><div class=\"line\">    cmd1      sub-command under base controller</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py -a foo</div><div class=\"line\">Inside Base._default()</div><div class=\"line\">Received Option: -a</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">### sub-commands support their own arguments</span></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py cmd1 --<span class=\"built_in\">help</span></div><div class=\"line\">usage: myapp cmd1 [-h] [-b B]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --<span class=\"built_in\">help</span>  show this <span class=\"built_in\">help</span> message and <span class=\"built_in\">exit</span></div><div class=\"line\">  -b B        cmd1 b option</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py cmd1 -b foo</div><div class=\"line\">Inside Base.cmd1()</div><div class=\"line\">Recieved Option: -b</div></pre></td></tr></table></figure>\n<p><strong>Nested / Embedded Controllers</strong></p>\n<p>Cement supports two types of controller <code>stacking</code>:</p>\n<ul>\n<li><code>nested</code> - The arguments and commands are nested under a sub-parser whose label is that of the controller.  For example, a nested controller with a label of <code>my-nested-controller</code> would be called as <code>$ myapp my-nested-controller sub-command</code>.</li>\n<li><code>embedded</code> - The arguments and commands are embedded within it’s parent controller, therefore appearing as if they were defined by the parent itself.  A sub-command under an embedded controller would be called as <code>$ myapp sub-command</code>.</li>\n</ul>\n<p>Controllers can be stacked on other controllers as many levels deep as necessary.  An <code>embedded</code> controller can be stacked on top of a <code>nested</code> controller, and vice versa.  There is little, if any, limitation.</p>\n<p><strong>Controller Arguments vs Command Arguments</strong></p>\n<p>Both Controllers and their sub-commands can have arguments defined.  Think of controllers as the primary namespace.  It’s arguments should be globally relevant within that namespace.  A sub-command within the namespace can have it’s own arguments, but are only relevant to that sub-command.</p>\n<p>I.e. <code>$ myapp -a my-controller -b my-sub-command -c</code></p>\n<p>In the above example, <code>-a</code> is relevant to the global scope of the entire application because it is defined on the <code>base</code> controller.  Option <code>-b</code> is relevant to the scope of <code>my-controller</code> and all sub-commands under it. Finally, <code>-c</code> is only relevant to the <code>my-sub-command</code> and has no use elsewhere.</p>\n<p><strong>Exposing Sub-Commands</strong></p>\n<p>By default, no commands are exposed to the CLI except that a <code>_default()</code> function will be called if no sub-command is passed (configurable by <code>Controller.Meta.default_func</code>).</p>\n<p>To expose a function as a sub-command, you must decorate it with <code>@ex()</code>. It’s usage is simple, and supports the following parameters:</p>\n<ul>\n<li><code>hide</code> (<em>bool</em>) - Whether or not to display in <code>--help</code> output.</li>\n<li><code>arguments</code> (<em>list</em>) - Argument list of tuples in the format <code>( [], {} )</code>, that are passed to <code>Argparse.add_argument(*args, **kwargs)</code>.</li>\n<li><code>**kwargs</code> - Additional keyword arguments are passed directly to Argparse when creating the sub-parser for this command.</li>\n</ul>\n<p class=\"tip\">Why <code>ex</code>?  Well, <code>ex</code> is short for <code>expose</code>, and just so happens that <code>@ex(</code> is exactly <code>4</code> characters, making it lineup perfectly with indented parameters.  It makes things more readable, more-better.</p>\n\n\n\n<h2 id=\"Framework-Extensions\"><a href=\"#Framework-Extensions\" class=\"headerlink\" title=\"Framework Extensions\"></a>Framework Extensions</h2><p>Cement’s Interfaces and Handlers system makes extending the framework easy, and limitless.  Cement ships dozens of extensions that either alter existing funtionality, or add to it.  For example, the default logging facility provides basic logging capabilities, however with a single line of code an application can instead use the <code>colorlog</code> extension to enable colorized console logging.  </p>\n<p>The example provides a quick look at using the <code>alarm</code> extension to handle application timeouts of long running operations</p>\n<p>Ex: Using Framework Extensions:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep</div><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [</div><div class=\"line\">            <span class=\"string\">'alarm'</span>,</div><div class=\"line\">        ]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">### set an alarm based on the max allowed run time</span></div><div class=\"line\">    app.alarm.set(<span class=\"number\">3</span>, <span class=\"string\">\"The operation timed out after 3 seconds!\"</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">### do something that takes time to operate</span></div><div class=\"line\">    sleep(<span class=\"number\">5</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">### stop the alarm if it ran within the time frame</span></div><div class=\"line\">    app.alarm.stop()</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">ERROR: The operation timed out after 3 seconds!</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">  File <span class=\"string\">\"myapp.py\"</span>, line 20, <span class=\"keyword\">in</span> &lt;module&gt;</div><div class=\"line\">    sleep(5)</div><div class=\"line\">  File <span class=\"string\">\"cement/core/foundation.py\"</span>, line 123, <span class=\"keyword\">in</span> cement_signal_handler</div><div class=\"line\">    raise exc.CaughtSignal(signum, frame)</div><div class=\"line\">cement.core.exc.CaughtSignal: Caught signal 14</div></pre></td></tr></table></figure>\n<p><strong>Included Extensions</strong></p>\n<p>Cement includes (but is not limited to) the following extensions:</p>\n<ul>\n<li><code>alarm</code> - Provides easy access to setting an application alarm to handle timing out operations</li>\n<li><code>argparse</code> - Provides <code>ArgparseArgumentHandler</code> and <code>ArgparseController</code> handlers built on Argparse</li>\n<li><code>colorlog</code> - Provides <code>ColorLogHandler</code> that produces colorized console logging</li>\n<li><code>configparser</code> - Provides <code>ConfigParserConfigHandler</code> handler for application configuration built on on ConfigParser</li>\n<li><code>daemon</code> - Provides daemonization, pidfile management, user/group context switching, etc</li>\n<li><code>handlebars</code> - Provides <code>HandlebarsOutputHandler</code> to render text output from Handlerbars templates</li>\n<li><code>jinja2</code> - Provides <code>Jinja2OutputHandler</code> to render text output from Jinja2 templates</li>\n<li><code>json</code> - Provides <code>JsonConfigHandler</code> and <code>JsonOutputHandler</code> to read JSON configuration files, and produce JSON structured output.</li>\n<li><code>logging</code> - Provides <code>LoggingLogHandler</code> for standard application logging</li>\n<li><code>memcached</code> - Providers <code>MemcachedCacheHandler</code> for caching built on Memcached</li>\n<li><code>mustache</code> - Provides <code>MustacheOutputHandler</code> to render text output from Mustache templates</li>\n<li><code>plugin</code> - Provides <code>CementPluginHandler</code> for application plugin support</li>\n<li><code>redis</code> - Provides <code>RedisCacheHandler</code> for caching built on Redis</li>\n<li><code>smtp</code> - Provides <code>SMTPMailHandler</code> for email messaging</li>\n<li><code>tabulate</code> - Provides <code>TabulateOutputHandler</code> for text output tabularized like MySQL, etc</li>\n<li><code>watchdog</code> - Provides cross-platform directory/file monitoring in order to handle filesystem events as they occur.</li>\n<li><code>yaml</code> - Providers <code>YamlConfigHandler</code> and <code>YamlOutputHandler</code> to read Yaml configuration files, and produce Yaml structured output.</li>\n</ul>\n<h2 id=\"Application-Plugins\"><a href=\"#Application-Plugins\" class=\"headerlink\" title=\"Application Plugins\"></a>Application Plugins</h2><p>Cement provides an interface that automatically handles the management, configuration, and loading of Application Plugins.  A Plugin is essentially the same as a Framework Extension, but is application specific where extensions are agnostic (can be used by any application).  </p>\n<p>A plugin can be anything, and provide any kind of functionality from defining runtime hooks, to extending an applications capabilities by adding nested/embedded controllers.  the only thing that a plugin must provide is a <code>load()</code> function that is called when the plugin is imported.</p>\n<p>Ex: Basic Application</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App, Controller, ex</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span><span class=\"params\">(Controller)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        handlers = [</div><div class=\"line\">            Base,</div><div class=\"line\">        ]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>CLI Usage (without plugin enabled):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python test.py --help</div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet] &#123;&#125; ...</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\"></div><div class=\"line\">sub-commands:</div><div class=\"line\">  &#123;&#125;</div></pre></td></tr></table></figure>\n<p>Ex: Plugin</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> Controller, ex</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPlugin</span><span class=\"params\">(Controller)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myplugin'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'embedded'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @ex()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cmd1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'Inside MyPlugin.cmd1()'</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    app.handler.register(MyPlugin)</div></pre></td></tr></table></figure>\n<p>Configuration (<code>~/.myapp.conf</code>):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">plugin_dir = /path/to/myapp/plugins</div><div class=\"line\"></div><div class=\"line\">[plugin.myplugin]</div><div class=\"line\">enabled = true</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet] &#123;cmd1&#125; ...</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\"></div><div class=\"line\">sub-commands:</div><div class=\"line\">  &#123;cmd1&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py cmd1</div><div class=\"line\">Inside MyPlugin.cmd1()</div></pre></td></tr></table></figure>\n<h2 id=\"Hooks\"><a href=\"#Hooks\" class=\"headerlink\" title=\"Hooks\"></a>Hooks</h2><p>Hooks provide developers the ability to tie into the framework, and applications without direct access to the runtime.  For example, a plugin might need to execute some code after arguments have been parsed, but before controller sub-commands are dispatched.  As a plugin developer, you don’t have direct access to the applications runtime code but you can still tie into it with the builtin <code>post_argument_parsing</code> hook.</p>\n<p>Cement defines several hooks that tie in to specific points throughout the application life cycle, however application developers can also define their own hooks allowing others to tie elsewhere, when needed.</p>\n<p>Ex: Executing Code Via Hooks</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_example_hook</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'Inside my_example_hook()'</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        hooks = [</div><div class=\"line\">            (<span class=\"string\">'post_argument_parsing'</span>, my_example_hook),</div><div class=\"line\">        ]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">Inside my_example_hook()</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>This section is intended to give a brief overview of some of the most commonly used core features of Cement.  Please do not be discouraged if you don’t “get it” right away.  Please also do not think, “is this it?”.  This is not intended to be an exhaustive end-all-be-all coverage of every feature of the framework.</p>\n<p>Some assumptions are being made here.  Primarily, we assume that you’ve used and are familiar with Python.  The overview is intended to give a high level look at using Cement.  Please dive deeper into the individual sections after the overview in order to gain a better understanding of each component.</p>\n<h2 id=\"The-Application-Object\"><a href=\"#The-Application-Object\" class=\"headerlink\" title=\"The Application Object\"></a>The Application Object</h2><p>The core of your application starts with the Cement <code>App</code> object, which we will refer to throughout this documentation in several ways:</p>\n<ul>\n<li><code>App</code> - The uninstantiated Cement <code>App</code> base class</li>\n<li><code>MyApp</code> - The uninstatiated/sub-classed Cement application you are creating</li>\n<li><code>app</code> - The instantiated application object</li>\n</ul>\n<p>Technically, Cement <code>App</code> can be used direcly (as in the example), however in practice you will almost always sub-class <code>App</code> in order to configure it for your needs (I.e. <code>MyApp</code>).</p>\n<p>Using Cement App Directly:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> App(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>Sub-classing Cement App:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --<span class=\"built_in\">help</span></div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --<span class=\"built_in\">help</span>  show this <span class=\"built_in\">help</span> message and <span class=\"built_in\">exit</span></div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div></pre></td></tr></table></figure>\n<h2 id=\"MetaMixin\"><a href=\"#MetaMixin\" class=\"headerlink\" title=\"MetaMixin\"></a>MetaMixin</h2><p>Cement uses <code>MetaMixin</code> classes everywhere, which allows the framework to define default functionality but also provides an easy mechanism for developers to override and customize.  </p>\n<p>This is implemented by declaring a <code>Meta</code> class, under your application and/or other Cement Handler classes.  </p>\n<p>Ex: Defining Meta Classes</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [<span class=\"string\">'json'</span>]</div></pre></td></tr></table></figure>\n<p>All Meta-options can also be overridden by any <code>**kwargs</code> that are passed to the parent class that is being instantiated. </p>\n<p>Ex: Passing meta options via <code>**kwargs</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">App(<span class=\"string\">'myapp'</span>, config_defaults=&#123;<span class=\"string\">'foo'</span>: <span class=\"string\">'bar'</span>&#125;)</div></pre></td></tr></table></figure>\n<p>Nearly every Cement class has an associated <code>Meta</code> class, which we often refer to as <code>App.Meta</code>, <code>SomeHandlerClass.Meta</code>, etc.  The instantiated object is refered to in code as <code>app._meta</code>, <code>some_handler._meta</code>, etc.</p>\n<p>Ex: Sub-classing Cement App / Overriding Metadata Options:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App, init_defaults</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># define default application configuration settings</span></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'myapp'</span>][<span class=\"string\">'foo'</span>] = <span class=\"string\">'bar'</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        config_defaults = defaults</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\">    print(<span class=\"string\">\"Foo =&gt; %s\"</span> % app.config.get(<span class=\"string\">'myapp'</span>, <span class=\"string\">'foo'</span>))</div></pre></td></tr></table></figure>\n<p>CLI Usage</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">Foo =&gt; bar</div></pre></td></tr></table></figure>\n<h2 id=\"Interfaces-and-Handlers\"><a href=\"#Interfaces-and-Handlers\" class=\"headerlink\" title=\"Interfaces and Handlers\"></a>Interfaces and Handlers</h2><p>All aspects of the framework are broken up into interfaces, and handlers. Interfaces define some functionality, and Handlers implement that functionality. Cement defines the following interfaces:</p>\n<ul>\n<li><code>extension</code> - Framework extensions loading</li>\n<li><code>log</code> - Logging to console/file</li>\n<li><code>config</code> - Application Configuration defaults, overrides by file, etc</li>\n<li><code>mail</code> - Mail sending (smtp, etc)</li>\n<li><code>plugin</code> - Application plugin loading</li>\n<li><code>output</code> - Output rendering (JSON, Yaml, Mustache Templates, etc)</li>\n<li><code>argument</code> - Command line argument parsing</li>\n<li><code>controller</code> - Command dispatch (sub-commands, sub-command arguments, etc)</li>\n<li><code>cache</code> - Key/Value data store (memcached, redis, etc)</li>\n</ul>\n<p>For example, the builtin configuration handler <code>ConfigParserConfigHandler</code>, implements the <code>config</code> interface.  Handlers are referred to by the interfaces they implement, such as <code>config.configparser</code>, <code>config.json</code>, <code>config.yaml</code>, etc.</p>\n<p class=\"tip\">Application developers can also define their own interfaces, allowing customization by plugins.</p>\n\n\n<p>Ex: Overriding Default Framework Handlers</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"><span class=\"keyword\">from</span> cement.ext.ext_configparser <span class=\"keyword\">import</span> ConfigParserConfigHandler</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyConfigHandler</span><span class=\"params\">(ConfigParserConfigHandler)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'my_config_handler'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># do something to subclass/re-implement </span></div><div class=\"line\">    <span class=\"comment\"># config handler here...</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        config_handler = <span class=\"string\">'my_config_handler'</span></div><div class=\"line\">        handlers = [</div><div class=\"line\">            MyConfigHandler</div><div class=\"line\">        ]</div></pre></td></tr></table></figure>\n<p><strong>Overriding Via Configuration Files</strong></p>\n<p><code>MyApp</code> defines and/or defaults to builtin handlers for all of the above listed core handlers.  Whatever the application code defines is the default,  however you can also override via the configuration file(s) as in the example to the right.  </p>\n<p>For example, imagine that your default <code>mail_handler</code> is <code>smtp</code> for sending email via your local SMTP server.  This is a configuration that might very on a per-user/environment basis.  Via the application configuration, you could override this with an alternative mail handler like <code>mail_handler=some_other_mail_handler</code></p>\n<p>Ex: Overriding Via Configuration File</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\"></div><div class=\"line\">### override App.Meta.mail_handler </div><div class=\"line\">mail_handler = my_mail_handler</div></pre></td></tr></table></figure>\n<h2 id=\"Configuration\"><a href=\"#Configuration\" class=\"headerlink\" title=\"Configuration\"></a>Configuration</h2><p>Cement supports loading multiple configuration files out-of-the-box. Configurations loaded from files are merged in, overriding the applications default settings (<code>App.Meta.config_defaults</code>).  The default configuration handler is <code>ConfigParserConfigHandler</code>, based on <a href=\"https://docs.python.org/3/library/configparser.html\">ConfigParser</a> in the standard library, and is instantiated as <code>app.config</code>.</p>\n<p>Cement looks for configuration files in the most common places such as:</p>\n<ul>\n<li><code>/etc/myapp/myapp.conf</code></li>\n<li><code>~/.myapp.conf</code></li>\n<li><code>~/.myapp/config</code></li>\n<li>etc </li>\n</ul>\n<p>The list of configuration file paths can be customized via the meta option <code>App.Meta.config_files</code> as well as their extension (i.e. <code>.conf</code>) can also be easily modified with <code>App.Meta.config_extension</code>.</p>\n<p>The builtin configuration handler <code>ConfigParserConfigHandler</code> uses common unix-like config files where <code>blocks</code> or <code>sections</code> are defined with brackets; <code>[myapp]</code>, <code>[plugin.myplugin]</code>, <code>[interface.handler]</code>, etc.</p>\n<p>Additional support for the following file formats is provided via optional extensions:</p>\n<ul>\n<li>Json</li>\n<li>Yaml</li>\n</ul>\n<p class=\"tip\">Config handler’s provide dropin replacements for the default <code>ConfigParserConfigHandler</code>, and are often based on it.  For example, the <code>JsonConfigHandler</code> and <code>YamlConfigHandler</code> hanlers do nothing more than support reading alternative file formats.  Accessing the config settings in the app is exactly the same.</p>\n\n<p>All extensions and application plugins can support customization loaded from the application configuration file under the section <code>[interface.handler]</code>. For example, the <code>ColorLogHandler</code> extension reads it’s configuration from <code>[log.colorlog]</code>.</p>\n<p>Ex: Application Configuration Settings</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App, init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'myapp'</span>][<span class=\"string\">'foo'</span>] = <span class=\"string\">'bar'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        config_defaults = defaults</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\">    print(<span class=\"string\">\"Foo =&gt; %s\"</span> % app.config.get(<span class=\"string\">'myapp'</span>, <span class=\"string\">'foo'</span>))</div></pre></td></tr></table></figure>\n<p>Configuration (<code>~/.myapp.conf</code>):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">foo = not-bar</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">Foo =&gt; not-bar</div></pre></td></tr></table></figure>\n<p><strong>Alternative Configuration Handler Example</strong></p>\n<p>The follow is an example of overriding the default config handler with an alternative, drop-in replacement <code>YamlConfighandler</code>:</p>\n<p>Ex: Alternative Configuration Handler (Yaml):</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [<span class=\"string\">'yaml'</span>]</div><div class=\"line\">        config_handler = <span class=\"string\">'yaml'</span></div><div class=\"line\">        config_extension = <span class=\"string\">'.yml'</span></div></pre></td></tr></table></figure>\n<p>Configuration (<code>~/.myapp.yml</code>):</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">myapp:</span></div><div class=\"line\"><span class=\"attr\">    foo:</span> <span class=\"string\">not-bar</span></div></pre></td></tr></table></figure>\n<h2 id=\"Arguments\"><a href=\"#Arguments\" class=\"headerlink\" title=\"Arguments\"></a>Arguments</h2><p>Argument parsing is based on the standard <a href=\"https://docs.python.org/3/library/argparse.html\">Argparse</a> library, with the same usage that you’re familiar with.  The argument handler <code>ArgparseArgumentHandler</code> is instantiated as <code>app.args</code>, arguments are defined with <code>app.args.add_argument()</code>, and parsed arguments are stored as <code>app.args.parsed_args</code> (or more conveniently <code>app.pargs</code> for easy reference).</p>\n<p>Ex: Simple Arguments Defined With Cement App</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> App(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.args.add_argument(<span class=\"string\">'-f'</span>, <span class=\"string\">'--foo'</span>, </div><div class=\"line\">                          help=<span class=\"string\">'notorous foo option'</span>, </div><div class=\"line\">                          dest=<span class=\"string\">'foo'</span>)</div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># do something with parsed arguments</span></div><div class=\"line\">    <span class=\"keyword\">if</span> app.pargs.foo <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">        print(<span class=\"string\">\"Foo Argument =&gt; %s\"</span> % app.pargs.foo)</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet] [-f FOO]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help         show this help message and exit</div><div class=\"line\">  --debug            toggle debug output</div><div class=\"line\">  --quiet            suppress all output</div><div class=\"line\">  -f FOO, --foo FOO  notorous foo option</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py -f bar</div><div class=\"line\">Foo Argument =&gt; bar</div></pre></td></tr></table></figure>\n<p><strong>Arguments Defined by Controllers</strong></p>\n<p>The power of the framework comes into play when we start talking about application controllers that streamline the process of mapping arguments and sub-commands to actions/functions as in the example (more on that later).</p>\n<p>Ex: Arguments Defined by Controllers</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App, Controller, ex</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span><span class=\"params\">(Controller)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\">        arguments = [</div><div class=\"line\">            <span class=\"comment\"># list of tuples in the format `( [], &#123;&#125; )`</span></div><div class=\"line\">            ( [ <span class=\"string\">'-f'</span>, <span class=\"string\">'--foo'</span> ],</div><div class=\"line\">              &#123; <span class=\"string\">'help'</span> : <span class=\"string\">'notorious foo option'</span>,</div><div class=\"line\">                <span class=\"string\">'dest'</span> : <span class=\"string\">'foo'</span> &#125; ),</div><div class=\"line\">        ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @ex(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'Inside BaseController._default()'</span>)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># do something with parsed arguments</span></div><div class=\"line\">        <span class=\"keyword\">if</span> self.app.pargs.foo <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">            print(<span class=\"string\">\"Foo Argument =&gt; %s\"</span> % self.app.pargs.foo)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        handlers = [Base]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet] [-f FOO]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help         show this help message and exit</div><div class=\"line\">  --debug            toggle debug output</div><div class=\"line\">  --quiet            suppress all output</div><div class=\"line\">  -f FOO, --foo FOO  notorous foo option</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py -f bar</div><div class=\"line\">Foo Argument =&gt; bar</div></pre></td></tr></table></figure>\n<h2 id=\"Logging\"><a href=\"#Logging\" class=\"headerlink\" title=\"Logging\"></a>Logging</h2><p>Logging is based on the standard <a href=\"https://docs.python.org/3/library/logging.html\">Logging</a> library, with the same usage you’re familiar with.  The logging facility is customizable via the <code>[log.logging]</code> section of an applications configuration:</p>\n<ul>\n<li><code>level</code> - The level at which to start logging (<code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>,<br><code>FATAL</code>, <code>DEBUG</code>, etc).</li>\n<li><code>file</code> (<em>path</em>) - File path to log to.</li>\n<li><code>to_console</code> (<em>bool</em>) - Whether or not to log to console.</li>\n<li><code>rotate</code> (<em>bool</em>) - Whether or not to rotate the log file when it hits<br><code>max_bytes</code></li>\n<li><code>max_bytes</code> (<em>int</em>) - Maximum file size in bytes before file gets rotated</li>\n<li><code>max_files</code> (<em>int</em>) - Maximum number of log files to keep after rotating</li>\n</ul>\n<p>Cement also includes the following optional extensions that provide drop-in replacements for the default log handler:</p>\n<ul>\n<li><code>ColorlogHandler</code> - Provides colorized log output via the <a href=\"https://github.com/borntyping/python-colorlog\">Colorlog</a> library.</li>\n</ul>\n<p>Ex: Logging Example</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> App(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># log messages to console and file</span></div><div class=\"line\">    app.log.info(<span class=\"string\">'this is an info message'</span>)</div><div class=\"line\">    app.log.warning(<span class=\"string\">'this is an warning message'</span>)</div><div class=\"line\">    app.log.error(<span class=\"string\">'this is an error message'</span>)</div><div class=\"line\">    app.log.fatal(<span class=\"string\">'this is an fatal message'</span>)</div><div class=\"line\">    app.log.debug(<span class=\"string\">'this is an debug message'</span>)</div></pre></td></tr></table></figure>\n<p>Ex: Logging Configuration Example</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">log_handler = logging</div><div class=\"line\"></div><div class=\"line\">[log.logging]</div><div class=\"line\">to_console = true</div><div class=\"line\">file = /path/to/myapp.log</div><div class=\"line\">level = warning</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">INFO: this is an info message</div><div class=\"line\">WARNING: this is an warning message</div><div class=\"line\">ERROR: this is an error message</div><div class=\"line\">CRITICAL: this is an fatal message</div></pre></td></tr></table></figure>\n<h2 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h2><p>By default, Cement does not define any output handlers.  Just like any other app, you are free to <code>print()</code> to console all you like or use the builtin  logging facility.  That said, more complex applications will benefit greatly by separating the output from the logic.  Think of output handling as the <code>view</code> in a traditional <a href=\"https://en.wikipedia.org/wiki/Model-view-controller\">MVC Framework</a>.</p>\n<p>Cement ships with several types of extensions that produce output in different forms, including the following:</p>\n<ul>\n<li>Text Rendered From Template Files</li>\n<li>Programatic Structures (JSON, Yaml, etc)</li>\n<li>Tabulated (like MySQL, etc)</li>\n<li>Etc</li>\n</ul>\n<p>The following output handlers ship with Cement:</p>\n<ul>\n<li><code>Json</code> - Produces JSON output from dicts</li>\n<li><code>Yaml</code> - Produces Yaml output from dicts</li>\n<li><code>Mustache</code> - Produces text output rendered from <a href=\"http://mustache.github.io/\">Mustache</a> templates</li>\n<li><code>Handlebars</code> - Produces text output rendered from <a href=\"https://github.com/wbond/pybars3\">Handlebars</a> templates</li>\n<li><code>Jinja2</code> - Produces text output rendered from <a href=\"http://jinja.pocoo.org/\">Jinja2</a> templates</li>\n<li><code>Tabulated</code> - Produces tabulated text output rendered via the <a href=\"https://pypi.python.org/pypi/tabulate\">Tabulate</a> library.</li>\n</ul>\n<p>Ex: Standard Output via Print Statements</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> App(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    print(<span class=\"string\">'About Run MyApp!'</span>)</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p><strong>Multiple Output Handler Support</strong></p>\n<p>One of the unique features of Cement is that you can build your application to support multiple output handlers and formats.  Output handlers have a special attribute that allows them to be exposed via the CLI option <code>-o</code> (configurable via <code>App.Meta.core_handler_override_options</code>).  Therefore, you might have default text based output rendered from Mustache templates, but optionally output programatic structures <em>from the same dict</em> when necessary (i.e.<code>$ myapp -o json</code>).</p>\n<p>Ex: Mixed Template/JSON Output Example</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">### add optional extensions</span></div><div class=\"line\">        extensions = [<span class=\"string\">'json'</span>, <span class=\"string\">'mustache'</span>]</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">### set the default output handler</span></div><div class=\"line\">        output_handler = <span class=\"string\">'mustache'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">### external template directory</span></div><div class=\"line\">        template_dir = <span class=\"string\">'/path/to/templates'</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">### internal template module (shipped with app code)</span></div><div class=\"line\">        template_module = <span class=\"string\">'myapp.templates'</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">### create some data</span></div><div class=\"line\">    data = &#123;</div><div class=\"line\">        <span class=\"string\">'foo'</span> : <span class=\"string\">'bar'</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">### render data using mustache template (by default)</span></div><div class=\"line\">    app.render(data, <span class=\"string\">'example.m'</span>)</div></pre></td></tr></table></figure>\n<p>Ex: Mustache Template: /path/to/templates/example.m</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">The value of foo=&#123;&#123;foo&#125;&#125;.</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet] [-o &#123;json&#125;]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\">  -o &#123;json&#125;   output handler</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py</div><div class=\"line\">The value of foo=bar</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py -o json</div><div class=\"line\">&#123;&quot;foo&quot;: &quot;bar&quot;&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Controllers\"><a href=\"#Controllers\" class=\"headerlink\" title=\"Controllers\"></a>Controllers</h2><p>Controllers provide a common means of organizing application logic into relevant chunks of code, as well as the ability for plugins and extensions to extend an applications capabilities. It is the <code>Controller</code> piece of the traditional  <a href=\"https://en.wikipedia.org/wiki/Model-view-controller\">MVC Framework</a>.</p>\n<p>The first controller is called <code>base</code>, and if registered will take over runtime control when <code>app.run()</code> is called.  What this means is, instead of Cement calling <code>app.args.parse_arguments()</code> directly, the application dispatch is handed over to the <code>base</code> controller, that is then responsible for parsing and handling arguments.  This is what we call <code>Runtime Dispatch</code>.</p>\n<p>The most notable action of <code>Runtime Dispatch</code> is mapping arguments and sub-commands to their respective controllers and functions.  For example, the default action when running <code>$ myapp</code> without any arguments or sub-commands is to execute the <code>BaseController._default()</code> function.</p>\n<p>Ex: Application Base Controller</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App, Controller, ex</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span><span class=\"params\">(Controller)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\">        arguments = [</div><div class=\"line\">            <span class=\"comment\"># list of tuples in the format `( [], &#123;&#125; )`</span></div><div class=\"line\">            ( [ <span class=\"string\">'-a'</span> ],</div><div class=\"line\">              &#123; <span class=\"string\">'help'</span> : <span class=\"string\">'example a option'</span>,</div><div class=\"line\">                <span class=\"string\">'dest'</span> : <span class=\"string\">'a'</span> &#125; ),</div><div class=\"line\">        ]</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'Inside Base._default()'</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> self.app.pargs.a:</div><div class=\"line\">            print(<span class=\"string\">'Received Option: -a'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @ex(</span></div><div class=\"line\">        help=<span class=\"string\">'sub-command under base controller'</span>,</div><div class=\"line\">        arguments=[</div><div class=\"line\">            ( [ <span class=\"string\">'-b'</span> ],</div><div class=\"line\">              &#123; <span class=\"string\">'help'</span> : <span class=\"string\">'cmd1 b option'</span> &#125; ),</div><div class=\"line\">        ]</div><div class=\"line\">    )</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cmd1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'Inside Base.cmd1()'</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> self.app.pargs.b:</div><div class=\"line\">            print(<span class=\"string\">'Recieved Option: -b'</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        handlers = [</div><div class=\"line\">            Base,</div><div class=\"line\">        ]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">### help output shows base namespace arguments and sub-commands</span></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py --<span class=\"built_in\">help</span></div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet] [-a A] &#123;cmd1&#125; ...</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --<span class=\"built_in\">help</span>  show this <span class=\"built_in\">help</span> message and <span class=\"built_in\">exit</span></div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\">  -a A        example a option</div><div class=\"line\"></div><div class=\"line\">sub-commands:</div><div class=\"line\">  &#123;cmd1&#125;</div><div class=\"line\">    cmd1      sub-command under base controller</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py -a foo</div><div class=\"line\">Inside Base._default()</div><div class=\"line\">Received Option: -a</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">### sub-commands support their own arguments</span></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py cmd1 --<span class=\"built_in\">help</span></div><div class=\"line\">usage: myapp cmd1 [-h] [-b B]</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --<span class=\"built_in\">help</span>  show this <span class=\"built_in\">help</span> message and <span class=\"built_in\">exit</span></div><div class=\"line\">  -b B        cmd1 b option</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py cmd1 -b foo</div><div class=\"line\">Inside Base.cmd1()</div><div class=\"line\">Recieved Option: -b</div></pre></td></tr></table></figure>\n<p><strong>Nested / Embedded Controllers</strong></p>\n<p>Cement supports two types of controller <code>stacking</code>:</p>\n<ul>\n<li><code>nested</code> - The arguments and commands are nested under a sub-parser whose label is that of the controller.  For example, a nested controller with a label of <code>my-nested-controller</code> would be called as <code>$ myapp my-nested-controller sub-command</code>.</li>\n<li><code>embedded</code> - The arguments and commands are embedded within it’s parent controller, therefore appearing as if they were defined by the parent itself.  A sub-command under an embedded controller would be called as <code>$ myapp sub-command</code>.</li>\n</ul>\n<p>Controllers can be stacked on other controllers as many levels deep as necessary.  An <code>embedded</code> controller can be stacked on top of a <code>nested</code> controller, and vice versa.  There is little, if any, limitation.</p>\n<p><strong>Controller Arguments vs Command Arguments</strong></p>\n<p>Both Controllers and their sub-commands can have arguments defined.  Think of controllers as the primary namespace.  It’s arguments should be globally relevant within that namespace.  A sub-command within the namespace can have it’s own arguments, but are only relevant to that sub-command.</p>\n<p>I.e. <code>$ myapp -a my-controller -b my-sub-command -c</code></p>\n<p>In the above example, <code>-a</code> is relevant to the global scope of the entire application because it is defined on the <code>base</code> controller.  Option <code>-b</code> is relevant to the scope of <code>my-controller</code> and all sub-commands under it. Finally, <code>-c</code> is only relevant to the <code>my-sub-command</code> and has no use elsewhere.</p>\n<p><strong>Exposing Sub-Commands</strong></p>\n<p>By default, no commands are exposed to the CLI except that a <code>_default()</code> function will be called if no sub-command is passed (configurable by <code>Controller.Meta.default_func</code>).</p>\n<p>To expose a function as a sub-command, you must decorate it with <code>@ex()</code>. It’s usage is simple, and supports the following parameters:</p>\n<ul>\n<li><code>hide</code> (<em>bool</em>) - Whether or not to display in <code>--help</code> output.</li>\n<li><code>arguments</code> (<em>list</em>) - Argument list of tuples in the format <code>( [], {} )</code>, that are passed to <code>Argparse.add_argument(*args, **kwargs)</code>.</li>\n<li><code>**kwargs</code> - Additional keyword arguments are passed directly to Argparse when creating the sub-parser for this command.</li>\n</ul>\n<p class='tip'>Why <code>ex</code>?  Well, <code>ex</code> is short for <code>expose</code>, and just so happens that <code>@ex(</code> is exactly <code>4</code> characters, making it lineup perfectly with indented parameters.  It makes things more readable, more-better.</p>\n\n\n\n<h2 id=\"Framework-Extensions\"><a href=\"#Framework-Extensions\" class=\"headerlink\" title=\"Framework Extensions\"></a>Framework Extensions</h2><p>Cement’s Interfaces and Handlers system makes extending the framework easy, and limitless.  Cement ships dozens of extensions that either alter existing funtionality, or add to it.  For example, the default logging facility provides basic logging capabilities, however with a single line of code an application can instead use the <code>colorlog</code> extension to enable colorized console logging.  </p>\n<p>The example provides a quick look at using the <code>alarm</code> extension to handle application timeouts of long running operations</p>\n<p>Ex: Using Framework Extensions:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep</div><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [</div><div class=\"line\">            <span class=\"string\">'alarm'</span>,</div><div class=\"line\">        ]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">### set an alarm based on the max allowed run time</span></div><div class=\"line\">    app.alarm.set(<span class=\"number\">3</span>, <span class=\"string\">\"The operation timed out after 3 seconds!\"</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">### do something that takes time to operate</span></div><div class=\"line\">    sleep(<span class=\"number\">5</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">### stop the alarm if it ran within the time frame</span></div><div class=\"line\">    app.alarm.stop()</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">ERROR: The operation timed out after 3 seconds!</div><div class=\"line\">Traceback (most recent call last):</div><div class=\"line\">  File <span class=\"string\">\"myapp.py\"</span>, line 20, <span class=\"keyword\">in</span> &lt;module&gt;</div><div class=\"line\">    sleep(5)</div><div class=\"line\">  File <span class=\"string\">\"cement/core/foundation.py\"</span>, line 123, <span class=\"keyword\">in</span> cement_signal_handler</div><div class=\"line\">    raise exc.CaughtSignal(signum, frame)</div><div class=\"line\">cement.core.exc.CaughtSignal: Caught signal 14</div></pre></td></tr></table></figure>\n<p><strong>Included Extensions</strong></p>\n<p>Cement includes (but is not limited to) the following extensions:</p>\n<ul>\n<li><code>alarm</code> - Provides easy access to setting an application alarm to handle timing out operations</li>\n<li><code>argparse</code> - Provides <code>ArgparseArgumentHandler</code> and <code>ArgparseController</code> handlers built on Argparse</li>\n<li><code>colorlog</code> - Provides <code>ColorLogHandler</code> that produces colorized console logging</li>\n<li><code>configparser</code> - Provides <code>ConfigParserConfigHandler</code> handler for application configuration built on on ConfigParser</li>\n<li><code>daemon</code> - Provides daemonization, pidfile management, user/group context switching, etc</li>\n<li><code>handlebars</code> - Provides <code>HandlebarsOutputHandler</code> to render text output from Handlerbars templates</li>\n<li><code>jinja2</code> - Provides <code>Jinja2OutputHandler</code> to render text output from Jinja2 templates</li>\n<li><code>json</code> - Provides <code>JsonConfigHandler</code> and <code>JsonOutputHandler</code> to read JSON configuration files, and produce JSON structured output.</li>\n<li><code>logging</code> - Provides <code>LoggingLogHandler</code> for standard application logging</li>\n<li><code>memcached</code> - Providers <code>MemcachedCacheHandler</code> for caching built on Memcached</li>\n<li><code>mustache</code> - Provides <code>MustacheOutputHandler</code> to render text output from Mustache templates</li>\n<li><code>plugin</code> - Provides <code>CementPluginHandler</code> for application plugin support</li>\n<li><code>redis</code> - Provides <code>RedisCacheHandler</code> for caching built on Redis</li>\n<li><code>smtp</code> - Provides <code>SMTPMailHandler</code> for email messaging</li>\n<li><code>tabulate</code> - Provides <code>TabulateOutputHandler</code> for text output tabularized like MySQL, etc</li>\n<li><code>watchdog</code> - Provides cross-platform directory/file monitoring in order to handle filesystem events as they occur.</li>\n<li><code>yaml</code> - Providers <code>YamlConfigHandler</code> and <code>YamlOutputHandler</code> to read Yaml configuration files, and produce Yaml structured output.</li>\n</ul>\n<h2 id=\"Application-Plugins\"><a href=\"#Application-Plugins\" class=\"headerlink\" title=\"Application Plugins\"></a>Application Plugins</h2><p>Cement provides an interface that automatically handles the management, configuration, and loading of Application Plugins.  A Plugin is essentially the same as a Framework Extension, but is application specific where extensions are agnostic (can be used by any application).  </p>\n<p>A plugin can be anything, and provide any kind of functionality from defining runtime hooks, to extending an applications capabilities by adding nested/embedded controllers.  the only thing that a plugin must provide is a <code>load()</code> function that is called when the plugin is imported.</p>\n<p>Ex: Basic Application</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App, Controller, ex</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span><span class=\"params\">(Controller)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        handlers = [</div><div class=\"line\">            Base,</div><div class=\"line\">        ]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>CLI Usage (without plugin enabled):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python test.py --help</div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet] &#123;&#125; ...</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\"></div><div class=\"line\">sub-commands:</div><div class=\"line\">  &#123;&#125;</div></pre></td></tr></table></figure>\n<p>Ex: Plugin</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> Controller, ex</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPlugin</span><span class=\"params\">(Controller)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myplugin'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'embedded'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @ex()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cmd1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'Inside MyPlugin.cmd1()'</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    app.handler.register(MyPlugin)</div></pre></td></tr></table></figure>\n<p>Configuration (<code>~/.myapp.conf</code>):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">plugin_dir = /path/to/myapp/plugins</div><div class=\"line\"></div><div class=\"line\">[plugin.myplugin]</div><div class=\"line\">enabled = true</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp [-h] [--debug] [--quiet] &#123;cmd1&#125; ...</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\"></div><div class=\"line\">sub-commands:</div><div class=\"line\">  &#123;cmd1&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py cmd1</div><div class=\"line\">Inside MyPlugin.cmd1()</div></pre></td></tr></table></figure>\n<h2 id=\"Hooks\"><a href=\"#Hooks\" class=\"headerlink\" title=\"Hooks\"></a>Hooks</h2><p>Hooks provide developers the ability to tie into the framework, and applications without direct access to the runtime.  For example, a plugin might need to execute some code after arguments have been parsed, but before controller sub-commands are dispatched.  As a plugin developer, you don’t have direct access to the applications runtime code but you can still tie into it with the builtin <code>post_argument_parsing</code> hook.</p>\n<p>Cement defines several hooks that tie in to specific points throughout the application life cycle, however application developers can also define their own hooks allowing others to tie elsewhere, when needed.</p>\n<p>Ex: Executing Code Via Hooks</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement <span class=\"keyword\">import</span> App</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_example_hook</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">'Inside my_example_hook()'</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(App)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        hooks = [</div><div class=\"line\">            (<span class=\"string\">'post_argument_parsing'</span>, my_example_hook),</div><div class=\"line\">        ]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>CLI Usage:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">Inside my_example_hook()</div></pre></td></tr></table></figure>\n"},{"title":"Output","type":"guide","version":"2.10","order":8,"_content":"\nCement defines an output interface called [IOutput](/{{ version }}/api/core/output.html#cement.core.output.IOutput), as well as the default [DummyOutputHandler](/{{ version }}/api/ext/ext_dummy.html) that implements the interface.  This handler is part of Cement, and actually does nothing to produce output.  Therefore it can be said that by default a Cement application does not handle rendering output to the console, but can if another output handler be used.\n\nPlease note that there may be other handler's that implement the `IOutput` interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.\n\nThe following output handlers are included and maintained with Cement:\n\n- [DummyOutputHandler](/{{ version }}/api/ext/ext_dummy.html)\n- [JsonOutputHandler](/{{ version }}/api/ext/ext_json.html)\n- [YamlOutputHandler](/{{ version }}/api/ext/ext_yaml.html)\n- [GenshiOutputHandler](/{{ version }}/api/ext/ext_genshi.html)\n- [HandlebarsOutputHandler](/{{ version }}/api/ext/ext_handlebars.html)\n- [Jinja2OutputHandler](/{{ version }}/api/ext/ext_jinja2.html)\n- [MustacheOutputHandler](/{{ version }}/api/ext/ext_mustache.html)\n- [TabulateOUtputHandler](/{{ version }}/api/ext/ext_tabulate.html)\n\n\nPlease reference the [IOutput](/{{ version }}/api/core/output.html#cement.core.output.IOutput) interface documentation for writing your own output handler.\n\n\n## Rending Output\n\nCement applications do not need to use an output handler by any means.  Most small applications can get away with simple `print()` statements.  However, anyone who has ever built a bigger application that produces a lot of output will know that this can get ugly very quickly in your code.\n\nUsing an output handler allows the developer to keep their logic clean, and offload the display of relevant data to an output handler, possibly by templates or other means (GUI?).\n\nAn output handler has a `render()` function that takes a data dictionary to produce output.  Some output handlers may also accept a `template` or other parameters that define how output is rendered.  This is easily accessible by the application object.\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    app.run()\n\n    # render data dictionary with the output handler\n    data = dict(foo='bar')\n    app.render(data)\n```\n\nThe above example uses the default output handler, therefore nothing is displayed on screen.  That said, if we write our own quickly we can see something happen:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.output import CementOutputHandler\n\n# Create a custom output handler\nclass MyOutputHandler(CementOutputHandler):\n    class Meta:\n        label = 'myoutput'\n\n    def render(self, data):\n        for key in data:\n            print \"%s => %s\" % (key, data[key])\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        output_handler = MyOutputHandler\n\n\nwith MyApp() as app:\n    app.run()\n\n    # render data dictionary with the output handler\n    data = dict(foo='bar')\n    app.render(data)\n```\n\nWhich looks like:\n\n```\n$ python test.py\nfoo => bar\n```\n\n\n## Rendering Output Via Templates\n\nAn extremely powerful feature of Cement is the ability to offload console output to a template output handler.  Several are inluded with Cement but not enabled by default (listed above).  The following example shows the use of the Mustache templating langugage, as well as Json output handling.\n\n**myapp.py**\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\n\nclass MyBaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n        description = 'MyApp Does Amazing Things'\n\n    @expose(hide=True)\n    def default(self):\n        data = dict(foo='bar')\n        self.app.render(data, 'default.m')\n\n        # always return the data, some output handlers require this\n        # such as Json/Yaml (which don't use templates)\n        return data\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        base_controller = MyBaseController\n        extensions = ['mustache', 'json']\n\n        # default output handler\n        output_handler = 'mustache'\n\n\nwith MyApp() as app:\n    app.run()\n```\n\n\n**/usr/lib/myapp/templates/default.m**\n\n```\nThis is the output of the MyBaseController.default() command.\n\nThe value of the 'foo' variable is => '{{foo}}'\n```\n\n\nAnd this looks like:\n\n```\n$ python myapp.py\n\nThis is the output of the MyBaseController.default() command.\n\nThe value of the 'foo' variable is => 'bar'\n```\n\n\nOptionally, we can use the `JsonOutputHandler` via `-o json` to trigger just Json output (supressing all other output) using our return dictionary:\n\n```\n$ python myapp.py -o json\n{\"foo\": \"bar\"}\n```\n","source":"2.10/dev/output.md","raw":"---\ntitle: Output\ntype: guide\nversion: \"2.10\"\norder: 8\n---\n\nCement defines an output interface called [IOutput](/{{ version }}/api/core/output.html#cement.core.output.IOutput), as well as the default [DummyOutputHandler](/{{ version }}/api/ext/ext_dummy.html) that implements the interface.  This handler is part of Cement, and actually does nothing to produce output.  Therefore it can be said that by default a Cement application does not handle rendering output to the console, but can if another output handler be used.\n\nPlease note that there may be other handler's that implement the `IOutput` interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.\n\nThe following output handlers are included and maintained with Cement:\n\n- [DummyOutputHandler](/{{ version }}/api/ext/ext_dummy.html)\n- [JsonOutputHandler](/{{ version }}/api/ext/ext_json.html)\n- [YamlOutputHandler](/{{ version }}/api/ext/ext_yaml.html)\n- [GenshiOutputHandler](/{{ version }}/api/ext/ext_genshi.html)\n- [HandlebarsOutputHandler](/{{ version }}/api/ext/ext_handlebars.html)\n- [Jinja2OutputHandler](/{{ version }}/api/ext/ext_jinja2.html)\n- [MustacheOutputHandler](/{{ version }}/api/ext/ext_mustache.html)\n- [TabulateOUtputHandler](/{{ version }}/api/ext/ext_tabulate.html)\n\n\nPlease reference the [IOutput](/{{ version }}/api/core/output.html#cement.core.output.IOutput) interface documentation for writing your own output handler.\n\n\n## Rending Output\n\nCement applications do not need to use an output handler by any means.  Most small applications can get away with simple `print()` statements.  However, anyone who has ever built a bigger application that produces a lot of output will know that this can get ugly very quickly in your code.\n\nUsing an output handler allows the developer to keep their logic clean, and offload the display of relevant data to an output handler, possibly by templates or other means (GUI?).\n\nAn output handler has a `render()` function that takes a data dictionary to produce output.  Some output handlers may also accept a `template` or other parameters that define how output is rendered.  This is easily accessible by the application object.\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    app.run()\n\n    # render data dictionary with the output handler\n    data = dict(foo='bar')\n    app.render(data)\n```\n\nThe above example uses the default output handler, therefore nothing is displayed on screen.  That said, if we write our own quickly we can see something happen:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.output import CementOutputHandler\n\n# Create a custom output handler\nclass MyOutputHandler(CementOutputHandler):\n    class Meta:\n        label = 'myoutput'\n\n    def render(self, data):\n        for key in data:\n            print \"%s => %s\" % (key, data[key])\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        output_handler = MyOutputHandler\n\n\nwith MyApp() as app:\n    app.run()\n\n    # render data dictionary with the output handler\n    data = dict(foo='bar')\n    app.render(data)\n```\n\nWhich looks like:\n\n```\n$ python test.py\nfoo => bar\n```\n\n\n## Rendering Output Via Templates\n\nAn extremely powerful feature of Cement is the ability to offload console output to a template output handler.  Several are inluded with Cement but not enabled by default (listed above).  The following example shows the use of the Mustache templating langugage, as well as Json output handling.\n\n**myapp.py**\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\n\nclass MyBaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n        description = 'MyApp Does Amazing Things'\n\n    @expose(hide=True)\n    def default(self):\n        data = dict(foo='bar')\n        self.app.render(data, 'default.m')\n\n        # always return the data, some output handlers require this\n        # such as Json/Yaml (which don't use templates)\n        return data\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        base_controller = MyBaseController\n        extensions = ['mustache', 'json']\n\n        # default output handler\n        output_handler = 'mustache'\n\n\nwith MyApp() as app:\n    app.run()\n```\n\n\n**/usr/lib/myapp/templates/default.m**\n\n```\nThis is the output of the MyBaseController.default() command.\n\nThe value of the 'foo' variable is => '{{foo}}'\n```\n\n\nAnd this looks like:\n\n```\n$ python myapp.py\n\nThis is the output of the MyBaseController.default() command.\n\nThe value of the 'foo' variable is => 'bar'\n```\n\n\nOptionally, we can use the `JsonOutputHandler` via `-o json` to trigger just Json output (supressing all other output) using our return dictionary:\n\n```\n$ python myapp.py -o json\n{\"foo\": \"bar\"}\n```\n","date":"2017-08-04T03:39:01.000Z","updated":"2017-08-04T03:39:01.000Z","path":"2.10/dev/output.html","_id":"cj5x9ekc10001h9pwthku6gh0","comments":1,"layout":"page","content":"<p>Cement defines an output interface called <a href=\"/2.10/api/core/output.html#cement.core.output.IOutput\">IOutput</a>, as well as the default <a href=\"/2.10/api/ext/ext_dummy.html\">DummyOutputHandler</a> that implements the interface.  This handler is part of Cement, and actually does nothing to produce output.  Therefore it can be said that by default a Cement application does not handle rendering output to the console, but can if another output handler be used.</p>\n<p>Please note that there may be other handler’s that implement the <code>IOutput</code> interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.</p>\n<p>The following output handlers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/ext/ext_dummy.html\">DummyOutputHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_json.html\">JsonOutputHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_yaml.html\">YamlOutputHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_genshi.html\">GenshiOutputHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_handlebars.html\">HandlebarsOutputHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_jinja2.html\">Jinja2OutputHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_mustache.html\">MustacheOutputHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_tabulate.html\">TabulateOUtputHandler</a></li>\n</ul>\n<p>Please reference the <a href=\"/2.10/api/core/output.html#cement.core.output.IOutput\">IOutput</a> interface documentation for writing your own output handler.</p>\n<h2 id=\"Rending-Output\"><a href=\"#Rending-Output\" class=\"headerlink\" title=\"Rending Output\"></a>Rending Output</h2><p>Cement applications do not need to use an output handler by any means.  Most small applications can get away with simple <code>print()</code> statements.  However, anyone who has ever built a bigger application that produces a lot of output will know that this can get ugly very quickly in your code.</p>\n<p>Using an output handler allows the developer to keep their logic clean, and offload the display of relevant data to an output handler, possibly by templates or other means (GUI?).</p>\n<p>An output handler has a <code>render()</code> function that takes a data dictionary to produce output.  Some output handlers may also accept a <code>template</code> or other parameters that define how output is rendered.  This is easily accessible by the application object.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># render data dictionary with the output handler</span></div><div class=\"line\">    data = dict(foo=<span class=\"string\">'bar'</span>)</div><div class=\"line\">    app.render(data)</div></pre></td></tr></table></figure>\n<p>The above example uses the default output handler, therefore nothing is displayed on screen.  That said, if we write our own quickly we can see something happen:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.output <span class=\"keyword\">import</span> CementOutputHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Create a custom output handler</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyOutputHandler</span><span class=\"params\">(CementOutputHandler)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myoutput'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">render</span><span class=\"params\">(self, data)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> data:</div><div class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"%s =&gt; %s\"</span> % (key, data[key])</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        output_handler = MyOutputHandler</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># render data dictionary with the output handler</span></div><div class=\"line\">    data = dict(foo=<span class=\"string\">'bar'</span>)</div><div class=\"line\">    app.render(data)</div></pre></td></tr></table></figure>\n<p>Which looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python test.py</div><div class=\"line\">foo =&gt; bar</div></pre></td></tr></table></figure>\n<h2 id=\"Rendering-Output-Via-Templates\"><a href=\"#Rendering-Output-Via-Templates\" class=\"headerlink\" title=\"Rendering Output Via Templates\"></a>Rendering Output Via Templates</h2><p>An extremely powerful feature of Cement is the ability to offload console output to a template output handler.  Several are inluded with Cement but not enabled by default (listed above).  The following example shows the use of the Mustache templating langugage, as well as Json output handling.</p>\n<p><strong>myapp.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\">        description = <span class=\"string\">'MyApp Does Amazing Things'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        data = dict(foo=<span class=\"string\">'bar'</span>)</div><div class=\"line\">        self.app.render(data, <span class=\"string\">'default.m'</span>)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># always return the data, some output handlers require this</span></div><div class=\"line\">        <span class=\"comment\"># such as Json/Yaml (which don't use templates)</span></div><div class=\"line\">        <span class=\"keyword\">return</span> data</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        base_controller = MyBaseController</div><div class=\"line\">        extensions = [<span class=\"string\">'mustache'</span>, <span class=\"string\">'json'</span>]</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># default output handler</span></div><div class=\"line\">        output_handler = <span class=\"string\">'mustache'</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p><strong>/usr/lib/myapp/templates/default.m</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">This is the output of the MyBaseController.default() command.</div><div class=\"line\"></div><div class=\"line\">The value of the &apos;foo&apos; variable is =&gt; &apos;&#123;&#123;foo&#125;&#125;&apos;</div></pre></td></tr></table></figure>\n<p>And this looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\"></div><div class=\"line\">This is the output of the MyBaseController.default() command.</div><div class=\"line\"></div><div class=\"line\">The value of the &apos;foo&apos; variable is =&gt; &apos;bar&apos;</div></pre></td></tr></table></figure>\n<p>Optionally, we can use the <code>JsonOutputHandler</code> via <code>-o json</code> to trigger just Json output (supressing all other output) using our return dictionary:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py -o json</div><div class=\"line\">&#123;&quot;foo&quot;: &quot;bar&quot;&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>Cement defines an output interface called <a href=\"/2.10/api/core/output.html#cement.core.output.IOutput\">IOutput</a>, as well as the default <a href=\"/2.10/api/ext/ext_dummy.html\">DummyOutputHandler</a> that implements the interface.  This handler is part of Cement, and actually does nothing to produce output.  Therefore it can be said that by default a Cement application does not handle rendering output to the console, but can if another output handler be used.</p>\n<p>Please note that there may be other handler’s that implement the <code>IOutput</code> interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.</p>\n<p>The following output handlers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/ext/ext_dummy.html\">DummyOutputHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_json.html\">JsonOutputHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_yaml.html\">YamlOutputHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_genshi.html\">GenshiOutputHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_handlebars.html\">HandlebarsOutputHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_jinja2.html\">Jinja2OutputHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_mustache.html\">MustacheOutputHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_tabulate.html\">TabulateOUtputHandler</a></li>\n</ul>\n<p>Please reference the <a href=\"/2.10/api/core/output.html#cement.core.output.IOutput\">IOutput</a> interface documentation for writing your own output handler.</p>\n<h2 id=\"Rending-Output\"><a href=\"#Rending-Output\" class=\"headerlink\" title=\"Rending Output\"></a>Rending Output</h2><p>Cement applications do not need to use an output handler by any means.  Most small applications can get away with simple <code>print()</code> statements.  However, anyone who has ever built a bigger application that produces a lot of output will know that this can get ugly very quickly in your code.</p>\n<p>Using an output handler allows the developer to keep their logic clean, and offload the display of relevant data to an output handler, possibly by templates or other means (GUI?).</p>\n<p>An output handler has a <code>render()</code> function that takes a data dictionary to produce output.  Some output handlers may also accept a <code>template</code> or other parameters that define how output is rendered.  This is easily accessible by the application object.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># render data dictionary with the output handler</span></div><div class=\"line\">    data = dict(foo=<span class=\"string\">'bar'</span>)</div><div class=\"line\">    app.render(data)</div></pre></td></tr></table></figure>\n<p>The above example uses the default output handler, therefore nothing is displayed on screen.  That said, if we write our own quickly we can see something happen:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.output <span class=\"keyword\">import</span> CementOutputHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># Create a custom output handler</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyOutputHandler</span><span class=\"params\">(CementOutputHandler)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myoutput'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">render</span><span class=\"params\">(self, data)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> data:</div><div class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"%s =&gt; %s\"</span> % (key, data[key])</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        output_handler = MyOutputHandler</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># render data dictionary with the output handler</span></div><div class=\"line\">    data = dict(foo=<span class=\"string\">'bar'</span>)</div><div class=\"line\">    app.render(data)</div></pre></td></tr></table></figure>\n<p>Which looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python test.py</div><div class=\"line\">foo =&gt; bar</div></pre></td></tr></table></figure>\n<h2 id=\"Rendering-Output-Via-Templates\"><a href=\"#Rendering-Output-Via-Templates\" class=\"headerlink\" title=\"Rendering Output Via Templates\"></a>Rendering Output Via Templates</h2><p>An extremely powerful feature of Cement is the ability to offload console output to a template output handler.  Several are inluded with Cement but not enabled by default (listed above).  The following example shows the use of the Mustache templating langugage, as well as Json output handling.</p>\n<p><strong>myapp.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\">        description = <span class=\"string\">'MyApp Does Amazing Things'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        data = dict(foo=<span class=\"string\">'bar'</span>)</div><div class=\"line\">        self.app.render(data, <span class=\"string\">'default.m'</span>)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># always return the data, some output handlers require this</span></div><div class=\"line\">        <span class=\"comment\"># such as Json/Yaml (which don't use templates)</span></div><div class=\"line\">        <span class=\"keyword\">return</span> data</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        base_controller = MyBaseController</div><div class=\"line\">        extensions = [<span class=\"string\">'mustache'</span>, <span class=\"string\">'json'</span>]</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># default output handler</span></div><div class=\"line\">        output_handler = <span class=\"string\">'mustache'</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p><strong>/usr/lib/myapp/templates/default.m</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">This is the output of the MyBaseController.default() command.</div><div class=\"line\"></div><div class=\"line\">The value of the &apos;foo&apos; variable is =&gt; &apos;&#123;&#123;foo&#125;&#125;&apos;</div></pre></td></tr></table></figure>\n<p>And this looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\"></div><div class=\"line\">This is the output of the MyBaseController.default() command.</div><div class=\"line\"></div><div class=\"line\">The value of the &apos;foo&apos; variable is =&gt; &apos;bar&apos;</div></pre></td></tr></table></figure>\n<p>Optionally, we can use the <code>JsonOutputHandler</code> via <code>-o json</code> to trigger just Json output (supressing all other output) using our return dictionary:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py -o json</div><div class=\"line\">&#123;&quot;foo&quot;: &quot;bar&quot;&#125;</div></pre></td></tr></table></figure>\n"},{"title":"Application Controllers","type":"guide","version":"2.10","order":9,"_content":"\nCement defines a controller interface called [IController](/{{ version }}/api/core/controller.html#cement.core.controller.IController), but does not enable any default handlers that implement the interface.\n\nUsing application controllers is not necessary, but enables rapid development by wrapping pieces of the framework like adding arguments, and linking commands with functions to name a few.  The examples below use the `CementBaseController` for examples.  It is important to note that this class also requires that your application's argument_handler be the `ArgParseArgumentHandler`.  That said, the `CementBaseController` is relatively useless when used directly and therefore should be used as a Base class to create your own application controllers from.\n\nThe following controllers are included and maintained with Cement:\n\n- [CementBaseController](/{{ version }}/api/core/controller.html#cement.core.controller.CementBaseController)\n\n\nPlease reference the [IController](/{{ version }}/api/core/controller.html#cement.core.controller.IController) interface documentation for writing your own controller.\n\n\n## Example Application Base Controller\n\nThis example demonstrates the use of application controllers that handle command dispatch and rapid development.\n\n```python\nfrom cement.core import backend\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\n# define an application base controller\nclass MyAppBaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n        description = \"My Application does amazing things!\"\n        epilog = \"This is the text at the bottom of --help.\"\n\n        config_defaults = dict(\n            foo='bar',\n            some_other_option='my default value',\n            )\n\n        arguments = [\n            (['-f', '--foo'],\n             dict(action='store', help='the notorious foo option')),\n            (['-C'],\n             dict(action='store_true', help='the big c option')),\n            ]\n\n    @expose(hide=True, aliases=['run'])\n    def default(self):\n        self.app.log.info('Inside base.default function.')\n        if self.app.pargs.foo:\n            self.app.log.info(\"Recieved option 'foo' with value '%s'.\" % \\\n                          self.app.pargs.foo)\n\n    @expose(help=\"this command does relatively nothing useful.\")\n    def command1(self):\n        self.app.log.info(\"Inside base.command1 function.\")\n\n    @expose(aliases=['cmd2'], help=\"more of nothing.\")\n    def command2(self):\n        self.app.log.info(\"Inside base.command2 function.\")\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'example'\n        base_controller = MyAppBaseController\n\n\nwith MyApp() as app:\n    app.run()\n```\n\n\nAs you can see, we're able to build out the core functionality of our app\nvia a controller class.  Lets see what this looks like:\n\n```\n\n$ python example.py --help\nusage: example.py <CMD> -opt1 --opt2=VAL [arg1] [arg2] ...\n\nMy Application does amazing things!\n\ncommands:\n\n  command1\n    this command does relatively nothing useful.\n\n  command2 (aliases: cmd2)\n    more of nothing.\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n  --foo FOO   the notorious foo option\n  -C          the big C option\n\nThis is the text at the bottom of --help.\n\n\n$ python example2.py\nINFO: Inside base.default function.\n\n$ python example2.py command1\nINFO: Inside base.command1 function.\n\n$ python example2.py cmd2\nINFO: Inside base.command2 function.\n```\n\n\n## Additional Controllers and Namespaces\n\nAny number of additional controllers can be added to your application after a base controller is created.  Additionally, these controllers can be ``stacked`` onto the base controller (or any other controller) in one of two ways:\n\n- `embedded` - The controllers commands and arguments are included under the parent controllers name space.\n- `nested` - The controller label is added as a sub-command under the parent controllers namespace (effectively this is a sub-command with additional sub-sub-commands under it)\n\n\nFor example, The `base` controller is accessed when calling `example.py` directly. Any commands under the `base` controller would be accessible as `example.py <cmd1>`, or `example.py <cmd2>`, etc.  An `embedded` controller will merge its commands and options into the `base` controller namespace and appear to be part of the base controller... meaning you would still access the `embedded` controllers commands as `example.py <embedded_cmd1>`, etc (same for options).\n\nFor `nested` controllers, a prefix will be created with that controllers label under its parents namespace.  Therefore you would access that controllers commands and options as `example.py <controller_label> <controller_cmd1>`.\n\nSee the [Multiple Stacked Controllers](/{{ version }}/examples/multiple_stacked_controllers.html) example for more help.\n","source":"2.10/dev/controllers.md","raw":"---\ntitle: Application Controllers\ntype: guide\nversion: \"2.10\"\norder: 9\n---\n\nCement defines a controller interface called [IController](/{{ version }}/api/core/controller.html#cement.core.controller.IController), but does not enable any default handlers that implement the interface.\n\nUsing application controllers is not necessary, but enables rapid development by wrapping pieces of the framework like adding arguments, and linking commands with functions to name a few.  The examples below use the `CementBaseController` for examples.  It is important to note that this class also requires that your application's argument_handler be the `ArgParseArgumentHandler`.  That said, the `CementBaseController` is relatively useless when used directly and therefore should be used as a Base class to create your own application controllers from.\n\nThe following controllers are included and maintained with Cement:\n\n- [CementBaseController](/{{ version }}/api/core/controller.html#cement.core.controller.CementBaseController)\n\n\nPlease reference the [IController](/{{ version }}/api/core/controller.html#cement.core.controller.IController) interface documentation for writing your own controller.\n\n\n## Example Application Base Controller\n\nThis example demonstrates the use of application controllers that handle command dispatch and rapid development.\n\n```python\nfrom cement.core import backend\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\n# define an application base controller\nclass MyAppBaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n        description = \"My Application does amazing things!\"\n        epilog = \"This is the text at the bottom of --help.\"\n\n        config_defaults = dict(\n            foo='bar',\n            some_other_option='my default value',\n            )\n\n        arguments = [\n            (['-f', '--foo'],\n             dict(action='store', help='the notorious foo option')),\n            (['-C'],\n             dict(action='store_true', help='the big c option')),\n            ]\n\n    @expose(hide=True, aliases=['run'])\n    def default(self):\n        self.app.log.info('Inside base.default function.')\n        if self.app.pargs.foo:\n            self.app.log.info(\"Recieved option 'foo' with value '%s'.\" % \\\n                          self.app.pargs.foo)\n\n    @expose(help=\"this command does relatively nothing useful.\")\n    def command1(self):\n        self.app.log.info(\"Inside base.command1 function.\")\n\n    @expose(aliases=['cmd2'], help=\"more of nothing.\")\n    def command2(self):\n        self.app.log.info(\"Inside base.command2 function.\")\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'example'\n        base_controller = MyAppBaseController\n\n\nwith MyApp() as app:\n    app.run()\n```\n\n\nAs you can see, we're able to build out the core functionality of our app\nvia a controller class.  Lets see what this looks like:\n\n```\n\n$ python example.py --help\nusage: example.py <CMD> -opt1 --opt2=VAL [arg1] [arg2] ...\n\nMy Application does amazing things!\n\ncommands:\n\n  command1\n    this command does relatively nothing useful.\n\n  command2 (aliases: cmd2)\n    more of nothing.\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n  --foo FOO   the notorious foo option\n  -C          the big C option\n\nThis is the text at the bottom of --help.\n\n\n$ python example2.py\nINFO: Inside base.default function.\n\n$ python example2.py command1\nINFO: Inside base.command1 function.\n\n$ python example2.py cmd2\nINFO: Inside base.command2 function.\n```\n\n\n## Additional Controllers and Namespaces\n\nAny number of additional controllers can be added to your application after a base controller is created.  Additionally, these controllers can be ``stacked`` onto the base controller (or any other controller) in one of two ways:\n\n- `embedded` - The controllers commands and arguments are included under the parent controllers name space.\n- `nested` - The controller label is added as a sub-command under the parent controllers namespace (effectively this is a sub-command with additional sub-sub-commands under it)\n\n\nFor example, The `base` controller is accessed when calling `example.py` directly. Any commands under the `base` controller would be accessible as `example.py <cmd1>`, or `example.py <cmd2>`, etc.  An `embedded` controller will merge its commands and options into the `base` controller namespace and appear to be part of the base controller... meaning you would still access the `embedded` controllers commands as `example.py <embedded_cmd1>`, etc (same for options).\n\nFor `nested` controllers, a prefix will be created with that controllers label under its parents namespace.  Therefore you would access that controllers commands and options as `example.py <controller_label> <controller_cmd1>`.\n\nSee the [Multiple Stacked Controllers](/{{ version }}/examples/multiple_stacked_controllers.html) example for more help.\n","date":"2017-08-04T04:17:56.000Z","updated":"2017-08-04T04:17:56.000Z","path":"2.10/dev/controllers.html","_id":"cj5xcguc2000060pw5hl6sm72","comments":1,"layout":"page","content":"<p>Cement defines a controller interface called <a href=\"/2.10/api/core/controller.html#cement.core.controller.IController\">IController</a>, but does not enable any default handlers that implement the interface.</p>\n<p>Using application controllers is not necessary, but enables rapid development by wrapping pieces of the framework like adding arguments, and linking commands with functions to name a few.  The examples below use the <code>CementBaseController</code> for examples.  It is important to note that this class also requires that your application’s argument_handler be the <code>ArgParseArgumentHandler</code>.  That said, the <code>CementBaseController</code> is relatively useless when used directly and therefore should be used as a Base class to create your own application controllers from.</p>\n<p>The following controllers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/core/controller.html#cement.core.controller.CementBaseController\">CementBaseController</a></li>\n</ul>\n<p>Please reference the <a href=\"/2.10/api/core/controller.html#cement.core.controller.IController\">IController</a> interface documentation for writing your own controller.</p>\n<h2 id=\"Example-Application-Base-Controller\"><a href=\"#Example-Application-Base-Controller\" class=\"headerlink\" title=\"Example Application Base Controller\"></a>Example Application Base Controller</h2><p>This example demonstrates the use of application controllers that handle command dispatch and rapid development.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> backend</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># define an application base controller</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAppBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\">        description = <span class=\"string\">\"My Application does amazing things!\"</span></div><div class=\"line\">        epilog = <span class=\"string\">\"This is the text at the bottom of --help.\"</span></div><div class=\"line\"></div><div class=\"line\">        config_defaults = dict(</div><div class=\"line\">            foo=<span class=\"string\">'bar'</span>,</div><div class=\"line\">            some_other_option=<span class=\"string\">'my default value'</span>,</div><div class=\"line\">            )</div><div class=\"line\"></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'-f'</span>, <span class=\"string\">'--foo'</span>],</div><div class=\"line\">             dict(action=<span class=\"string\">'store'</span>, help=<span class=\"string\">'the notorious foo option'</span>)),</div><div class=\"line\">            ([<span class=\"string\">'-C'</span>],</div><div class=\"line\">             dict(action=<span class=\"string\">'store_true'</span>, help=<span class=\"string\">'the big c option'</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True, aliases=['run'])</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app.log.info(<span class=\"string\">'Inside base.default function.'</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> self.app.pargs.foo:</div><div class=\"line\">            self.app.log.info(<span class=\"string\">\"Recieved option 'foo' with value '%s'.\"</span> % \\</div><div class=\"line\">                          self.app.pargs.foo)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"this command does relatively nothing useful.\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app.log.info(<span class=\"string\">\"Inside base.command1 function.\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(aliases=['cmd2'], help=\"more of nothing.\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command2</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app.log.info(<span class=\"string\">\"Inside base.command2 function.\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'example'</span></div><div class=\"line\">        base_controller = MyAppBaseController</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>As you can see, we’re able to build out the core functionality of our app<br>via a controller class.  Lets see what this looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">$ python example.py --help</div><div class=\"line\">usage: example.py &lt;CMD&gt; -opt1 --opt2=VAL [arg1] [arg2] ...</div><div class=\"line\"></div><div class=\"line\">My Application does amazing things!</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  command1</div><div class=\"line\">    this command does relatively nothing useful.</div><div class=\"line\"></div><div class=\"line\">  command2 (aliases: cmd2)</div><div class=\"line\">    more of nothing.</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\">  --foo FOO   the notorious foo option</div><div class=\"line\">  -C          the big C option</div><div class=\"line\"></div><div class=\"line\">This is the text at the bottom of --help.</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python example2.py</div><div class=\"line\">INFO: Inside base.default function.</div><div class=\"line\"></div><div class=\"line\">$ python example2.py command1</div><div class=\"line\">INFO: Inside base.command1 function.</div><div class=\"line\"></div><div class=\"line\">$ python example2.py cmd2</div><div class=\"line\">INFO: Inside base.command2 function.</div></pre></td></tr></table></figure>\n<h2 id=\"Additional-Controllers-and-Namespaces\"><a href=\"#Additional-Controllers-and-Namespaces\" class=\"headerlink\" title=\"Additional Controllers and Namespaces\"></a>Additional Controllers and Namespaces</h2><p>Any number of additional controllers can be added to your application after a base controller is created.  Additionally, these controllers can be <code>stacked</code> onto the base controller (or any other controller) in one of two ways:</p>\n<ul>\n<li><code>embedded</code> - The controllers commands and arguments are included under the parent controllers name space.</li>\n<li><code>nested</code> - The controller label is added as a sub-command under the parent controllers namespace (effectively this is a sub-command with additional sub-sub-commands under it)</li>\n</ul>\n<p>For example, The <code>base</code> controller is accessed when calling <code>example.py</code> directly. Any commands under the <code>base</code> controller would be accessible as <code>example.py &lt;cmd1&gt;</code>, or <code>example.py &lt;cmd2&gt;</code>, etc.  An <code>embedded</code> controller will merge its commands and options into the <code>base</code> controller namespace and appear to be part of the base controller… meaning you would still access the <code>embedded</code> controllers commands as <code>example.py &lt;embedded_cmd1&gt;</code>, etc (same for options).</p>\n<p>For <code>nested</code> controllers, a prefix will be created with that controllers label under its parents namespace.  Therefore you would access that controllers commands and options as <code>example.py &lt;controller_label&gt; &lt;controller_cmd1&gt;</code>.</p>\n<p>See the <a href=\"/2.10/examples/multiple_stacked_controllers.html\">Multiple Stacked Controllers</a> example for more help.</p>\n","excerpt":"","more":"<p>Cement defines a controller interface called <a href=\"/2.10/api/core/controller.html#cement.core.controller.IController\">IController</a>, but does not enable any default handlers that implement the interface.</p>\n<p>Using application controllers is not necessary, but enables rapid development by wrapping pieces of the framework like adding arguments, and linking commands with functions to name a few.  The examples below use the <code>CementBaseController</code> for examples.  It is important to note that this class also requires that your application’s argument_handler be the <code>ArgParseArgumentHandler</code>.  That said, the <code>CementBaseController</code> is relatively useless when used directly and therefore should be used as a Base class to create your own application controllers from.</p>\n<p>The following controllers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/core/controller.html#cement.core.controller.CementBaseController\">CementBaseController</a></li>\n</ul>\n<p>Please reference the <a href=\"/2.10/api/core/controller.html#cement.core.controller.IController\">IController</a> interface documentation for writing your own controller.</p>\n<h2 id=\"Example-Application-Base-Controller\"><a href=\"#Example-Application-Base-Controller\" class=\"headerlink\" title=\"Example Application Base Controller\"></a>Example Application Base Controller</h2><p>This example demonstrates the use of application controllers that handle command dispatch and rapid development.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> backend</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># define an application base controller</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAppBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\">        description = <span class=\"string\">\"My Application does amazing things!\"</span></div><div class=\"line\">        epilog = <span class=\"string\">\"This is the text at the bottom of --help.\"</span></div><div class=\"line\"></div><div class=\"line\">        config_defaults = dict(</div><div class=\"line\">            foo=<span class=\"string\">'bar'</span>,</div><div class=\"line\">            some_other_option=<span class=\"string\">'my default value'</span>,</div><div class=\"line\">            )</div><div class=\"line\"></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'-f'</span>, <span class=\"string\">'--foo'</span>],</div><div class=\"line\">             dict(action=<span class=\"string\">'store'</span>, help=<span class=\"string\">'the notorious foo option'</span>)),</div><div class=\"line\">            ([<span class=\"string\">'-C'</span>],</div><div class=\"line\">             dict(action=<span class=\"string\">'store_true'</span>, help=<span class=\"string\">'the big c option'</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True, aliases=['run'])</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app.log.info(<span class=\"string\">'Inside base.default function.'</span>)</div><div class=\"line\">        <span class=\"keyword\">if</span> self.app.pargs.foo:</div><div class=\"line\">            self.app.log.info(<span class=\"string\">\"Recieved option 'foo' with value '%s'.\"</span> % \\</div><div class=\"line\">                          self.app.pargs.foo)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"this command does relatively nothing useful.\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app.log.info(<span class=\"string\">\"Inside base.command1 function.\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(aliases=['cmd2'], help=\"more of nothing.\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command2</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        self.app.log.info(<span class=\"string\">\"Inside base.command2 function.\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'example'</span></div><div class=\"line\">        base_controller = MyAppBaseController</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>As you can see, we’re able to build out the core functionality of our app<br>via a controller class.  Lets see what this looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">$ python example.py --help</div><div class=\"line\">usage: example.py &lt;CMD&gt; -opt1 --opt2=VAL [arg1] [arg2] ...</div><div class=\"line\"></div><div class=\"line\">My Application does amazing things!</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  command1</div><div class=\"line\">    this command does relatively nothing useful.</div><div class=\"line\"></div><div class=\"line\">  command2 (aliases: cmd2)</div><div class=\"line\">    more of nothing.</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\">  --foo FOO   the notorious foo option</div><div class=\"line\">  -C          the big C option</div><div class=\"line\"></div><div class=\"line\">This is the text at the bottom of --help.</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python example2.py</div><div class=\"line\">INFO: Inside base.default function.</div><div class=\"line\"></div><div class=\"line\">$ python example2.py command1</div><div class=\"line\">INFO: Inside base.command1 function.</div><div class=\"line\"></div><div class=\"line\">$ python example2.py cmd2</div><div class=\"line\">INFO: Inside base.command2 function.</div></pre></td></tr></table></figure>\n<h2 id=\"Additional-Controllers-and-Namespaces\"><a href=\"#Additional-Controllers-and-Namespaces\" class=\"headerlink\" title=\"Additional Controllers and Namespaces\"></a>Additional Controllers and Namespaces</h2><p>Any number of additional controllers can be added to your application after a base controller is created.  Additionally, these controllers can be <code>stacked</code> onto the base controller (or any other controller) in one of two ways:</p>\n<ul>\n<li><code>embedded</code> - The controllers commands and arguments are included under the parent controllers name space.</li>\n<li><code>nested</code> - The controller label is added as a sub-command under the parent controllers namespace (effectively this is a sub-command with additional sub-sub-commands under it)</li>\n</ul>\n<p>For example, The <code>base</code> controller is accessed when calling <code>example.py</code> directly. Any commands under the <code>base</code> controller would be accessible as <code>example.py &lt;cmd1&gt;</code>, or <code>example.py &lt;cmd2&gt;</code>, etc.  An <code>embedded</code> controller will merge its commands and options into the <code>base</code> controller namespace and appear to be part of the base controller… meaning you would still access the <code>embedded</code> controllers commands as <code>example.py &lt;embedded_cmd1&gt;</code>, etc (same for options).</p>\n<p>For <code>nested</code> controllers, a prefix will be created with that controllers label under its parents namespace.  Therefore you would access that controllers commands and options as <code>example.py &lt;controller_label&gt; &lt;controller_cmd1&gt;</code>.</p>\n<p>See the <a href=\"/2.10/examples/multiple_stacked_controllers.html\">Multiple Stacked Controllers</a> example for more help.</p>\n"},{"title":"Framework Extensions","type":"guide","version":"2.10","order":10,"_content":"\nCement defines an extension interface called [IExtension](/{{ version }}/api/core/extension.html#cement.core.extension.IExtension), as well as the default [CementExtensionHandler](/{{ version }}/api/core/extension.html#cement.core.extension.CementExtensionHandler) that implements the interface.  Its purpose is to manage loading framework extensions and making them usable by the application.  Extensions are similar to [Application Plugins](/{{ version }}/dev/plugins.html), but at the framework level (application agnostic).\n\nPlease note that there may be other handler's that implement the `IExtension` interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.\n\nThe following extension handlers are included and maintained with Cement:\n\n- [CementExtensionHandler](/{{ version }}/api/core/extension.html#cement.core.extension.CementExtensionHandler)\n\n\nPlease reference the [IExtension](/{{ version }}/api/core/extension.html#cement.core.extension.IExtension) interface documentation for writing your own extension handler.\n\n<p class=\"tip-warn\">\nAs of Cement 2.1.3, optional extensions with external dependencies are now being shipped along with mainline sources.  This means, that Cement Core continues to maintain a 100% zero dependency policy, however Framework Extensions *can* rely on external deps.  It is the responsibility of the application developer to include these dependencies in their application (as the Cement package does not include these dependencies).</p>\n\n\n## Extension Configuration Settings\n\nThe following Meta settings are honored under the CementApp:\n\n- **extension_handler** - A handler class that implements the `IExtension` interface.  This can be a string (label of a registered handler), an uninstantiated class, or an instantiated class object. Default: `CementExtensionHandler`.\n\n- **core_extensions** - List of Cement core extensions.  These are generally required by Cement and should only be modified if you know what you're doing.  Use `extensions` to add to this list, rather than overriding core extensions.  That said if you want to prune down your application, you can remove core extensions if they are not necessary (for example if using your own log handler extension you likely don't want/need `LoggingLogHandler` to be registered, but removing it really doesn't buy you much).\n\n- **extensions** - List of additional framework extensions to load.\n\n\nThe following example shows how to alter these settings for your application:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.ext import CementExtensionHandler\n\nclass MyExtensionHandler(CementExtensionHandler):\n    pass\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        extension_handler = MyExtensionHandler\n        extensions = ['myapp.ext.ext_something_fancy']\n\nwith MyApp() as app:\n    app.run()\n```\n\n\n## Creating an Extension\n\nThe extension system is a mechanism for dynamically loading code to extend the functionality of the framework.  In general, this includes the registration of interfaces, handlers, and/or hooks.\n\nThe following is an example extension that provides an Output Handler.  We will assume this extension is part of our `myapp` application, and the extension module will be `myapp.ext.ext_myoutput` (or whatever you want to call it).\n\n```python\nfrom cement.core import handler, output\nfrom cement.utils.misc import minimal_logger\n\nLOG = minimal_logger(__name__)\n\nclass MyOutputHandler(output.CementOutputHandler):\n    class Meta:\n        label = 'myoutput'\n\n    def render(self, data_dict, template=None):\n        LOG.debug(\"Rendering output via MyAppOutputHandler\")\n        for key in data_dict.keys():\n            print \"%s => %s\" % (key, data_dict[key])\n\ndef load(app):\n    handler.register(MyOutputHandler)\n```\n\n\nTake note of two things.  One is, the `LOG` we are using is from `cement.utils.misc.minimal_logger(__name__)`.  Framework extensions do not use the application log handler, ever.  Use the `minimal_logger()`, and only log to 'DEBUG' (recommended).\n\nSecondly, in our extension file we need to define any interfaces, and register handlers and/or hooks if necessary.  In this example we only needed to register our output handler (which happens when the extension is loaded by the application).\n\nLast, notice that all `bootstrapping` code goes in a `load()` function. This is where registration of handlers/hooks should happen.  For convenience, and certain edge cases, the `app` object is passed here in its current state at the time that `load()` is called.\n\nYou will notice that extensions are essentially the same as application plugins, however the difference is both when/how the code is loaded, as well as the purpose of that code.  Framework extensions add functionality to the framework for the application to utilize, where application plugins extend the functionality of the application itself.\n\n\n## Loading an Extension\n\nExtensions are loaded when `setup()` is called on an application.  Cement automatically loads all extensions listed under the applications `core_extensions` and `extensions` meta options.\n\nTo load the above example into our application, we just add it to the list of `extensions` (not core extensions).  Lets assume the extension code lives in `myapp/ext/ext_something_fancy.py`:\n\n```python\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        extensions = ['myapp.ext.ext_something_fancy']\n\nwith MyApp() as app:\n    app.run()\n```\n\n\nNote that Cement provides a shortcut for Cement extensions.  For example, the following:\n\n```python\nCementApp('myapp', extensions=['json', 'daemon'])\n```\n\nIs equivalent to:\n\n```python\nCementApp('myapp',\n    extensions=[\n        'cement.ext.ext_json',\n        'cement.ext.ext_daemon',\n        ]\n    )\n```\n\nFor non-cement extensions you need to use the full python 'dotted' module path.\n\n\n## Loading Extensions Via a Configuration File\n\nSome use cases require that end-users are able to modify what framework extensions are loaded via a configuration file.  The following gives an example of how an application can support an optional `extensions` configuration setting that will **append** extensions to `CementApp.Meta.extensions`.\n\nNote that extensions loaded in this way will happen **after** the config handler is setup.  Normally, extensions are loaded just before the configuration files are read.  Therefore, some extensions may not be compatible with this method if they attempt to perform any actions before `app.setup()` completes (such as in early framework hooks before configuration files are loaded).\n\n**myapp.py**\n\n```python\n\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        config_files = [\n            './myapp.conf',\n            ]\n\ndef main():\n    with MyApp() as app:\n        app.run()\n\nif __name__ == '__main__':\n    main()\n```\n\n\n**myapp.conf**\n\n```\n[myapp]\nextensions = json, yaml\n```\n\n\nWhich looks like:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nMyApp Does Amazing Things\n\noptional arguments:\n  -h, --help     show this help message and exit\n  --debug        toggle debug output\n  --quiet        suppress all output\n  -o {json,yaml} output format\n```\n\n\nNote the `-o` command line option that are provided by Cement allowing the end user to override the output handler with the available/loaded extensions (that support this feature).\n","source":"2.10/dev/extensions.md","raw":"---\ntitle: Framework Extensions\ntype: guide\nversion: \"2.10\"\norder: 10\n---\n\nCement defines an extension interface called [IExtension](/{{ version }}/api/core/extension.html#cement.core.extension.IExtension), as well as the default [CementExtensionHandler](/{{ version }}/api/core/extension.html#cement.core.extension.CementExtensionHandler) that implements the interface.  Its purpose is to manage loading framework extensions and making them usable by the application.  Extensions are similar to [Application Plugins](/{{ version }}/dev/plugins.html), but at the framework level (application agnostic).\n\nPlease note that there may be other handler's that implement the `IExtension` interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.\n\nThe following extension handlers are included and maintained with Cement:\n\n- [CementExtensionHandler](/{{ version }}/api/core/extension.html#cement.core.extension.CementExtensionHandler)\n\n\nPlease reference the [IExtension](/{{ version }}/api/core/extension.html#cement.core.extension.IExtension) interface documentation for writing your own extension handler.\n\n<p class=\"tip-warn\">\nAs of Cement 2.1.3, optional extensions with external dependencies are now being shipped along with mainline sources.  This means, that Cement Core continues to maintain a 100% zero dependency policy, however Framework Extensions *can* rely on external deps.  It is the responsibility of the application developer to include these dependencies in their application (as the Cement package does not include these dependencies).</p>\n\n\n## Extension Configuration Settings\n\nThe following Meta settings are honored under the CementApp:\n\n- **extension_handler** - A handler class that implements the `IExtension` interface.  This can be a string (label of a registered handler), an uninstantiated class, or an instantiated class object. Default: `CementExtensionHandler`.\n\n- **core_extensions** - List of Cement core extensions.  These are generally required by Cement and should only be modified if you know what you're doing.  Use `extensions` to add to this list, rather than overriding core extensions.  That said if you want to prune down your application, you can remove core extensions if they are not necessary (for example if using your own log handler extension you likely don't want/need `LoggingLogHandler` to be registered, but removing it really doesn't buy you much).\n\n- **extensions** - List of additional framework extensions to load.\n\n\nThe following example shows how to alter these settings for your application:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.ext import CementExtensionHandler\n\nclass MyExtensionHandler(CementExtensionHandler):\n    pass\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        extension_handler = MyExtensionHandler\n        extensions = ['myapp.ext.ext_something_fancy']\n\nwith MyApp() as app:\n    app.run()\n```\n\n\n## Creating an Extension\n\nThe extension system is a mechanism for dynamically loading code to extend the functionality of the framework.  In general, this includes the registration of interfaces, handlers, and/or hooks.\n\nThe following is an example extension that provides an Output Handler.  We will assume this extension is part of our `myapp` application, and the extension module will be `myapp.ext.ext_myoutput` (or whatever you want to call it).\n\n```python\nfrom cement.core import handler, output\nfrom cement.utils.misc import minimal_logger\n\nLOG = minimal_logger(__name__)\n\nclass MyOutputHandler(output.CementOutputHandler):\n    class Meta:\n        label = 'myoutput'\n\n    def render(self, data_dict, template=None):\n        LOG.debug(\"Rendering output via MyAppOutputHandler\")\n        for key in data_dict.keys():\n            print \"%s => %s\" % (key, data_dict[key])\n\ndef load(app):\n    handler.register(MyOutputHandler)\n```\n\n\nTake note of two things.  One is, the `LOG` we are using is from `cement.utils.misc.minimal_logger(__name__)`.  Framework extensions do not use the application log handler, ever.  Use the `minimal_logger()`, and only log to 'DEBUG' (recommended).\n\nSecondly, in our extension file we need to define any interfaces, and register handlers and/or hooks if necessary.  In this example we only needed to register our output handler (which happens when the extension is loaded by the application).\n\nLast, notice that all `bootstrapping` code goes in a `load()` function. This is where registration of handlers/hooks should happen.  For convenience, and certain edge cases, the `app` object is passed here in its current state at the time that `load()` is called.\n\nYou will notice that extensions are essentially the same as application plugins, however the difference is both when/how the code is loaded, as well as the purpose of that code.  Framework extensions add functionality to the framework for the application to utilize, where application plugins extend the functionality of the application itself.\n\n\n## Loading an Extension\n\nExtensions are loaded when `setup()` is called on an application.  Cement automatically loads all extensions listed under the applications `core_extensions` and `extensions` meta options.\n\nTo load the above example into our application, we just add it to the list of `extensions` (not core extensions).  Lets assume the extension code lives in `myapp/ext/ext_something_fancy.py`:\n\n```python\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        extensions = ['myapp.ext.ext_something_fancy']\n\nwith MyApp() as app:\n    app.run()\n```\n\n\nNote that Cement provides a shortcut for Cement extensions.  For example, the following:\n\n```python\nCementApp('myapp', extensions=['json', 'daemon'])\n```\n\nIs equivalent to:\n\n```python\nCementApp('myapp',\n    extensions=[\n        'cement.ext.ext_json',\n        'cement.ext.ext_daemon',\n        ]\n    )\n```\n\nFor non-cement extensions you need to use the full python 'dotted' module path.\n\n\n## Loading Extensions Via a Configuration File\n\nSome use cases require that end-users are able to modify what framework extensions are loaded via a configuration file.  The following gives an example of how an application can support an optional `extensions` configuration setting that will **append** extensions to `CementApp.Meta.extensions`.\n\nNote that extensions loaded in this way will happen **after** the config handler is setup.  Normally, extensions are loaded just before the configuration files are read.  Therefore, some extensions may not be compatible with this method if they attempt to perform any actions before `app.setup()` completes (such as in early framework hooks before configuration files are loaded).\n\n**myapp.py**\n\n```python\n\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        config_files = [\n            './myapp.conf',\n            ]\n\ndef main():\n    with MyApp() as app:\n        app.run()\n\nif __name__ == '__main__':\n    main()\n```\n\n\n**myapp.conf**\n\n```\n[myapp]\nextensions = json, yaml\n```\n\n\nWhich looks like:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nMyApp Does Amazing Things\n\noptional arguments:\n  -h, --help     show this help message and exit\n  --debug        toggle debug output\n  --quiet        suppress all output\n  -o {json,yaml} output format\n```\n\n\nNote the `-o` command line option that are provided by Cement allowing the end user to override the output handler with the available/loaded extensions (that support this feature).\n","date":"2017-08-04T05:05:51.000Z","updated":"2017-08-04T05:05:51.000Z","path":"2.10/dev/extensions.html","_id":"cj5xdc737000160pwrrb24chc","comments":1,"layout":"page","content":"<p>Cement defines an extension interface called <a href=\"/2.10/api/core/extension.html#cement.core.extension.IExtension\">IExtension</a>, as well as the default <a href=\"/2.10/api/core/extension.html#cement.core.extension.CementExtensionHandler\">CementExtensionHandler</a> that implements the interface.  Its purpose is to manage loading framework extensions and making them usable by the application.  Extensions are similar to <a href=\"/2.10/dev/plugins.html\">Application Plugins</a>, but at the framework level (application agnostic).</p>\n<p>Please note that there may be other handler’s that implement the <code>IExtension</code> interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.</p>\n<p>The following extension handlers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/core/extension.html#cement.core.extension.CementExtensionHandler\">CementExtensionHandler</a></li>\n</ul>\n<p>Please reference the <a href=\"/2.10/api/core/extension.html#cement.core.extension.IExtension\">IExtension</a> interface documentation for writing your own extension handler.</p>\n<p class=\"tip-warn\"><br>As of Cement 2.1.3, optional extensions with external dependencies are now being shipped along with mainline sources.  This means, that Cement Core continues to maintain a 100% zero dependency policy, however Framework Extensions <em>can</em> rely on external deps.  It is the responsibility of the application developer to include these dependencies in their application (as the Cement package does not include these dependencies).</p>\n\n\n<h2 id=\"Extension-Configuration-Settings\"><a href=\"#Extension-Configuration-Settings\" class=\"headerlink\" title=\"Extension Configuration Settings\"></a>Extension Configuration Settings</h2><p>The following Meta settings are honored under the CementApp:</p>\n<ul>\n<li><p><strong>extension_handler</strong> - A handler class that implements the <code>IExtension</code> interface.  This can be a string (label of a registered handler), an uninstantiated class, or an instantiated class object. Default: <code>CementExtensionHandler</code>.</p>\n</li>\n<li><p><strong>core_extensions</strong> - List of Cement core extensions.  These are generally required by Cement and should only be modified if you know what you’re doing.  Use <code>extensions</code> to add to this list, rather than overriding core extensions.  That said if you want to prune down your application, you can remove core extensions if they are not necessary (for example if using your own log handler extension you likely don’t want/need <code>LoggingLogHandler</code> to be registered, but removing it really doesn’t buy you much).</p>\n</li>\n<li><p><strong>extensions</strong> - List of additional framework extensions to load.</p>\n</li>\n</ul>\n<p>The following example shows how to alter these settings for your application:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.ext <span class=\"keyword\">import</span> CementExtensionHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyExtensionHandler</span><span class=\"params\">(CementExtensionHandler)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extension_handler = MyExtensionHandler</div><div class=\"line\">        extensions = [<span class=\"string\">'myapp.ext.ext_something_fancy'</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<h2 id=\"Creating-an-Extension\"><a href=\"#Creating-an-Extension\" class=\"headerlink\" title=\"Creating an Extension\"></a>Creating an Extension</h2><p>The extension system is a mechanism for dynamically loading code to extend the functionality of the framework.  In general, this includes the registration of interfaces, handlers, and/or hooks.</p>\n<p>The following is an example extension that provides an Output Handler.  We will assume this extension is part of our <code>myapp</code> application, and the extension module will be <code>myapp.ext.ext_myoutput</code> (or whatever you want to call it).</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> handler, output</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> minimal_logger</div><div class=\"line\"></div><div class=\"line\">LOG = minimal_logger(__name__)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyOutputHandler</span><span class=\"params\">(output.CementOutputHandler)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myoutput'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">render</span><span class=\"params\">(self, data_dict, template=None)</span>:</span></div><div class=\"line\">        LOG.debug(<span class=\"string\">\"Rendering output via MyAppOutputHandler\"</span>)</div><div class=\"line\">        <span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> data_dict.keys():</div><div class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"%s =&gt; %s\"</span> % (key, data_dict[key])</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    handler.register(MyOutputHandler)</div></pre></td></tr></table></figure>\n<p>Take note of two things.  One is, the <code>LOG</code> we are using is from <code>cement.utils.misc.minimal_logger(__name__)</code>.  Framework extensions do not use the application log handler, ever.  Use the <code>minimal_logger()</code>, and only log to ‘DEBUG’ (recommended).</p>\n<p>Secondly, in our extension file we need to define any interfaces, and register handlers and/or hooks if necessary.  In this example we only needed to register our output handler (which happens when the extension is loaded by the application).</p>\n<p>Last, notice that all <code>bootstrapping</code> code goes in a <code>load()</code> function. This is where registration of handlers/hooks should happen.  For convenience, and certain edge cases, the <code>app</code> object is passed here in its current state at the time that <code>load()</code> is called.</p>\n<p>You will notice that extensions are essentially the same as application plugins, however the difference is both when/how the code is loaded, as well as the purpose of that code.  Framework extensions add functionality to the framework for the application to utilize, where application plugins extend the functionality of the application itself.</p>\n<h2 id=\"Loading-an-Extension\"><a href=\"#Loading-an-Extension\" class=\"headerlink\" title=\"Loading an Extension\"></a>Loading an Extension</h2><p>Extensions are loaded when <code>setup()</code> is called on an application.  Cement automatically loads all extensions listed under the applications <code>core_extensions</code> and <code>extensions</code> meta options.</p>\n<p>To load the above example into our application, we just add it to the list of <code>extensions</code> (not core extensions).  Lets assume the extension code lives in <code>myapp/ext/ext_something_fancy.py</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [<span class=\"string\">'myapp.ext.ext_something_fancy'</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>Note that Cement provides a shortcut for Cement extensions.  For example, the following:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">CementApp(<span class=\"string\">'myapp'</span>, extensions=[<span class=\"string\">'json'</span>, <span class=\"string\">'daemon'</span>])</div></pre></td></tr></table></figure>\n<p>Is equivalent to:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">CementApp(<span class=\"string\">'myapp'</span>,</div><div class=\"line\">    extensions=[</div><div class=\"line\">        <span class=\"string\">'cement.ext.ext_json'</span>,</div><div class=\"line\">        <span class=\"string\">'cement.ext.ext_daemon'</span>,</div><div class=\"line\">        ]</div><div class=\"line\">    )</div></pre></td></tr></table></figure>\n<p>For non-cement extensions you need to use the full python ‘dotted’ module path.</p>\n<h2 id=\"Loading-Extensions-Via-a-Configuration-File\"><a href=\"#Loading-Extensions-Via-a-Configuration-File\" class=\"headerlink\" title=\"Loading Extensions Via a Configuration File\"></a>Loading Extensions Via a Configuration File</h2><p>Some use cases require that end-users are able to modify what framework extensions are loaded via a configuration file.  The following gives an example of how an application can support an optional <code>extensions</code> configuration setting that will <strong>append</strong> extensions to <code>CementApp.Meta.extensions</code>.</p>\n<p>Note that extensions loaded in this way will happen <strong>after</strong> the config handler is setup.  Normally, extensions are loaded just before the configuration files are read.  Therefore, some extensions may not be compatible with this method if they attempt to perform any actions before <code>app.setup()</code> completes (such as in early framework hooks before configuration files are loaded).</p>\n<p><strong>myapp.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        config_files = [</div><div class=\"line\">            <span class=\"string\">'./myapp.conf'</span>,</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">        app.run()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<p><strong>myapp.conf</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">extensions = json, yaml</div></pre></td></tr></table></figure>\n<p>Which looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">MyApp Does Amazing Things</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help     show this help message and exit</div><div class=\"line\">  --debug        toggle debug output</div><div class=\"line\">  --quiet        suppress all output</div><div class=\"line\">  -o &#123;json,yaml&#125; output format</div></pre></td></tr></table></figure>\n<p>Note the <code>-o</code> command line option that are provided by Cement allowing the end user to override the output handler with the available/loaded extensions (that support this feature).</p>\n","excerpt":"","more":"<p>Cement defines an extension interface called <a href=\"/2.10/api/core/extension.html#cement.core.extension.IExtension\">IExtension</a>, as well as the default <a href=\"/2.10/api/core/extension.html#cement.core.extension.CementExtensionHandler\">CementExtensionHandler</a> that implements the interface.  Its purpose is to manage loading framework extensions and making them usable by the application.  Extensions are similar to <a href=\"/2.10/dev/plugins.html\">Application Plugins</a>, but at the framework level (application agnostic).</p>\n<p>Please note that there may be other handler’s that implement the <code>IExtension</code> interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.</p>\n<p>The following extension handlers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/core/extension.html#cement.core.extension.CementExtensionHandler\">CementExtensionHandler</a></li>\n</ul>\n<p>Please reference the <a href=\"/2.10/api/core/extension.html#cement.core.extension.IExtension\">IExtension</a> interface documentation for writing your own extension handler.</p>\n<p class=\"tip-warn\"><br>As of Cement 2.1.3, optional extensions with external dependencies are now being shipped along with mainline sources.  This means, that Cement Core continues to maintain a 100% zero dependency policy, however Framework Extensions <em>can</em> rely on external deps.  It is the responsibility of the application developer to include these dependencies in their application (as the Cement package does not include these dependencies).</p>\n\n\n<h2 id=\"Extension-Configuration-Settings\"><a href=\"#Extension-Configuration-Settings\" class=\"headerlink\" title=\"Extension Configuration Settings\"></a>Extension Configuration Settings</h2><p>The following Meta settings are honored under the CementApp:</p>\n<ul>\n<li><p><strong>extension_handler</strong> - A handler class that implements the <code>IExtension</code> interface.  This can be a string (label of a registered handler), an uninstantiated class, or an instantiated class object. Default: <code>CementExtensionHandler</code>.</p>\n</li>\n<li><p><strong>core_extensions</strong> - List of Cement core extensions.  These are generally required by Cement and should only be modified if you know what you’re doing.  Use <code>extensions</code> to add to this list, rather than overriding core extensions.  That said if you want to prune down your application, you can remove core extensions if they are not necessary (for example if using your own log handler extension you likely don’t want/need <code>LoggingLogHandler</code> to be registered, but removing it really doesn’t buy you much).</p>\n</li>\n<li><p><strong>extensions</strong> - List of additional framework extensions to load.</p>\n</li>\n</ul>\n<p>The following example shows how to alter these settings for your application:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.ext <span class=\"keyword\">import</span> CementExtensionHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyExtensionHandler</span><span class=\"params\">(CementExtensionHandler)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extension_handler = MyExtensionHandler</div><div class=\"line\">        extensions = [<span class=\"string\">'myapp.ext.ext_something_fancy'</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<h2 id=\"Creating-an-Extension\"><a href=\"#Creating-an-Extension\" class=\"headerlink\" title=\"Creating an Extension\"></a>Creating an Extension</h2><p>The extension system is a mechanism for dynamically loading code to extend the functionality of the framework.  In general, this includes the registration of interfaces, handlers, and/or hooks.</p>\n<p>The following is an example extension that provides an Output Handler.  We will assume this extension is part of our <code>myapp</code> application, and the extension module will be <code>myapp.ext.ext_myoutput</code> (or whatever you want to call it).</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> handler, output</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> minimal_logger</div><div class=\"line\"></div><div class=\"line\">LOG = minimal_logger(__name__)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyOutputHandler</span><span class=\"params\">(output.CementOutputHandler)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myoutput'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">render</span><span class=\"params\">(self, data_dict, template=None)</span>:</span></div><div class=\"line\">        LOG.debug(<span class=\"string\">\"Rendering output via MyAppOutputHandler\"</span>)</div><div class=\"line\">        <span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> data_dict.keys():</div><div class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"%s =&gt; %s\"</span> % (key, data_dict[key])</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    handler.register(MyOutputHandler)</div></pre></td></tr></table></figure>\n<p>Take note of two things.  One is, the <code>LOG</code> we are using is from <code>cement.utils.misc.minimal_logger(__name__)</code>.  Framework extensions do not use the application log handler, ever.  Use the <code>minimal_logger()</code>, and only log to ‘DEBUG’ (recommended).</p>\n<p>Secondly, in our extension file we need to define any interfaces, and register handlers and/or hooks if necessary.  In this example we only needed to register our output handler (which happens when the extension is loaded by the application).</p>\n<p>Last, notice that all <code>bootstrapping</code> code goes in a <code>load()</code> function. This is where registration of handlers/hooks should happen.  For convenience, and certain edge cases, the <code>app</code> object is passed here in its current state at the time that <code>load()</code> is called.</p>\n<p>You will notice that extensions are essentially the same as application plugins, however the difference is both when/how the code is loaded, as well as the purpose of that code.  Framework extensions add functionality to the framework for the application to utilize, where application plugins extend the functionality of the application itself.</p>\n<h2 id=\"Loading-an-Extension\"><a href=\"#Loading-an-Extension\" class=\"headerlink\" title=\"Loading an Extension\"></a>Loading an Extension</h2><p>Extensions are loaded when <code>setup()</code> is called on an application.  Cement automatically loads all extensions listed under the applications <code>core_extensions</code> and <code>extensions</code> meta options.</p>\n<p>To load the above example into our application, we just add it to the list of <code>extensions</code> (not core extensions).  Lets assume the extension code lives in <code>myapp/ext/ext_something_fancy.py</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [<span class=\"string\">'myapp.ext.ext_something_fancy'</span>]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>Note that Cement provides a shortcut for Cement extensions.  For example, the following:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">CementApp(<span class=\"string\">'myapp'</span>, extensions=[<span class=\"string\">'json'</span>, <span class=\"string\">'daemon'</span>])</div></pre></td></tr></table></figure>\n<p>Is equivalent to:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">CementApp(<span class=\"string\">'myapp'</span>,</div><div class=\"line\">    extensions=[</div><div class=\"line\">        <span class=\"string\">'cement.ext.ext_json'</span>,</div><div class=\"line\">        <span class=\"string\">'cement.ext.ext_daemon'</span>,</div><div class=\"line\">        ]</div><div class=\"line\">    )</div></pre></td></tr></table></figure>\n<p>For non-cement extensions you need to use the full python ‘dotted’ module path.</p>\n<h2 id=\"Loading-Extensions-Via-a-Configuration-File\"><a href=\"#Loading-Extensions-Via-a-Configuration-File\" class=\"headerlink\" title=\"Loading Extensions Via a Configuration File\"></a>Loading Extensions Via a Configuration File</h2><p>Some use cases require that end-users are able to modify what framework extensions are loaded via a configuration file.  The following gives an example of how an application can support an optional <code>extensions</code> configuration setting that will <strong>append</strong> extensions to <code>CementApp.Meta.extensions</code>.</p>\n<p>Note that extensions loaded in this way will happen <strong>after</strong> the config handler is setup.  Normally, extensions are loaded just before the configuration files are read.  Therefore, some extensions may not be compatible with this method if they attempt to perform any actions before <code>app.setup()</code> completes (such as in early framework hooks before configuration files are loaded).</p>\n<p><strong>myapp.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        config_files = [</div><div class=\"line\">            <span class=\"string\">'./myapp.conf'</span>,</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">        app.run()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<p><strong>myapp.conf</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">extensions = json, yaml</div></pre></td></tr></table></figure>\n<p>Which looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">MyApp Does Amazing Things</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help     show this help message and exit</div><div class=\"line\">  --debug        toggle debug output</div><div class=\"line\">  --quiet        suppress all output</div><div class=\"line\">  -o &#123;json,yaml&#125; output format</div></pre></td></tr></table></figure>\n<p>Note the <code>-o</code> command line option that are provided by Cement allowing the end user to override the output handler with the available/loaded extensions (that support this feature).</p>\n"},{"title":"Application Plugins","type":"guide","version":"2.10","order":11,"_content":"\nCement defines a plugin interface called [IPlugin](/{{ version }}/api/core/plugin.html#cement.core.plugin.IPlugin), as well as the default [CementPluginHandler](/{{ version }}/api/ext/ext_plugin.html#cement.ext.ext_plugin.CementPluginHandler) that implements the interface.\n\nPlease note that there may be other handlers that implement the `IPlugin` interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.\n\nThe following plugin handlers are included and maintained with Cement:\n\n- [CementPluginHandler](/{{ version }}/api/ext/ext_plugin.html#cement.ext.ext_plugin.CementPluginHandler)\n\nPlease reference the [IPlugin](/{{ version }}/api/core/plugin.html#cement.core.plugin.IPlugin) interface documentation for writing your own plugin handler.\n\n\n## Plugin Configuration Settings\n\nThere are a few settings related to how plugins are loaded under an applications meta options.  These are:\n\n### plugins\n\n*Default: `[]`*\n\nA list of plugins to load.  This is generally considered bad practice since plugins should be dynamically enabled/disabled via a plugin config file.\n\n\n### plugin_config_dirs\n\n*Default: `None`*\n\nA list of directory paths where plugin config files can be found. Files must end in `.conf` (or the extension defined by `CementApp.Meta.config_extension`), or they will be ignored.\n\nNote: Though `CementApp.Meta.plugin_config_dirs` is `None`, Cement will set this to a default list based on `CementApp.Meta.label`.  This will equate to:\n\n```python\n['/etc/<app_label>/plugins.d', '~/.<app_label>/plugin.d']\n```\n\nFiles are loaded in order, and have precedence in that order.  Therefore, the last configuration loaded has precedence (and overwrites settings loaded from previous configuration files).\n\n### plugin_config_dir\n\n*Default: `None`*\n\nA directory path where plugin config files can be found.  Files must end  in `.conf` (or the extension defined by `CementApp.Meta.config_extension`), or they will be ignored.  By default, this setting is also overridden by the  `[<app_label>] -> plugin_config_dir` config setting parsed in any of the application configuration files.\n\nIf set, this item will be **appended** to `CementApp.Meta.plugin_config_dirs` so that it's settings will have presedence over other configuration files.\n\nIn general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a `plugin_config_dir` without completely trumping the hard-coded list of default `plugin_config_dirs` defined by the app/developer.\n\n### plugin_bootstrap\n\n*Default: `None`*\n\nA python package (dotted import path) where plugin code can be loaded from.  This is generally something like `myapp.plugins` where a plugin file would live at `myapp/plugins/myplugin.py` or  `myapp/plugins/myplugin/__init__.py`. This provides a facility for applications that have builtin plugins that ship with the applications source code and live in the same Python module.\n\nNote: Though the meta default is `None`, Cement will set this to `<app_label>.plugins` if not set.\n\n### plugin_dirs\n\n*Default: `None`*\n\nA list of directory paths where plugin code (modules) can be loaded from.\n\nNote: Though `CementApp.Meta.plugin_dirs` is None, Cement will set this to a default list based on `CementApp.Meta.label` if not set.  This will equate to:\n\n```python\n['~/.<app_label>/plugins', '/usr/lib/<app_label>/plugins']\n```\n\n\nModules are attempted to be loaded in order, and will stop loading once a plugin is successfully loaded from a directory.  Therefore this is the oposite of configuration file loading, in that here the first has precedence.\n\n### plugin_dir\n\n*Default: `None`*\n\nA directory path where plugin code (modules) can be loaded from. By default, this setting is also overridden by the `[<app_label>] -> plugin_dir` config setting parsed in any of the application configuration files.\n\nIf set, this item will be **prepended** to `Meta.plugin_dirs` so that a users defined `plugin_dir` has precedence over others.\n\nIn general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a `plugin_dir` without completely trumping the hard-coded list of default `plugin_dirs` defined by the app/developer.\n\n\n## Creating a Plugin\n\nA plugin is essentially an extension of a Cement application, that is loaded from an internal or external source location.  It is a mechanism for dynamically loading code (whether the plugin is enabled or not). It can contain any code that would normally be part of your application, but should be thought of as optional features, where the core application does not rely on that code to operate.\n\nThe following is an example plugin (single file) that provides a number of options and commands via an application controller:\n\n**myplugin.py**\n\n```python\n\nfrom cement.core.controller import CementBaseController, expose\n\nclass MyPluginController(CementBaseController):\n    class Meta:\n        label = 'myplugin'\n        description = 'this is my controller description'\n        stacked_on = 'base'\n\n        config_defaults = dict(\n            foo='bar',\n            )\n\n        arguments = [\n            (['--foo'],\n             dict(action='store', help='the infamous foo option')),\n            ]\n\n    @expose(help=\"this is my command description\")\n    def mycommand(self):\n        print 'in MyPlugin.mycommand()'\n\ndef load(app):\n    app.handler.register(MyPluginController)\n```\n\n\nAs you can see, this is very similar to an application that has a base controller, however as you'll note we do not create an application object via `foundation.CementApp()` like we do in our application.  This code/file would then be saved to a location defined by your applications configuration that determines where plugins are loaded from (see the next section).\n\nNotice that all 'bootstrapping' code goes in a `load()` function.  This is where registration of handlers/hooks should happen.  For convenience, and certain edge cases, the `app` object is passed here in its current state at the time that `load()` is called.  You do not need to do anything with the `app` object, but you can.\n\nA plugin also has a configuration file that will be Cement will attempt to find in one of the directories listed in `CementApp.Meta.plugin_config_dirs` as defined by your application's configuration.  The following is an example plugin configuration file:\n\n**myplugin.conf**\n\n```\n[myplugin]\nenable_plugin = true\nfoo = bar\n```\n\n\n## Loading a Plugin\n\nPlugin modules are looked for first in one of the defined `plugin_dirs`, and if not found then Cement attempts to load them from the `plugin_bootstrap`. The following application shows how to configure an application to load plugins.  Take note that these are the **default settings** and will work the same if not defined:\n\n```\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\nclass MyBaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n        description = 'MyApp Does Amazing Things'\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        base_controller = MyBaseController\n        plugin_bootstrap='myapp.bootstrap',\n        plugin_config_dirs=[\n            '/etc/myapp/plugins.d',\n            '~/.myapp/plugins.d',\n            ]\n        plugin_dirs=[\n            '/usr/lib/myapp/plugins',\n            '~/.myapp/plugins',\n            ]\n\n\ndef main():\n    with MyApp() as app:\n        app.run()\n\nif __name__ == '__main__':\n    main()\n```\n\n\nWe modified the default settings for `plugin_config_dirs` and `plugin_dirs`.  These are the default settings under `Cementapp`, however we have put them here for clarity.\n\nRunning this application will do nothing particularly special, however the following demonstrates what happens when we add a simple plugin that provides an application controller:\n\n**/etc/myapp/plugins.d/myplugin.conf**\n\n```\n[myplugin]\nenable_plugin = true\nsome_option = some value\n```\n\n\n**/usr/lib/myapp/plugins/myplugin.py**\n\n```python\nfrom cement.core.controller import CementBaseController, expose\nfrom cement.utils.misc import init_defaults\n\ndefaults = init_defaults('myplugin')\n\nclass MyPluginController(CementBaseController):\n    class Meta:\n        label = 'myplugin'\n        description = 'this is my plugin description'\n        stacked_on = 'base'\n        config_defaults = defaults\n        arguments = [\n            (['--some-option'], dict(action='store')),\n            ]\n\n    @expose(help=\"this is my command description\")\n    def my_plugin_command(self):\n        print 'In MyPlugin.my_plugin_command()'\n\ndef load(app):\n    app.handler.register(MyPluginController)\n```\n\nRunning our application with the plugin disabled, we see:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nMyApp Does Amazing Things\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n```\n\n\nBut if we enable the plugin, we get something a little different:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nMyApp Does Amazing Things\n\ncommands:\n\n  my-plugin-command\n    this is my command description\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --debug               toggle debug output\n  --quiet               suppress all output\n  --some-option SOME_OPTION\n```\n\n\nWe can see that the `my-plugin-command` and the `--some-option` option were provided by our plugin, which has been 'stacked' on top of the base controller.\n\n## User Defined Plugin Configuration and Module Directories\n\nMost applications will want to provide the ability for the end-user to define where plugin configurations and modules live.  This is possible by setting the `plugin_config_dir` and `plugin_dir` settings in any of the applications configuration files.  Note that these paths will be **added** to the built-in `plugin_config_dirs` and `plugin_dirs` settings respectively, rather than completely overwriting them.  Therefore, your application can maintain it's default list of plugin configuration and module paths while also allowing users to define their own.\n\n**/etc/myapp/myapp.conf**\n\n```\n[myapp]\nplugin_dir = /usr/lib/myapp/plugins\nplugin_config_dir = /etc/myapp/plugins.d\n```\n\n\nThe `plugin_bootstrap` setting is however only configurable within the application itself.\n\n\n## What Can Go Into a Plugin?\n\nThe above example shows how to add an optional application controller via a plugin, however a plugin can contain anything you want.  This could be as simple as adding a hook that does something magical.  For example:\n\n```python\nfrom cement.core import hook\n\ndef my_magical_hook(app):\n    # do something magical\n    print('Something Magical is Happening!')\n\ndef load(app):\n    hook.register('post_setup', my_magical_hook)\n```\n\n\nAnd with the plugin enabled, we get this when we run the same app defined above:\n\n```\n$ python myapp.py\nSomething Magical is Happening!\n```\n\n\nThe primary detail is that Cement calls the `load()` function of a plugin... after that, you can do anything you like.\n\n\n## Single File Plugins vs. Plugin Directories\n\nAs of Cement 2.9.x, plugins can be either a single file (i.e `myplugin.py`) or a python module directory (i.e. `myplugin/__init__.py`).  Both will be loaded and executed the exact same way.\n\nOne caveat however, is that the submodules referenced from within a plugin directory must be relative path.  For example:\n\n**myplugin/__init__.py**\n\n```python\nfrom .controllers import MyPluginController\n\ndef load(app):\n    app.handler.register(MyPluginController)\n```\n\n\n**myplugin/controllers.py**\n\n```python\nfrom cement.core.controller import CementBaseController, expose\n\nclass MyPluginController(CementBaseController):\n    class Meta:\n        label = 'myplugin'\n        stacked_on = 'base'\n        stacked_type = 'embedded'\n\n    @expose()\n    def my_command(self):\n        print('Inside MyPluginController.my_command()')\n```\n\n\n## Loading Templates From Plugin Directories\n\nA common use case for complex applications is to use an output handler the uses templates, such as Mustache, Genshi, Jinja2, etc.  In order for a plugin to use it's own template files it's templates directory first needs to be added to the list of template directories to be parsed.  In the future, this will be more streamlined however currently the following is the recommeded way:\n\n**myplugin/__init__.py**\n\n```python\ndef add_template_dir(app):\n    path = os.path.join(os.path.basename(self.__file__, 'templates')\n    app.add_template_dir(path)\n\ndef load(app):\n    app.hook.register('post_setup', add_template_dir)\n```\n\n\nThe above will append the directory `/path/to/myplugin/templates` to the list of template directories that the applications output handler with search for template files.\n","source":"2.10/dev/plugins.md","raw":"---\ntitle: Application Plugins\ntype: guide\nversion: \"2.10\"\norder: 11\n---\n\nCement defines a plugin interface called [IPlugin](/{{ version }}/api/core/plugin.html#cement.core.plugin.IPlugin), as well as the default [CementPluginHandler](/{{ version }}/api/ext/ext_plugin.html#cement.ext.ext_plugin.CementPluginHandler) that implements the interface.\n\nPlease note that there may be other handlers that implement the `IPlugin` interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.\n\nThe following plugin handlers are included and maintained with Cement:\n\n- [CementPluginHandler](/{{ version }}/api/ext/ext_plugin.html#cement.ext.ext_plugin.CementPluginHandler)\n\nPlease reference the [IPlugin](/{{ version }}/api/core/plugin.html#cement.core.plugin.IPlugin) interface documentation for writing your own plugin handler.\n\n\n## Plugin Configuration Settings\n\nThere are a few settings related to how plugins are loaded under an applications meta options.  These are:\n\n### plugins\n\n*Default: `[]`*\n\nA list of plugins to load.  This is generally considered bad practice since plugins should be dynamically enabled/disabled via a plugin config file.\n\n\n### plugin_config_dirs\n\n*Default: `None`*\n\nA list of directory paths where plugin config files can be found. Files must end in `.conf` (or the extension defined by `CementApp.Meta.config_extension`), or they will be ignored.\n\nNote: Though `CementApp.Meta.plugin_config_dirs` is `None`, Cement will set this to a default list based on `CementApp.Meta.label`.  This will equate to:\n\n```python\n['/etc/<app_label>/plugins.d', '~/.<app_label>/plugin.d']\n```\n\nFiles are loaded in order, and have precedence in that order.  Therefore, the last configuration loaded has precedence (and overwrites settings loaded from previous configuration files).\n\n### plugin_config_dir\n\n*Default: `None`*\n\nA directory path where plugin config files can be found.  Files must end  in `.conf` (or the extension defined by `CementApp.Meta.config_extension`), or they will be ignored.  By default, this setting is also overridden by the  `[<app_label>] -> plugin_config_dir` config setting parsed in any of the application configuration files.\n\nIf set, this item will be **appended** to `CementApp.Meta.plugin_config_dirs` so that it's settings will have presedence over other configuration files.\n\nIn general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a `plugin_config_dir` without completely trumping the hard-coded list of default `plugin_config_dirs` defined by the app/developer.\n\n### plugin_bootstrap\n\n*Default: `None`*\n\nA python package (dotted import path) where plugin code can be loaded from.  This is generally something like `myapp.plugins` where a plugin file would live at `myapp/plugins/myplugin.py` or  `myapp/plugins/myplugin/__init__.py`. This provides a facility for applications that have builtin plugins that ship with the applications source code and live in the same Python module.\n\nNote: Though the meta default is `None`, Cement will set this to `<app_label>.plugins` if not set.\n\n### plugin_dirs\n\n*Default: `None`*\n\nA list of directory paths where plugin code (modules) can be loaded from.\n\nNote: Though `CementApp.Meta.plugin_dirs` is None, Cement will set this to a default list based on `CementApp.Meta.label` if not set.  This will equate to:\n\n```python\n['~/.<app_label>/plugins', '/usr/lib/<app_label>/plugins']\n```\n\n\nModules are attempted to be loaded in order, and will stop loading once a plugin is successfully loaded from a directory.  Therefore this is the oposite of configuration file loading, in that here the first has precedence.\n\n### plugin_dir\n\n*Default: `None`*\n\nA directory path where plugin code (modules) can be loaded from. By default, this setting is also overridden by the `[<app_label>] -> plugin_dir` config setting parsed in any of the application configuration files.\n\nIf set, this item will be **prepended** to `Meta.plugin_dirs` so that a users defined `plugin_dir` has precedence over others.\n\nIn general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a `plugin_dir` without completely trumping the hard-coded list of default `plugin_dirs` defined by the app/developer.\n\n\n## Creating a Plugin\n\nA plugin is essentially an extension of a Cement application, that is loaded from an internal or external source location.  It is a mechanism for dynamically loading code (whether the plugin is enabled or not). It can contain any code that would normally be part of your application, but should be thought of as optional features, where the core application does not rely on that code to operate.\n\nThe following is an example plugin (single file) that provides a number of options and commands via an application controller:\n\n**myplugin.py**\n\n```python\n\nfrom cement.core.controller import CementBaseController, expose\n\nclass MyPluginController(CementBaseController):\n    class Meta:\n        label = 'myplugin'\n        description = 'this is my controller description'\n        stacked_on = 'base'\n\n        config_defaults = dict(\n            foo='bar',\n            )\n\n        arguments = [\n            (['--foo'],\n             dict(action='store', help='the infamous foo option')),\n            ]\n\n    @expose(help=\"this is my command description\")\n    def mycommand(self):\n        print 'in MyPlugin.mycommand()'\n\ndef load(app):\n    app.handler.register(MyPluginController)\n```\n\n\nAs you can see, this is very similar to an application that has a base controller, however as you'll note we do not create an application object via `foundation.CementApp()` like we do in our application.  This code/file would then be saved to a location defined by your applications configuration that determines where plugins are loaded from (see the next section).\n\nNotice that all 'bootstrapping' code goes in a `load()` function.  This is where registration of handlers/hooks should happen.  For convenience, and certain edge cases, the `app` object is passed here in its current state at the time that `load()` is called.  You do not need to do anything with the `app` object, but you can.\n\nA plugin also has a configuration file that will be Cement will attempt to find in one of the directories listed in `CementApp.Meta.plugin_config_dirs` as defined by your application's configuration.  The following is an example plugin configuration file:\n\n**myplugin.conf**\n\n```\n[myplugin]\nenable_plugin = true\nfoo = bar\n```\n\n\n## Loading a Plugin\n\nPlugin modules are looked for first in one of the defined `plugin_dirs`, and if not found then Cement attempts to load them from the `plugin_bootstrap`. The following application shows how to configure an application to load plugins.  Take note that these are the **default settings** and will work the same if not defined:\n\n```\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\nclass MyBaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n        description = 'MyApp Does Amazing Things'\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        base_controller = MyBaseController\n        plugin_bootstrap='myapp.bootstrap',\n        plugin_config_dirs=[\n            '/etc/myapp/plugins.d',\n            '~/.myapp/plugins.d',\n            ]\n        plugin_dirs=[\n            '/usr/lib/myapp/plugins',\n            '~/.myapp/plugins',\n            ]\n\n\ndef main():\n    with MyApp() as app:\n        app.run()\n\nif __name__ == '__main__':\n    main()\n```\n\n\nWe modified the default settings for `plugin_config_dirs` and `plugin_dirs`.  These are the default settings under `Cementapp`, however we have put them here for clarity.\n\nRunning this application will do nothing particularly special, however the following demonstrates what happens when we add a simple plugin that provides an application controller:\n\n**/etc/myapp/plugins.d/myplugin.conf**\n\n```\n[myplugin]\nenable_plugin = true\nsome_option = some value\n```\n\n\n**/usr/lib/myapp/plugins/myplugin.py**\n\n```python\nfrom cement.core.controller import CementBaseController, expose\nfrom cement.utils.misc import init_defaults\n\ndefaults = init_defaults('myplugin')\n\nclass MyPluginController(CementBaseController):\n    class Meta:\n        label = 'myplugin'\n        description = 'this is my plugin description'\n        stacked_on = 'base'\n        config_defaults = defaults\n        arguments = [\n            (['--some-option'], dict(action='store')),\n            ]\n\n    @expose(help=\"this is my command description\")\n    def my_plugin_command(self):\n        print 'In MyPlugin.my_plugin_command()'\n\ndef load(app):\n    app.handler.register(MyPluginController)\n```\n\nRunning our application with the plugin disabled, we see:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nMyApp Does Amazing Things\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n```\n\n\nBut if we enable the plugin, we get something a little different:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nMyApp Does Amazing Things\n\ncommands:\n\n  my-plugin-command\n    this is my command description\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --debug               toggle debug output\n  --quiet               suppress all output\n  --some-option SOME_OPTION\n```\n\n\nWe can see that the `my-plugin-command` and the `--some-option` option were provided by our plugin, which has been 'stacked' on top of the base controller.\n\n## User Defined Plugin Configuration and Module Directories\n\nMost applications will want to provide the ability for the end-user to define where plugin configurations and modules live.  This is possible by setting the `plugin_config_dir` and `plugin_dir` settings in any of the applications configuration files.  Note that these paths will be **added** to the built-in `plugin_config_dirs` and `plugin_dirs` settings respectively, rather than completely overwriting them.  Therefore, your application can maintain it's default list of plugin configuration and module paths while also allowing users to define their own.\n\n**/etc/myapp/myapp.conf**\n\n```\n[myapp]\nplugin_dir = /usr/lib/myapp/plugins\nplugin_config_dir = /etc/myapp/plugins.d\n```\n\n\nThe `plugin_bootstrap` setting is however only configurable within the application itself.\n\n\n## What Can Go Into a Plugin?\n\nThe above example shows how to add an optional application controller via a plugin, however a plugin can contain anything you want.  This could be as simple as adding a hook that does something magical.  For example:\n\n```python\nfrom cement.core import hook\n\ndef my_magical_hook(app):\n    # do something magical\n    print('Something Magical is Happening!')\n\ndef load(app):\n    hook.register('post_setup', my_magical_hook)\n```\n\n\nAnd with the plugin enabled, we get this when we run the same app defined above:\n\n```\n$ python myapp.py\nSomething Magical is Happening!\n```\n\n\nThe primary detail is that Cement calls the `load()` function of a plugin... after that, you can do anything you like.\n\n\n## Single File Plugins vs. Plugin Directories\n\nAs of Cement 2.9.x, plugins can be either a single file (i.e `myplugin.py`) or a python module directory (i.e. `myplugin/__init__.py`).  Both will be loaded and executed the exact same way.\n\nOne caveat however, is that the submodules referenced from within a plugin directory must be relative path.  For example:\n\n**myplugin/__init__.py**\n\n```python\nfrom .controllers import MyPluginController\n\ndef load(app):\n    app.handler.register(MyPluginController)\n```\n\n\n**myplugin/controllers.py**\n\n```python\nfrom cement.core.controller import CementBaseController, expose\n\nclass MyPluginController(CementBaseController):\n    class Meta:\n        label = 'myplugin'\n        stacked_on = 'base'\n        stacked_type = 'embedded'\n\n    @expose()\n    def my_command(self):\n        print('Inside MyPluginController.my_command()')\n```\n\n\n## Loading Templates From Plugin Directories\n\nA common use case for complex applications is to use an output handler the uses templates, such as Mustache, Genshi, Jinja2, etc.  In order for a plugin to use it's own template files it's templates directory first needs to be added to the list of template directories to be parsed.  In the future, this will be more streamlined however currently the following is the recommeded way:\n\n**myplugin/__init__.py**\n\n```python\ndef add_template_dir(app):\n    path = os.path.join(os.path.basename(self.__file__, 'templates')\n    app.add_template_dir(path)\n\ndef load(app):\n    app.hook.register('post_setup', add_template_dir)\n```\n\n\nThe above will append the directory `/path/to/myplugin/templates` to the list of template directories that the applications output handler with search for template files.\n","date":"2017-08-07T17:55:32.000Z","updated":"2017-08-07T17:55:32.000Z","path":"2.10/dev/plugins.html","_id":"cj5y95fa30000bzpwtyl3h7cc","comments":1,"layout":"page","content":"<p>Cement defines a plugin interface called <a href=\"/2.10/api/core/plugin.html#cement.core.plugin.IPlugin\">IPlugin</a>, as well as the default <a href=\"/2.10/api/ext/ext_plugin.html#cement.ext.ext_plugin.CementPluginHandler\">CementPluginHandler</a> that implements the interface.</p>\n<p>Please note that there may be other handlers that implement the <code>IPlugin</code> interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.</p>\n<p>The following plugin handlers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/ext/ext_plugin.html#cement.ext.ext_plugin.CementPluginHandler\">CementPluginHandler</a></li>\n</ul>\n<p>Please reference the <a href=\"/2.10/api/core/plugin.html#cement.core.plugin.IPlugin\">IPlugin</a> interface documentation for writing your own plugin handler.</p>\n<h2 id=\"Plugin-Configuration-Settings\"><a href=\"#Plugin-Configuration-Settings\" class=\"headerlink\" title=\"Plugin Configuration Settings\"></a>Plugin Configuration Settings</h2><p>There are a few settings related to how plugins are loaded under an applications meta options.  These are:</p>\n<h3 id=\"plugins\"><a href=\"#plugins\" class=\"headerlink\" title=\"plugins\"></a>plugins</h3><p><em>Default: <code>[]</code></em></p>\n<p>A list of plugins to load.  This is generally considered bad practice since plugins should be dynamically enabled/disabled via a plugin config file.</p>\n<h3 id=\"plugin-config-dirs\"><a href=\"#plugin-config-dirs\" class=\"headerlink\" title=\"plugin_config_dirs\"></a>plugin_config_dirs</h3><p><em>Default: <code>None</code></em></p>\n<p>A list of directory paths where plugin config files can be found. Files must end in <code>.conf</code> (or the extension defined by <code>CementApp.Meta.config_extension</code>), or they will be ignored.</p>\n<p>Note: Though <code>CementApp.Meta.plugin_config_dirs</code> is <code>None</code>, Cement will set this to a default list based on <code>CementApp.Meta.label</code>.  This will equate to:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">[<span class=\"string\">'/etc/&lt;app_label&gt;/plugins.d'</span>, <span class=\"string\">'~/.&lt;app_label&gt;/plugin.d'</span>]</div></pre></td></tr></table></figure>\n<p>Files are loaded in order, and have precedence in that order.  Therefore, the last configuration loaded has precedence (and overwrites settings loaded from previous configuration files).</p>\n<h3 id=\"plugin-config-dir\"><a href=\"#plugin-config-dir\" class=\"headerlink\" title=\"plugin_config_dir\"></a>plugin_config_dir</h3><p><em>Default: <code>None</code></em></p>\n<p>A directory path where plugin config files can be found.  Files must end  in <code>.conf</code> (or the extension defined by <code>CementApp.Meta.config_extension</code>), or they will be ignored.  By default, this setting is also overridden by the  <code>[&lt;app_label&gt;] -&gt; plugin_config_dir</code> config setting parsed in any of the application configuration files.</p>\n<p>If set, this item will be <strong>appended</strong> to <code>CementApp.Meta.plugin_config_dirs</code> so that it’s settings will have presedence over other configuration files.</p>\n<p>In general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a <code>plugin_config_dir</code> without completely trumping the hard-coded list of default <code>plugin_config_dirs</code> defined by the app/developer.</p>\n<h3 id=\"plugin-bootstrap\"><a href=\"#plugin-bootstrap\" class=\"headerlink\" title=\"plugin_bootstrap\"></a>plugin_bootstrap</h3><p><em>Default: <code>None</code></em></p>\n<p>A python package (dotted import path) where plugin code can be loaded from.  This is generally something like <code>myapp.plugins</code> where a plugin file would live at <code>myapp/plugins/myplugin.py</code> or  <code>myapp/plugins/myplugin/__init__.py</code>. This provides a facility for applications that have builtin plugins that ship with the applications source code and live in the same Python module.</p>\n<p>Note: Though the meta default is <code>None</code>, Cement will set this to <code>&lt;app_label&gt;.plugins</code> if not set.</p>\n<h3 id=\"plugin-dirs\"><a href=\"#plugin-dirs\" class=\"headerlink\" title=\"plugin_dirs\"></a>plugin_dirs</h3><p><em>Default: <code>None</code></em></p>\n<p>A list of directory paths where plugin code (modules) can be loaded from.</p>\n<p>Note: Though <code>CementApp.Meta.plugin_dirs</code> is None, Cement will set this to a default list based on <code>CementApp.Meta.label</code> if not set.  This will equate to:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">[<span class=\"string\">'~/.&lt;app_label&gt;/plugins'</span>, <span class=\"string\">'/usr/lib/&lt;app_label&gt;/plugins'</span>]</div></pre></td></tr></table></figure>\n<p>Modules are attempted to be loaded in order, and will stop loading once a plugin is successfully loaded from a directory.  Therefore this is the oposite of configuration file loading, in that here the first has precedence.</p>\n<h3 id=\"plugin-dir\"><a href=\"#plugin-dir\" class=\"headerlink\" title=\"plugin_dir\"></a>plugin_dir</h3><p><em>Default: <code>None</code></em></p>\n<p>A directory path where plugin code (modules) can be loaded from. By default, this setting is also overridden by the <code>[&lt;app_label&gt;] -&gt; plugin_dir</code> config setting parsed in any of the application configuration files.</p>\n<p>If set, this item will be <strong>prepended</strong> to <code>Meta.plugin_dirs</code> so that a users defined <code>plugin_dir</code> has precedence over others.</p>\n<p>In general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a <code>plugin_dir</code> without completely trumping the hard-coded list of default <code>plugin_dirs</code> defined by the app/developer.</p>\n<h2 id=\"Creating-a-Plugin\"><a href=\"#Creating-a-Plugin\" class=\"headerlink\" title=\"Creating a Plugin\"></a>Creating a Plugin</h2><p>A plugin is essentially an extension of a Cement application, that is loaded from an internal or external source location.  It is a mechanism for dynamically loading code (whether the plugin is enabled or not). It can contain any code that would normally be part of your application, but should be thought of as optional features, where the core application does not rely on that code to operate.</p>\n<p>The following is an example plugin (single file) that provides a number of options and commands via an application controller:</p>\n<p><strong>myplugin.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPluginController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myplugin'</span></div><div class=\"line\">        description = <span class=\"string\">'this is my controller description'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\">        config_defaults = dict(</div><div class=\"line\">            foo=<span class=\"string\">'bar'</span>,</div><div class=\"line\">            )</div><div class=\"line\"></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'--foo'</span>],</div><div class=\"line\">             dict(action=<span class=\"string\">'store'</span>, help=<span class=\"string\">'the infamous foo option'</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"this is my command description\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mycommand</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'in MyPlugin.mycommand()'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    app.handler.register(MyPluginController)</div></pre></td></tr></table></figure>\n<p>As you can see, this is very similar to an application that has a base controller, however as you’ll note we do not create an application object via <code>foundation.CementApp()</code> like we do in our application.  This code/file would then be saved to a location defined by your applications configuration that determines where plugins are loaded from (see the next section).</p>\n<p>Notice that all ‘bootstrapping’ code goes in a <code>load()</code> function.  This is where registration of handlers/hooks should happen.  For convenience, and certain edge cases, the <code>app</code> object is passed here in its current state at the time that <code>load()</code> is called.  You do not need to do anything with the <code>app</code> object, but you can.</p>\n<p>A plugin also has a configuration file that will be Cement will attempt to find in one of the directories listed in <code>CementApp.Meta.plugin_config_dirs</code> as defined by your application’s configuration.  The following is an example plugin configuration file:</p>\n<p><strong>myplugin.conf</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myplugin]</div><div class=\"line\">enable_plugin = true</div><div class=\"line\">foo = bar</div></pre></td></tr></table></figure>\n<h2 id=\"Loading-a-Plugin\"><a href=\"#Loading-a-Plugin\" class=\"headerlink\" title=\"Loading a Plugin\"></a>Loading a Plugin</h2><p>Plugin modules are looked for first in one of the defined <code>plugin_dirs</code>, and if not found then Cement attempts to load them from the <code>plugin_bootstrap</code>. The following application shows how to configure an application to load plugins.  Take note that these are the <strong>default settings</strong> and will work the same if not defined:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">from cement.core.foundation import CementApp</div><div class=\"line\">from cement.core.controller import CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\">class MyBaseController(CementBaseController):</div><div class=\"line\">    class Meta:</div><div class=\"line\">        label = &apos;base&apos;</div><div class=\"line\">        description = &apos;MyApp Does Amazing Things&apos;</div><div class=\"line\"></div><div class=\"line\">class MyApp(CementApp):</div><div class=\"line\">    class Meta:</div><div class=\"line\">        label = &apos;myapp&apos;</div><div class=\"line\">        base_controller = MyBaseController</div><div class=\"line\">        plugin_bootstrap=&apos;myapp.bootstrap&apos;,</div><div class=\"line\">        plugin_config_dirs=[</div><div class=\"line\">            &apos;/etc/myapp/plugins.d&apos;,</div><div class=\"line\">            &apos;~/.myapp/plugins.d&apos;,</div><div class=\"line\">            ]</div><div class=\"line\">        plugin_dirs=[</div><div class=\"line\">            &apos;/usr/lib/myapp/plugins&apos;,</div><div class=\"line\">            &apos;~/.myapp/plugins&apos;,</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    with MyApp() as app:</div><div class=\"line\">        app.run()</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<p>We modified the default settings for <code>plugin_config_dirs</code> and <code>plugin_dirs</code>.  These are the default settings under <code>Cementapp</code>, however we have put them here for clarity.</p>\n<p>Running this application will do nothing particularly special, however the following demonstrates what happens when we add a simple plugin that provides an application controller:</p>\n<p><strong>/etc/myapp/plugins.d/myplugin.conf</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myplugin]</div><div class=\"line\">enable_plugin = true</div><div class=\"line\">some_option = some value</div></pre></td></tr></table></figure>\n<p><strong>/usr/lib/myapp/plugins/myplugin.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myplugin'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPluginController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myplugin'</span></div><div class=\"line\">        description = <span class=\"string\">'this is my plugin description'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        config_defaults = defaults</div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'--some-option'</span>], dict(action=<span class=\"string\">'store'</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"this is my command description\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_plugin_command</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'In MyPlugin.my_plugin_command()'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    app.handler.register(MyPluginController)</div></pre></td></tr></table></figure>\n<p>Running our application with the plugin disabled, we see:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">MyApp Does Amazing Things</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div></pre></td></tr></table></figure>\n<p>But if we enable the plugin, we get something a little different:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">MyApp Does Amazing Things</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  my-plugin-command</div><div class=\"line\">    this is my command description</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help            show this help message and exit</div><div class=\"line\">  --debug               toggle debug output</div><div class=\"line\">  --quiet               suppress all output</div><div class=\"line\">  --some-option SOME_OPTION</div></pre></td></tr></table></figure>\n<p>We can see that the <code>my-plugin-command</code> and the <code>--some-option</code> option were provided by our plugin, which has been ‘stacked’ on top of the base controller.</p>\n<h2 id=\"User-Defined-Plugin-Configuration-and-Module-Directories\"><a href=\"#User-Defined-Plugin-Configuration-and-Module-Directories\" class=\"headerlink\" title=\"User Defined Plugin Configuration and Module Directories\"></a>User Defined Plugin Configuration and Module Directories</h2><p>Most applications will want to provide the ability for the end-user to define where plugin configurations and modules live.  This is possible by setting the <code>plugin_config_dir</code> and <code>plugin_dir</code> settings in any of the applications configuration files.  Note that these paths will be <strong>added</strong> to the built-in <code>plugin_config_dirs</code> and <code>plugin_dirs</code> settings respectively, rather than completely overwriting them.  Therefore, your application can maintain it’s default list of plugin configuration and module paths while also allowing users to define their own.</p>\n<p><strong>/etc/myapp/myapp.conf</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">plugin_dir = /usr/lib/myapp/plugins</div><div class=\"line\">plugin_config_dir = /etc/myapp/plugins.d</div></pre></td></tr></table></figure>\n<p>The <code>plugin_bootstrap</code> setting is however only configurable within the application itself.</p>\n<h2 id=\"What-Can-Go-Into-a-Plugin\"><a href=\"#What-Can-Go-Into-a-Plugin\" class=\"headerlink\" title=\"What Can Go Into a Plugin?\"></a>What Can Go Into a Plugin?</h2><p>The above example shows how to add an optional application controller via a plugin, however a plugin can contain anything you want.  This could be as simple as adding a hook that does something magical.  For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> hook</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_magical_hook</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># do something magical</span></div><div class=\"line\">    print(<span class=\"string\">'Something Magical is Happening!'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    hook.register(<span class=\"string\">'post_setup'</span>, my_magical_hook)</div></pre></td></tr></table></figure>\n<p>And with the plugin enabled, we get this when we run the same app defined above:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">Something Magical is Happening!</div></pre></td></tr></table></figure>\n<p>The primary detail is that Cement calls the <code>load()</code> function of a plugin… after that, you can do anything you like.</p>\n<h2 id=\"Single-File-Plugins-vs-Plugin-Directories\"><a href=\"#Single-File-Plugins-vs-Plugin-Directories\" class=\"headerlink\" title=\"Single File Plugins vs. Plugin Directories\"></a>Single File Plugins vs. Plugin Directories</h2><p>As of Cement 2.9.x, plugins can be either a single file (i.e <code>myplugin.py</code>) or a python module directory (i.e. <code>myplugin/__init__.py</code>).  Both will be loaded and executed the exact same way.</p>\n<p>One caveat however, is that the submodules referenced from within a plugin directory must be relative path.  For example:</p>\n<p><strong>myplugin/<strong>init</strong>.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> .controllers <span class=\"keyword\">import</span> MyPluginController</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    app.handler.register(MyPluginController)</div></pre></td></tr></table></figure>\n<p><strong>myplugin/controllers.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPluginController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myplugin'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'embedded'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_command</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'Inside MyPluginController.my_command()'</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"Loading-Templates-From-Plugin-Directories\"><a href=\"#Loading-Templates-From-Plugin-Directories\" class=\"headerlink\" title=\"Loading Templates From Plugin Directories\"></a>Loading Templates From Plugin Directories</h2><p>A common use case for complex applications is to use an output handler the uses templates, such as Mustache, Genshi, Jinja2, etc.  In order for a plugin to use it’s own template files it’s templates directory first needs to be added to the list of template directories to be parsed.  In the future, this will be more streamlined however currently the following is the recommeded way:</p>\n<p><strong>myplugin/<strong>init</strong>.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_template_dir</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    path = os.path.join(os.path.basename(self.__file__, <span class=\"string\">'templates'</span>)</div><div class=\"line\">    app.add_template_dir(path)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    app.hook.register(<span class=\"string\">'post_setup'</span>, add_template_dir)</div></pre></td></tr></table></figure>\n<p>The above will append the directory <code>/path/to/myplugin/templates</code> to the list of template directories that the applications output handler with search for template files.</p>\n","excerpt":"","more":"<p>Cement defines a plugin interface called <a href=\"/2.10/api/core/plugin.html#cement.core.plugin.IPlugin\">IPlugin</a>, as well as the default <a href=\"/2.10/api/ext/ext_plugin.html#cement.ext.ext_plugin.CementPluginHandler\">CementPluginHandler</a> that implements the interface.</p>\n<p>Please note that there may be other handlers that implement the <code>IPlugin</code> interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.</p>\n<p>The following plugin handlers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/ext/ext_plugin.html#cement.ext.ext_plugin.CementPluginHandler\">CementPluginHandler</a></li>\n</ul>\n<p>Please reference the <a href=\"/2.10/api/core/plugin.html#cement.core.plugin.IPlugin\">IPlugin</a> interface documentation for writing your own plugin handler.</p>\n<h2 id=\"Plugin-Configuration-Settings\"><a href=\"#Plugin-Configuration-Settings\" class=\"headerlink\" title=\"Plugin Configuration Settings\"></a>Plugin Configuration Settings</h2><p>There are a few settings related to how plugins are loaded under an applications meta options.  These are:</p>\n<h3 id=\"plugins\"><a href=\"#plugins\" class=\"headerlink\" title=\"plugins\"></a>plugins</h3><p><em>Default: <code>[]</code></em></p>\n<p>A list of plugins to load.  This is generally considered bad practice since plugins should be dynamically enabled/disabled via a plugin config file.</p>\n<h3 id=\"plugin-config-dirs\"><a href=\"#plugin-config-dirs\" class=\"headerlink\" title=\"plugin_config_dirs\"></a>plugin_config_dirs</h3><p><em>Default: <code>None</code></em></p>\n<p>A list of directory paths where plugin config files can be found. Files must end in <code>.conf</code> (or the extension defined by <code>CementApp.Meta.config_extension</code>), or they will be ignored.</p>\n<p>Note: Though <code>CementApp.Meta.plugin_config_dirs</code> is <code>None</code>, Cement will set this to a default list based on <code>CementApp.Meta.label</code>.  This will equate to:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">[<span class=\"string\">'/etc/&lt;app_label&gt;/plugins.d'</span>, <span class=\"string\">'~/.&lt;app_label&gt;/plugin.d'</span>]</div></pre></td></tr></table></figure>\n<p>Files are loaded in order, and have precedence in that order.  Therefore, the last configuration loaded has precedence (and overwrites settings loaded from previous configuration files).</p>\n<h3 id=\"plugin-config-dir\"><a href=\"#plugin-config-dir\" class=\"headerlink\" title=\"plugin_config_dir\"></a>plugin_config_dir</h3><p><em>Default: <code>None</code></em></p>\n<p>A directory path where plugin config files can be found.  Files must end  in <code>.conf</code> (or the extension defined by <code>CementApp.Meta.config_extension</code>), or they will be ignored.  By default, this setting is also overridden by the  <code>[&lt;app_label&gt;] -&gt; plugin_config_dir</code> config setting parsed in any of the application configuration files.</p>\n<p>If set, this item will be <strong>appended</strong> to <code>CementApp.Meta.plugin_config_dirs</code> so that it’s settings will have presedence over other configuration files.</p>\n<p>In general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a <code>plugin_config_dir</code> without completely trumping the hard-coded list of default <code>plugin_config_dirs</code> defined by the app/developer.</p>\n<h3 id=\"plugin-bootstrap\"><a href=\"#plugin-bootstrap\" class=\"headerlink\" title=\"plugin_bootstrap\"></a>plugin_bootstrap</h3><p><em>Default: <code>None</code></em></p>\n<p>A python package (dotted import path) where plugin code can be loaded from.  This is generally something like <code>myapp.plugins</code> where a plugin file would live at <code>myapp/plugins/myplugin.py</code> or  <code>myapp/plugins/myplugin/__init__.py</code>. This provides a facility for applications that have builtin plugins that ship with the applications source code and live in the same Python module.</p>\n<p>Note: Though the meta default is <code>None</code>, Cement will set this to <code>&lt;app_label&gt;.plugins</code> if not set.</p>\n<h3 id=\"plugin-dirs\"><a href=\"#plugin-dirs\" class=\"headerlink\" title=\"plugin_dirs\"></a>plugin_dirs</h3><p><em>Default: <code>None</code></em></p>\n<p>A list of directory paths where plugin code (modules) can be loaded from.</p>\n<p>Note: Though <code>CementApp.Meta.plugin_dirs</code> is None, Cement will set this to a default list based on <code>CementApp.Meta.label</code> if not set.  This will equate to:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">[<span class=\"string\">'~/.&lt;app_label&gt;/plugins'</span>, <span class=\"string\">'/usr/lib/&lt;app_label&gt;/plugins'</span>]</div></pre></td></tr></table></figure>\n<p>Modules are attempted to be loaded in order, and will stop loading once a plugin is successfully loaded from a directory.  Therefore this is the oposite of configuration file loading, in that here the first has precedence.</p>\n<h3 id=\"plugin-dir\"><a href=\"#plugin-dir\" class=\"headerlink\" title=\"plugin_dir\"></a>plugin_dir</h3><p><em>Default: <code>None</code></em></p>\n<p>A directory path where plugin code (modules) can be loaded from. By default, this setting is also overridden by the <code>[&lt;app_label&gt;] -&gt; plugin_dir</code> config setting parsed in any of the application configuration files.</p>\n<p>If set, this item will be <strong>prepended</strong> to <code>Meta.plugin_dirs</code> so that a users defined <code>plugin_dir</code> has precedence over others.</p>\n<p>In general, this setting should not be defined by the developer, as it is primarily used to allow the end-user to define a <code>plugin_dir</code> without completely trumping the hard-coded list of default <code>plugin_dirs</code> defined by the app/developer.</p>\n<h2 id=\"Creating-a-Plugin\"><a href=\"#Creating-a-Plugin\" class=\"headerlink\" title=\"Creating a Plugin\"></a>Creating a Plugin</h2><p>A plugin is essentially an extension of a Cement application, that is loaded from an internal or external source location.  It is a mechanism for dynamically loading code (whether the plugin is enabled or not). It can contain any code that would normally be part of your application, but should be thought of as optional features, where the core application does not rely on that code to operate.</p>\n<p>The following is an example plugin (single file) that provides a number of options and commands via an application controller:</p>\n<p><strong>myplugin.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPluginController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myplugin'</span></div><div class=\"line\">        description = <span class=\"string\">'this is my controller description'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\">        config_defaults = dict(</div><div class=\"line\">            foo=<span class=\"string\">'bar'</span>,</div><div class=\"line\">            )</div><div class=\"line\"></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'--foo'</span>],</div><div class=\"line\">             dict(action=<span class=\"string\">'store'</span>, help=<span class=\"string\">'the infamous foo option'</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"this is my command description\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mycommand</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'in MyPlugin.mycommand()'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    app.handler.register(MyPluginController)</div></pre></td></tr></table></figure>\n<p>As you can see, this is very similar to an application that has a base controller, however as you’ll note we do not create an application object via <code>foundation.CementApp()</code> like we do in our application.  This code/file would then be saved to a location defined by your applications configuration that determines where plugins are loaded from (see the next section).</p>\n<p>Notice that all ‘bootstrapping’ code goes in a <code>load()</code> function.  This is where registration of handlers/hooks should happen.  For convenience, and certain edge cases, the <code>app</code> object is passed here in its current state at the time that <code>load()</code> is called.  You do not need to do anything with the <code>app</code> object, but you can.</p>\n<p>A plugin also has a configuration file that will be Cement will attempt to find in one of the directories listed in <code>CementApp.Meta.plugin_config_dirs</code> as defined by your application’s configuration.  The following is an example plugin configuration file:</p>\n<p><strong>myplugin.conf</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myplugin]</div><div class=\"line\">enable_plugin = true</div><div class=\"line\">foo = bar</div></pre></td></tr></table></figure>\n<h2 id=\"Loading-a-Plugin\"><a href=\"#Loading-a-Plugin\" class=\"headerlink\" title=\"Loading a Plugin\"></a>Loading a Plugin</h2><p>Plugin modules are looked for first in one of the defined <code>plugin_dirs</code>, and if not found then Cement attempts to load them from the <code>plugin_bootstrap</code>. The following application shows how to configure an application to load plugins.  Take note that these are the <strong>default settings</strong> and will work the same if not defined:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">from cement.core.foundation import CementApp</div><div class=\"line\">from cement.core.controller import CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\">class MyBaseController(CementBaseController):</div><div class=\"line\">    class Meta:</div><div class=\"line\">        label = &apos;base&apos;</div><div class=\"line\">        description = &apos;MyApp Does Amazing Things&apos;</div><div class=\"line\"></div><div class=\"line\">class MyApp(CementApp):</div><div class=\"line\">    class Meta:</div><div class=\"line\">        label = &apos;myapp&apos;</div><div class=\"line\">        base_controller = MyBaseController</div><div class=\"line\">        plugin_bootstrap=&apos;myapp.bootstrap&apos;,</div><div class=\"line\">        plugin_config_dirs=[</div><div class=\"line\">            &apos;/etc/myapp/plugins.d&apos;,</div><div class=\"line\">            &apos;~/.myapp/plugins.d&apos;,</div><div class=\"line\">            ]</div><div class=\"line\">        plugin_dirs=[</div><div class=\"line\">            &apos;/usr/lib/myapp/plugins&apos;,</div><div class=\"line\">            &apos;~/.myapp/plugins&apos;,</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    with MyApp() as app:</div><div class=\"line\">        app.run()</div><div class=\"line\"></div><div class=\"line\">if __name__ == &apos;__main__&apos;:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<p>We modified the default settings for <code>plugin_config_dirs</code> and <code>plugin_dirs</code>.  These are the default settings under <code>Cementapp</code>, however we have put them here for clarity.</p>\n<p>Running this application will do nothing particularly special, however the following demonstrates what happens when we add a simple plugin that provides an application controller:</p>\n<p><strong>/etc/myapp/plugins.d/myplugin.conf</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myplugin]</div><div class=\"line\">enable_plugin = true</div><div class=\"line\">some_option = some value</div></pre></td></tr></table></figure>\n<p><strong>/usr/lib/myapp/plugins/myplugin.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myplugin'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPluginController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myplugin'</span></div><div class=\"line\">        description = <span class=\"string\">'this is my plugin description'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        config_defaults = defaults</div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'--some-option'</span>], dict(action=<span class=\"string\">'store'</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"this is my command description\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_plugin_command</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'In MyPlugin.my_plugin_command()'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    app.handler.register(MyPluginController)</div></pre></td></tr></table></figure>\n<p>Running our application with the plugin disabled, we see:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">MyApp Does Amazing Things</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div></pre></td></tr></table></figure>\n<p>But if we enable the plugin, we get something a little different:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">MyApp Does Amazing Things</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  my-plugin-command</div><div class=\"line\">    this is my command description</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help            show this help message and exit</div><div class=\"line\">  --debug               toggle debug output</div><div class=\"line\">  --quiet               suppress all output</div><div class=\"line\">  --some-option SOME_OPTION</div></pre></td></tr></table></figure>\n<p>We can see that the <code>my-plugin-command</code> and the <code>--some-option</code> option were provided by our plugin, which has been ‘stacked’ on top of the base controller.</p>\n<h2 id=\"User-Defined-Plugin-Configuration-and-Module-Directories\"><a href=\"#User-Defined-Plugin-Configuration-and-Module-Directories\" class=\"headerlink\" title=\"User Defined Plugin Configuration and Module Directories\"></a>User Defined Plugin Configuration and Module Directories</h2><p>Most applications will want to provide the ability for the end-user to define where plugin configurations and modules live.  This is possible by setting the <code>plugin_config_dir</code> and <code>plugin_dir</code> settings in any of the applications configuration files.  Note that these paths will be <strong>added</strong> to the built-in <code>plugin_config_dirs</code> and <code>plugin_dirs</code> settings respectively, rather than completely overwriting them.  Therefore, your application can maintain it’s default list of plugin configuration and module paths while also allowing users to define their own.</p>\n<p><strong>/etc/myapp/myapp.conf</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">plugin_dir = /usr/lib/myapp/plugins</div><div class=\"line\">plugin_config_dir = /etc/myapp/plugins.d</div></pre></td></tr></table></figure>\n<p>The <code>plugin_bootstrap</code> setting is however only configurable within the application itself.</p>\n<h2 id=\"What-Can-Go-Into-a-Plugin\"><a href=\"#What-Can-Go-Into-a-Plugin\" class=\"headerlink\" title=\"What Can Go Into a Plugin?\"></a>What Can Go Into a Plugin?</h2><p>The above example shows how to add an optional application controller via a plugin, however a plugin can contain anything you want.  This could be as simple as adding a hook that does something magical.  For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> hook</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_magical_hook</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># do something magical</span></div><div class=\"line\">    print(<span class=\"string\">'Something Magical is Happening!'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    hook.register(<span class=\"string\">'post_setup'</span>, my_magical_hook)</div></pre></td></tr></table></figure>\n<p>And with the plugin enabled, we get this when we run the same app defined above:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">Something Magical is Happening!</div></pre></td></tr></table></figure>\n<p>The primary detail is that Cement calls the <code>load()</code> function of a plugin… after that, you can do anything you like.</p>\n<h2 id=\"Single-File-Plugins-vs-Plugin-Directories\"><a href=\"#Single-File-Plugins-vs-Plugin-Directories\" class=\"headerlink\" title=\"Single File Plugins vs. Plugin Directories\"></a>Single File Plugins vs. Plugin Directories</h2><p>As of Cement 2.9.x, plugins can be either a single file (i.e <code>myplugin.py</code>) or a python module directory (i.e. <code>myplugin/__init__.py</code>).  Both will be loaded and executed the exact same way.</p>\n<p>One caveat however, is that the submodules referenced from within a plugin directory must be relative path.  For example:</p>\n<p><strong>myplugin/<strong>init</strong>.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> .controllers <span class=\"keyword\">import</span> MyPluginController</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    app.handler.register(MyPluginController)</div></pre></td></tr></table></figure>\n<p><strong>myplugin/controllers.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPluginController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myplugin'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'embedded'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_command</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'Inside MyPluginController.my_command()'</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"Loading-Templates-From-Plugin-Directories\"><a href=\"#Loading-Templates-From-Plugin-Directories\" class=\"headerlink\" title=\"Loading Templates From Plugin Directories\"></a>Loading Templates From Plugin Directories</h2><p>A common use case for complex applications is to use an output handler the uses templates, such as Mustache, Genshi, Jinja2, etc.  In order for a plugin to use it’s own template files it’s templates directory first needs to be added to the list of template directories to be parsed.  In the future, this will be more streamlined however currently the following is the recommeded way:</p>\n<p><strong>myplugin/<strong>init</strong>.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_template_dir</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    path = os.path.join(os.path.basename(self.__file__, <span class=\"string\">'templates'</span>)</div><div class=\"line\">    app.add_template_dir(path)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    app.hook.register(<span class=\"string\">'post_setup'</span>, add_template_dir)</div></pre></td></tr></table></figure>\n<p>The above will append the directory <code>/path/to/myplugin/templates</code> to the list of template directories that the applications output handler with search for template files.</p>\n"},{"title":"Framework and Application Hooks","type":"guide","version":"2.10","order":12,"_content":"\nHooks allow the developers to tie into different pieces of the application. A hook can be defined anywhere, be it internally in the application, or in a plugin.  Once a hook is defined, functions can be registered to that hook so that when the hook is called, all functions registered to that hook will be run.  By defining a hook, you are saying that you are going to honor that hook somewhere in your application.  Using descriptive hook names are good for clarity.  For example, `pre_database_connect` is obviously a hook that will be run before a database connection is attempted.\n\nThe most important thing to remember when defining hooks for your application is to properly document them.  Include whether anything is expected in return or what, if any, arguments will be passed to the hook functions when called.\n\nAPI Reference:\n\n- [Cement Hook Module](/{{ version }}/api/core/hook.html)\n\n\n## Defining a Hook\n\nA hook can be defined anywhere, however it is generally recommended to define the hook as early as possible.  A hook definition simply gives a label to the hook, and allows the developer (or third-party plugin developers) to register functions to that hook.  It's label is arbitrary.\n\nThe most convenient way to define a hook is via `CementApp.Meta.define_hooks`:\n\n```python\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        define_hooks = ['my_example_hook']\n```\n\nAlternatively, if you need more control you might do it in `CementApp.setup()`:\n\n```python\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n\n    def setup(self):\n        # always run core setup first\n        super(MyApp, self).setup()\n\n        # define application hooks here\n        self.hook.define('my_example_hook')\n```\n\n\n## Registering Functions to a Hook\n\nA hook is just an identifier, but the functions registered to that hook are what get run when the hook is called.  Registering a hook function should also be done early on in the bootstrap process, any time after the application has been created, after the hook is defined, and before the hook is run.  Note that every hook is different, and therefore should be clearly documented by the 'owner' of the hook (application developer, plugin developer, etc).\n\nThe most convenient way to register a hook function is with `CementApp.Meta.hooks`:\n\n```python\nfrom cement.core.foundation import CementApp\n\ndef my_hook1(app):\n    pass\n\ndef my_hook2(app):\n    pass\n\nclass MyApp(CementApp):\n    class Meta:\n        hooks = [\n            ('post_argument_parsing', my_hook1),\n            ('pre_close', my_hook2),\n            ]\n\nwith MyApp() as app:\n    app.run()\n```\n\n\nWhere `CementApp.Meta.hooks` is a list of tuples that define the hook label, and the function to register to that hook.\n\nAlternatively, if you need more control you might use:\n\n```python\nfrom cement.core.foundation import CementApp\n\ndef my_hook1(app):\n    pass\n\nwith CementApp('myapp') as app:\n    app.hook.register('post_argument_parsing', my_hook1)\n    app.run()\n```\n\n\nOr, for a third-party plugin:\n\n```python\ndef my_hook1(app):\n    pass\n\ndef load(app):\n    app.hook.register('post_argument_parsing', my_hook1)\n```\n\n\nWhat you return depends on what the developer defining the hook is expecting. Each hook is different, and the nature of the hook determines whether you need to return anything or not.  That is up to the developer.  Also, the `args` and `kwargs` coming in depend on the developer.  You have to be familiar with the purpose of the defined hook in order to know whether you are receiving any `args` or `kwargs`.\n\n\n## Running a hook\n\nNow that a hook is defined, and functions have been registered to that hook all that is left is to run it.  Keep in mind, you don't want to run a hook until after the application load process... meaning, after all plugins and other code are loaded.  If you receive an error that the hook doesn't exist, then you are trying to register a hook too soon before the hook is defined. Likewise, if it doesn't seem like your hook is running and you don't see it mentioned in `--debug` output, you might be registering your hook **after** the hook has already run.\n\nThat said, this is how you run a hook:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    for res in app.hook.run('my_example_hook'):\n        # do something with res?\n        pass\n```\n\n\nAs you can see we iterate over the hook, rather than just calling `app.hook.run()` by itself.  This is necessary because `app.hook.run()` yields the results from each hook function as they are run.  Hooks can be run anywhere *after* the hook is defined, and hooks are registered to that hook.\n\n\n## Controlling Hook Run Order\n\nSometimes you might have a very specific purpose in mind for a hook, and need it to run before or after other functions in the same hook.  For that reason there is an optional `weight` parameter that can be passed when registering a hook function.\n\nThe following is an example application that defines, registers, and runs a custom application hook:\n\n```python\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n\n    def setup(self):\n        # always run core setup\n        super(MyApp, self).setup()\n\n        # define hooks in setup\n        self.hook.define('my_hook')\n\n\n# the following are the function that will run when ``my_hook`` is called\ndef func1(app):\n    print 'Inside hook func1'\n\ndef func2(app):\n    print 'Inside hook func2'\n\ndef func3(app):\n    print 'Inside hook func3'\n\n\nwith MyApp() as app:\n    # register all hook functions *after* the hook is defined (setup) but\n    # also *before* the hook is called (different for every hook)\n    app.hook.register('my_hook', func1, weight=0)\n    app.hook.register('my_hook', func2, weight=100)\n    app.hook.register('my_hook', func3, weight=-99)\n\n    # run the application\n    app.run()\n\n    # run our custom hook\n    for res in self.hook.run('my_hook', app):\n        pass\n```\n\n\nAnd the result is:\n\n```\n$ python my_hook_test.py\nInside hook func3\nInside hook func1\nInside hook func2\n```\n\n\nAs you can see, it doesn’t matter what order we register the hook, the weight runs then in order from lowest to highest.\n\n\n## Cement Framework Hooks\n\nCement has a number of hooks that tie into the framework.\n\n### pre_setup\n\nRun first when `CementApp.setup()` is called.  The application object is passed as an argument.  Nothing is expected in return.\n\n\n### post_setup\n\nRun last when `CementApp.setup()` is called.  The application object is passed as an argument.  Nothing is expected in return.\n\n\n### pre_run\n\nRun first when `CementApp.run()` is called.  The application object is passed as an argument.  Nothing is expected in return.\n\n\n### post_run\n\nRun last when `CementApp.run()` is called.  The application object is passed as an argument.  Nothing is expected in return.\n\n\n### pre_argument_parsing\n\nRun after `CementApp.run()` is called, just *before* argument parsing happens. The application object is passed as an argument to these hook functions.  Nothing is expected in return.\n\n\n### post_argument_parsing\n\nRun after `CementApp.run()` is called, just *after* argument parsing happens. The application object is passed as an argument to these hook functions.  Nothing is expected in return.\n\nThis hook is generally useful where the developer needs to perform actions based on the arguments that were passed at command line, but before the logic of `app.run()` happens.\n\n\n### pre_render\n\nRun first when `CementApp.render()` is called.  The application object, and data dictionary are passed as arguments.  Must return either the original data dictionary, or a modified one.\n\nNote: This does not affect anything that is 'printed' to console.\n\n\n### post_render\n\nRun last when `CementApp.render()` is called.  The application object, and rendered output text are passed as arguments.  Must return either the original output text, or a modified version.\n\n\n### pre_close\n\nRun first when `app.close()` is called.  This hook should be used by plugins and extensions to do any 'cleanup' at the end of program execution.  Nothing is expected in return.\n\n\n### post_close\n\nRun last when `app.close()` is called.  Most use cases need pre_close(), however this hook is available should one need to do anything after all other 'close' operations.\n\n\n### signal\n\nRun when signal handling is enabled, and the defined signal handler callback is executed.  This hook should be used by the application, plugins, and extensions to perform any actions when a specific signal is caught.  Nothing is expected in return.\n","source":"2.10/dev/hooks.md","raw":"---\ntitle: Framework and Application Hooks\ntype: guide\nversion: \"2.10\"\norder: 12\n---\n\nHooks allow the developers to tie into different pieces of the application. A hook can be defined anywhere, be it internally in the application, or in a plugin.  Once a hook is defined, functions can be registered to that hook so that when the hook is called, all functions registered to that hook will be run.  By defining a hook, you are saying that you are going to honor that hook somewhere in your application.  Using descriptive hook names are good for clarity.  For example, `pre_database_connect` is obviously a hook that will be run before a database connection is attempted.\n\nThe most important thing to remember when defining hooks for your application is to properly document them.  Include whether anything is expected in return or what, if any, arguments will be passed to the hook functions when called.\n\nAPI Reference:\n\n- [Cement Hook Module](/{{ version }}/api/core/hook.html)\n\n\n## Defining a Hook\n\nA hook can be defined anywhere, however it is generally recommended to define the hook as early as possible.  A hook definition simply gives a label to the hook, and allows the developer (or third-party plugin developers) to register functions to that hook.  It's label is arbitrary.\n\nThe most convenient way to define a hook is via `CementApp.Meta.define_hooks`:\n\n```python\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        define_hooks = ['my_example_hook']\n```\n\nAlternatively, if you need more control you might do it in `CementApp.setup()`:\n\n```python\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n\n    def setup(self):\n        # always run core setup first\n        super(MyApp, self).setup()\n\n        # define application hooks here\n        self.hook.define('my_example_hook')\n```\n\n\n## Registering Functions to a Hook\n\nA hook is just an identifier, but the functions registered to that hook are what get run when the hook is called.  Registering a hook function should also be done early on in the bootstrap process, any time after the application has been created, after the hook is defined, and before the hook is run.  Note that every hook is different, and therefore should be clearly documented by the 'owner' of the hook (application developer, plugin developer, etc).\n\nThe most convenient way to register a hook function is with `CementApp.Meta.hooks`:\n\n```python\nfrom cement.core.foundation import CementApp\n\ndef my_hook1(app):\n    pass\n\ndef my_hook2(app):\n    pass\n\nclass MyApp(CementApp):\n    class Meta:\n        hooks = [\n            ('post_argument_parsing', my_hook1),\n            ('pre_close', my_hook2),\n            ]\n\nwith MyApp() as app:\n    app.run()\n```\n\n\nWhere `CementApp.Meta.hooks` is a list of tuples that define the hook label, and the function to register to that hook.\n\nAlternatively, if you need more control you might use:\n\n```python\nfrom cement.core.foundation import CementApp\n\ndef my_hook1(app):\n    pass\n\nwith CementApp('myapp') as app:\n    app.hook.register('post_argument_parsing', my_hook1)\n    app.run()\n```\n\n\nOr, for a third-party plugin:\n\n```python\ndef my_hook1(app):\n    pass\n\ndef load(app):\n    app.hook.register('post_argument_parsing', my_hook1)\n```\n\n\nWhat you return depends on what the developer defining the hook is expecting. Each hook is different, and the nature of the hook determines whether you need to return anything or not.  That is up to the developer.  Also, the `args` and `kwargs` coming in depend on the developer.  You have to be familiar with the purpose of the defined hook in order to know whether you are receiving any `args` or `kwargs`.\n\n\n## Running a hook\n\nNow that a hook is defined, and functions have been registered to that hook all that is left is to run it.  Keep in mind, you don't want to run a hook until after the application load process... meaning, after all plugins and other code are loaded.  If you receive an error that the hook doesn't exist, then you are trying to register a hook too soon before the hook is defined. Likewise, if it doesn't seem like your hook is running and you don't see it mentioned in `--debug` output, you might be registering your hook **after** the hook has already run.\n\nThat said, this is how you run a hook:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    for res in app.hook.run('my_example_hook'):\n        # do something with res?\n        pass\n```\n\n\nAs you can see we iterate over the hook, rather than just calling `app.hook.run()` by itself.  This is necessary because `app.hook.run()` yields the results from each hook function as they are run.  Hooks can be run anywhere *after* the hook is defined, and hooks are registered to that hook.\n\n\n## Controlling Hook Run Order\n\nSometimes you might have a very specific purpose in mind for a hook, and need it to run before or after other functions in the same hook.  For that reason there is an optional `weight` parameter that can be passed when registering a hook function.\n\nThe following is an example application that defines, registers, and runs a custom application hook:\n\n```python\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n\n    def setup(self):\n        # always run core setup\n        super(MyApp, self).setup()\n\n        # define hooks in setup\n        self.hook.define('my_hook')\n\n\n# the following are the function that will run when ``my_hook`` is called\ndef func1(app):\n    print 'Inside hook func1'\n\ndef func2(app):\n    print 'Inside hook func2'\n\ndef func3(app):\n    print 'Inside hook func3'\n\n\nwith MyApp() as app:\n    # register all hook functions *after* the hook is defined (setup) but\n    # also *before* the hook is called (different for every hook)\n    app.hook.register('my_hook', func1, weight=0)\n    app.hook.register('my_hook', func2, weight=100)\n    app.hook.register('my_hook', func3, weight=-99)\n\n    # run the application\n    app.run()\n\n    # run our custom hook\n    for res in self.hook.run('my_hook', app):\n        pass\n```\n\n\nAnd the result is:\n\n```\n$ python my_hook_test.py\nInside hook func3\nInside hook func1\nInside hook func2\n```\n\n\nAs you can see, it doesn’t matter what order we register the hook, the weight runs then in order from lowest to highest.\n\n\n## Cement Framework Hooks\n\nCement has a number of hooks that tie into the framework.\n\n### pre_setup\n\nRun first when `CementApp.setup()` is called.  The application object is passed as an argument.  Nothing is expected in return.\n\n\n### post_setup\n\nRun last when `CementApp.setup()` is called.  The application object is passed as an argument.  Nothing is expected in return.\n\n\n### pre_run\n\nRun first when `CementApp.run()` is called.  The application object is passed as an argument.  Nothing is expected in return.\n\n\n### post_run\n\nRun last when `CementApp.run()` is called.  The application object is passed as an argument.  Nothing is expected in return.\n\n\n### pre_argument_parsing\n\nRun after `CementApp.run()` is called, just *before* argument parsing happens. The application object is passed as an argument to these hook functions.  Nothing is expected in return.\n\n\n### post_argument_parsing\n\nRun after `CementApp.run()` is called, just *after* argument parsing happens. The application object is passed as an argument to these hook functions.  Nothing is expected in return.\n\nThis hook is generally useful where the developer needs to perform actions based on the arguments that were passed at command line, but before the logic of `app.run()` happens.\n\n\n### pre_render\n\nRun first when `CementApp.render()` is called.  The application object, and data dictionary are passed as arguments.  Must return either the original data dictionary, or a modified one.\n\nNote: This does not affect anything that is 'printed' to console.\n\n\n### post_render\n\nRun last when `CementApp.render()` is called.  The application object, and rendered output text are passed as arguments.  Must return either the original output text, or a modified version.\n\n\n### pre_close\n\nRun first when `app.close()` is called.  This hook should be used by plugins and extensions to do any 'cleanup' at the end of program execution.  Nothing is expected in return.\n\n\n### post_close\n\nRun last when `app.close()` is called.  Most use cases need pre_close(), however this hook is available should one need to do anything after all other 'close' operations.\n\n\n### signal\n\nRun when signal handling is enabled, and the defined signal handler callback is executed.  This hook should be used by the application, plugins, and extensions to perform any actions when a specific signal is caught.  Nothing is expected in return.\n","date":"2017-08-09T04:42:03.000Z","updated":"2017-08-09T04:42:03.000Z","path":"2.10/dev/hooks.html","_id":"cj64io4vm0000wtpwgyp80b55","comments":1,"layout":"page","content":"<p>Hooks allow the developers to tie into different pieces of the application. A hook can be defined anywhere, be it internally in the application, or in a plugin.  Once a hook is defined, functions can be registered to that hook so that when the hook is called, all functions registered to that hook will be run.  By defining a hook, you are saying that you are going to honor that hook somewhere in your application.  Using descriptive hook names are good for clarity.  For example, <code>pre_database_connect</code> is obviously a hook that will be run before a database connection is attempted.</p>\n<p>The most important thing to remember when defining hooks for your application is to properly document them.  Include whether anything is expected in return or what, if any, arguments will be passed to the hook functions when called.</p>\n<p>API Reference:</p>\n<ul>\n<li><a href=\"/2.10/api/core/hook.html\">Cement Hook Module</a></li>\n</ul>\n<h2 id=\"Defining-a-Hook\"><a href=\"#Defining-a-Hook\" class=\"headerlink\" title=\"Defining a Hook\"></a>Defining a Hook</h2><p>A hook can be defined anywhere, however it is generally recommended to define the hook as early as possible.  A hook definition simply gives a label to the hook, and allows the developer (or third-party plugin developers) to register functions to that hook.  It’s label is arbitrary.</p>\n<p>The most convenient way to define a hook is via <code>CementApp.Meta.define_hooks</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        define_hooks = [<span class=\"string\">'my_example_hook'</span>]</div></pre></td></tr></table></figure>\n<p>Alternatively, if you need more control you might do it in <code>CementApp.setup()</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">setup</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"comment\"># always run core setup first</span></div><div class=\"line\">        super(MyApp, self).setup()</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># define application hooks here</span></div><div class=\"line\">        self.hook.define(<span class=\"string\">'my_example_hook'</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"Registering-Functions-to-a-Hook\"><a href=\"#Registering-Functions-to-a-Hook\" class=\"headerlink\" title=\"Registering Functions to a Hook\"></a>Registering Functions to a Hook</h2><p>A hook is just an identifier, but the functions registered to that hook are what get run when the hook is called.  Registering a hook function should also be done early on in the bootstrap process, any time after the application has been created, after the hook is defined, and before the hook is run.  Note that every hook is different, and therefore should be clearly documented by the ‘owner’ of the hook (application developer, plugin developer, etc).</p>\n<p>The most convenient way to register a hook function is with <code>CementApp.Meta.hooks</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_hook1</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_hook2</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        hooks = [</div><div class=\"line\">            (<span class=\"string\">'post_argument_parsing'</span>, my_hook1),</div><div class=\"line\">            (<span class=\"string\">'pre_close'</span>, my_hook2),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>Where <code>CementApp.Meta.hooks</code> is a list of tuples that define the hook label, and the function to register to that hook.</p>\n<p>Alternatively, if you need more control you might use:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_hook1</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.hook.register(<span class=\"string\">'post_argument_parsing'</span>, my_hook1)</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>Or, for a third-party plugin:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_hook1</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    app.hook.register(<span class=\"string\">'post_argument_parsing'</span>, my_hook1)</div></pre></td></tr></table></figure>\n<p>What you return depends on what the developer defining the hook is expecting. Each hook is different, and the nature of the hook determines whether you need to return anything or not.  That is up to the developer.  Also, the <code>args</code> and <code>kwargs</code> coming in depend on the developer.  You have to be familiar with the purpose of the defined hook in order to know whether you are receiving any <code>args</code> or <code>kwargs</code>.</p>\n<h2 id=\"Running-a-hook\"><a href=\"#Running-a-hook\" class=\"headerlink\" title=\"Running a hook\"></a>Running a hook</h2><p>Now that a hook is defined, and functions have been registered to that hook all that is left is to run it.  Keep in mind, you don’t want to run a hook until after the application load process… meaning, after all plugins and other code are loaded.  If you receive an error that the hook doesn’t exist, then you are trying to register a hook too soon before the hook is defined. Likewise, if it doesn’t seem like your hook is running and you don’t see it mentioned in <code>--debug</code> output, you might be registering your hook <strong>after</strong> the hook has already run.</p>\n<p>That said, this is how you run a hook:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"keyword\">for</span> res <span class=\"keyword\">in</span> app.hook.run(<span class=\"string\">'my_example_hook'</span>):</div><div class=\"line\">        <span class=\"comment\"># do something with res?</span></div><div class=\"line\">        <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure>\n<p>As you can see we iterate over the hook, rather than just calling <code>app.hook.run()</code> by itself.  This is necessary because <code>app.hook.run()</code> yields the results from each hook function as they are run.  Hooks can be run anywhere <em>after</em> the hook is defined, and hooks are registered to that hook.</p>\n<h2 id=\"Controlling-Hook-Run-Order\"><a href=\"#Controlling-Hook-Run-Order\" class=\"headerlink\" title=\"Controlling Hook Run Order\"></a>Controlling Hook Run Order</h2><p>Sometimes you might have a very specific purpose in mind for a hook, and need it to run before or after other functions in the same hook.  For that reason there is an optional <code>weight</code> parameter that can be passed when registering a hook function.</p>\n<p>The following is an example application that defines, registers, and runs a custom application hook:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">setup</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"comment\"># always run core setup</span></div><div class=\"line\">        super(MyApp, self).setup()</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># define hooks in setup</span></div><div class=\"line\">        self.hook.define(<span class=\"string\">'my_hook'</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># the following are the function that will run when ``my_hook`` is called</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func1</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'Inside hook func1'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func2</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'Inside hook func2'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func3</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'Inside hook func3'</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># register all hook functions *after* the hook is defined (setup) but</span></div><div class=\"line\">    <span class=\"comment\"># also *before* the hook is called (different for every hook)</span></div><div class=\"line\">    app.hook.register(<span class=\"string\">'my_hook'</span>, func1, weight=<span class=\"number\">0</span>)</div><div class=\"line\">    app.hook.register(<span class=\"string\">'my_hook'</span>, func2, weight=<span class=\"number\">100</span>)</div><div class=\"line\">    app.hook.register(<span class=\"string\">'my_hook'</span>, func3, weight=<span class=\"number\">-99</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># run the application</span></div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># run our custom hook</span></div><div class=\"line\">    <span class=\"keyword\">for</span> res <span class=\"keyword\">in</span> self.hook.run(<span class=\"string\">'my_hook'</span>, app):</div><div class=\"line\">        <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure>\n<p>And the result is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python my_hook_test.py</div><div class=\"line\">Inside hook func3</div><div class=\"line\">Inside hook func1</div><div class=\"line\">Inside hook func2</div></pre></td></tr></table></figure>\n<p>As you can see, it doesn’t matter what order we register the hook, the weight runs then in order from lowest to highest.</p>\n<h2 id=\"Cement-Framework-Hooks\"><a href=\"#Cement-Framework-Hooks\" class=\"headerlink\" title=\"Cement Framework Hooks\"></a>Cement Framework Hooks</h2><p>Cement has a number of hooks that tie into the framework.</p>\n<h3 id=\"pre-setup\"><a href=\"#pre-setup\" class=\"headerlink\" title=\"pre_setup\"></a>pre_setup</h3><p>Run first when <code>CementApp.setup()</code> is called.  The application object is passed as an argument.  Nothing is expected in return.</p>\n<h3 id=\"post-setup\"><a href=\"#post-setup\" class=\"headerlink\" title=\"post_setup\"></a>post_setup</h3><p>Run last when <code>CementApp.setup()</code> is called.  The application object is passed as an argument.  Nothing is expected in return.</p>\n<h3 id=\"pre-run\"><a href=\"#pre-run\" class=\"headerlink\" title=\"pre_run\"></a>pre_run</h3><p>Run first when <code>CementApp.run()</code> is called.  The application object is passed as an argument.  Nothing is expected in return.</p>\n<h3 id=\"post-run\"><a href=\"#post-run\" class=\"headerlink\" title=\"post_run\"></a>post_run</h3><p>Run last when <code>CementApp.run()</code> is called.  The application object is passed as an argument.  Nothing is expected in return.</p>\n<h3 id=\"pre-argument-parsing\"><a href=\"#pre-argument-parsing\" class=\"headerlink\" title=\"pre_argument_parsing\"></a>pre_argument_parsing</h3><p>Run after <code>CementApp.run()</code> is called, just <em>before</em> argument parsing happens. The application object is passed as an argument to these hook functions.  Nothing is expected in return.</p>\n<h3 id=\"post-argument-parsing\"><a href=\"#post-argument-parsing\" class=\"headerlink\" title=\"post_argument_parsing\"></a>post_argument_parsing</h3><p>Run after <code>CementApp.run()</code> is called, just <em>after</em> argument parsing happens. The application object is passed as an argument to these hook functions.  Nothing is expected in return.</p>\n<p>This hook is generally useful where the developer needs to perform actions based on the arguments that were passed at command line, but before the logic of <code>app.run()</code> happens.</p>\n<h3 id=\"pre-render\"><a href=\"#pre-render\" class=\"headerlink\" title=\"pre_render\"></a>pre_render</h3><p>Run first when <code>CementApp.render()</code> is called.  The application object, and data dictionary are passed as arguments.  Must return either the original data dictionary, or a modified one.</p>\n<p>Note: This does not affect anything that is ‘printed’ to console.</p>\n<h3 id=\"post-render\"><a href=\"#post-render\" class=\"headerlink\" title=\"post_render\"></a>post_render</h3><p>Run last when <code>CementApp.render()</code> is called.  The application object, and rendered output text are passed as arguments.  Must return either the original output text, or a modified version.</p>\n<h3 id=\"pre-close\"><a href=\"#pre-close\" class=\"headerlink\" title=\"pre_close\"></a>pre_close</h3><p>Run first when <code>app.close()</code> is called.  This hook should be used by plugins and extensions to do any ‘cleanup’ at the end of program execution.  Nothing is expected in return.</p>\n<h3 id=\"post-close\"><a href=\"#post-close\" class=\"headerlink\" title=\"post_close\"></a>post_close</h3><p>Run last when <code>app.close()</code> is called.  Most use cases need pre_close(), however this hook is available should one need to do anything after all other ‘close’ operations.</p>\n<h3 id=\"signal\"><a href=\"#signal\" class=\"headerlink\" title=\"signal\"></a>signal</h3><p>Run when signal handling is enabled, and the defined signal handler callback is executed.  This hook should be used by the application, plugins, and extensions to perform any actions when a specific signal is caught.  Nothing is expected in return.</p>\n","excerpt":"","more":"<p>Hooks allow the developers to tie into different pieces of the application. A hook can be defined anywhere, be it internally in the application, or in a plugin.  Once a hook is defined, functions can be registered to that hook so that when the hook is called, all functions registered to that hook will be run.  By defining a hook, you are saying that you are going to honor that hook somewhere in your application.  Using descriptive hook names are good for clarity.  For example, <code>pre_database_connect</code> is obviously a hook that will be run before a database connection is attempted.</p>\n<p>The most important thing to remember when defining hooks for your application is to properly document them.  Include whether anything is expected in return or what, if any, arguments will be passed to the hook functions when called.</p>\n<p>API Reference:</p>\n<ul>\n<li><a href=\"/2.10/api/core/hook.html\">Cement Hook Module</a></li>\n</ul>\n<h2 id=\"Defining-a-Hook\"><a href=\"#Defining-a-Hook\" class=\"headerlink\" title=\"Defining a Hook\"></a>Defining a Hook</h2><p>A hook can be defined anywhere, however it is generally recommended to define the hook as early as possible.  A hook definition simply gives a label to the hook, and allows the developer (or third-party plugin developers) to register functions to that hook.  It’s label is arbitrary.</p>\n<p>The most convenient way to define a hook is via <code>CementApp.Meta.define_hooks</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        define_hooks = [<span class=\"string\">'my_example_hook'</span>]</div></pre></td></tr></table></figure>\n<p>Alternatively, if you need more control you might do it in <code>CementApp.setup()</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">setup</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"comment\"># always run core setup first</span></div><div class=\"line\">        super(MyApp, self).setup()</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># define application hooks here</span></div><div class=\"line\">        self.hook.define(<span class=\"string\">'my_example_hook'</span>)</div></pre></td></tr></table></figure>\n<h2 id=\"Registering-Functions-to-a-Hook\"><a href=\"#Registering-Functions-to-a-Hook\" class=\"headerlink\" title=\"Registering Functions to a Hook\"></a>Registering Functions to a Hook</h2><p>A hook is just an identifier, but the functions registered to that hook are what get run when the hook is called.  Registering a hook function should also be done early on in the bootstrap process, any time after the application has been created, after the hook is defined, and before the hook is run.  Note that every hook is different, and therefore should be clearly documented by the ‘owner’ of the hook (application developer, plugin developer, etc).</p>\n<p>The most convenient way to register a hook function is with <code>CementApp.Meta.hooks</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_hook1</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_hook2</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        hooks = [</div><div class=\"line\">            (<span class=\"string\">'post_argument_parsing'</span>, my_hook1),</div><div class=\"line\">            (<span class=\"string\">'pre_close'</span>, my_hook2),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>Where <code>CementApp.Meta.hooks</code> is a list of tuples that define the hook label, and the function to register to that hook.</p>\n<p>Alternatively, if you need more control you might use:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_hook1</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.hook.register(<span class=\"string\">'post_argument_parsing'</span>, my_hook1)</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>Or, for a third-party plugin:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_hook1</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    app.hook.register(<span class=\"string\">'post_argument_parsing'</span>, my_hook1)</div></pre></td></tr></table></figure>\n<p>What you return depends on what the developer defining the hook is expecting. Each hook is different, and the nature of the hook determines whether you need to return anything or not.  That is up to the developer.  Also, the <code>args</code> and <code>kwargs</code> coming in depend on the developer.  You have to be familiar with the purpose of the defined hook in order to know whether you are receiving any <code>args</code> or <code>kwargs</code>.</p>\n<h2 id=\"Running-a-hook\"><a href=\"#Running-a-hook\" class=\"headerlink\" title=\"Running a hook\"></a>Running a hook</h2><p>Now that a hook is defined, and functions have been registered to that hook all that is left is to run it.  Keep in mind, you don’t want to run a hook until after the application load process… meaning, after all plugins and other code are loaded.  If you receive an error that the hook doesn’t exist, then you are trying to register a hook too soon before the hook is defined. Likewise, if it doesn’t seem like your hook is running and you don’t see it mentioned in <code>--debug</code> output, you might be registering your hook <strong>after</strong> the hook has already run.</p>\n<p>That said, this is how you run a hook:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"keyword\">for</span> res <span class=\"keyword\">in</span> app.hook.run(<span class=\"string\">'my_example_hook'</span>):</div><div class=\"line\">        <span class=\"comment\"># do something with res?</span></div><div class=\"line\">        <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure>\n<p>As you can see we iterate over the hook, rather than just calling <code>app.hook.run()</code> by itself.  This is necessary because <code>app.hook.run()</code> yields the results from each hook function as they are run.  Hooks can be run anywhere <em>after</em> the hook is defined, and hooks are registered to that hook.</p>\n<h2 id=\"Controlling-Hook-Run-Order\"><a href=\"#Controlling-Hook-Run-Order\" class=\"headerlink\" title=\"Controlling Hook Run Order\"></a>Controlling Hook Run Order</h2><p>Sometimes you might have a very specific purpose in mind for a hook, and need it to run before or after other functions in the same hook.  For that reason there is an optional <code>weight</code> parameter that can be passed when registering a hook function.</p>\n<p>The following is an example application that defines, registers, and runs a custom application hook:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">setup</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"comment\"># always run core setup</span></div><div class=\"line\">        super(MyApp, self).setup()</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># define hooks in setup</span></div><div class=\"line\">        self.hook.define(<span class=\"string\">'my_hook'</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># the following are the function that will run when ``my_hook`` is called</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func1</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'Inside hook func1'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func2</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'Inside hook func2'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func3</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'Inside hook func3'</span></div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># register all hook functions *after* the hook is defined (setup) but</span></div><div class=\"line\">    <span class=\"comment\"># also *before* the hook is called (different for every hook)</span></div><div class=\"line\">    app.hook.register(<span class=\"string\">'my_hook'</span>, func1, weight=<span class=\"number\">0</span>)</div><div class=\"line\">    app.hook.register(<span class=\"string\">'my_hook'</span>, func2, weight=<span class=\"number\">100</span>)</div><div class=\"line\">    app.hook.register(<span class=\"string\">'my_hook'</span>, func3, weight=<span class=\"number\">-99</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># run the application</span></div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># run our custom hook</span></div><div class=\"line\">    <span class=\"keyword\">for</span> res <span class=\"keyword\">in</span> self.hook.run(<span class=\"string\">'my_hook'</span>, app):</div><div class=\"line\">        <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure>\n<p>And the result is:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python my_hook_test.py</div><div class=\"line\">Inside hook func3</div><div class=\"line\">Inside hook func1</div><div class=\"line\">Inside hook func2</div></pre></td></tr></table></figure>\n<p>As you can see, it doesn’t matter what order we register the hook, the weight runs then in order from lowest to highest.</p>\n<h2 id=\"Cement-Framework-Hooks\"><a href=\"#Cement-Framework-Hooks\" class=\"headerlink\" title=\"Cement Framework Hooks\"></a>Cement Framework Hooks</h2><p>Cement has a number of hooks that tie into the framework.</p>\n<h3 id=\"pre-setup\"><a href=\"#pre-setup\" class=\"headerlink\" title=\"pre_setup\"></a>pre_setup</h3><p>Run first when <code>CementApp.setup()</code> is called.  The application object is passed as an argument.  Nothing is expected in return.</p>\n<h3 id=\"post-setup\"><a href=\"#post-setup\" class=\"headerlink\" title=\"post_setup\"></a>post_setup</h3><p>Run last when <code>CementApp.setup()</code> is called.  The application object is passed as an argument.  Nothing is expected in return.</p>\n<h3 id=\"pre-run\"><a href=\"#pre-run\" class=\"headerlink\" title=\"pre_run\"></a>pre_run</h3><p>Run first when <code>CementApp.run()</code> is called.  The application object is passed as an argument.  Nothing is expected in return.</p>\n<h3 id=\"post-run\"><a href=\"#post-run\" class=\"headerlink\" title=\"post_run\"></a>post_run</h3><p>Run last when <code>CementApp.run()</code> is called.  The application object is passed as an argument.  Nothing is expected in return.</p>\n<h3 id=\"pre-argument-parsing\"><a href=\"#pre-argument-parsing\" class=\"headerlink\" title=\"pre_argument_parsing\"></a>pre_argument_parsing</h3><p>Run after <code>CementApp.run()</code> is called, just <em>before</em> argument parsing happens. The application object is passed as an argument to these hook functions.  Nothing is expected in return.</p>\n<h3 id=\"post-argument-parsing\"><a href=\"#post-argument-parsing\" class=\"headerlink\" title=\"post_argument_parsing\"></a>post_argument_parsing</h3><p>Run after <code>CementApp.run()</code> is called, just <em>after</em> argument parsing happens. The application object is passed as an argument to these hook functions.  Nothing is expected in return.</p>\n<p>This hook is generally useful where the developer needs to perform actions based on the arguments that were passed at command line, but before the logic of <code>app.run()</code> happens.</p>\n<h3 id=\"pre-render\"><a href=\"#pre-render\" class=\"headerlink\" title=\"pre_render\"></a>pre_render</h3><p>Run first when <code>CementApp.render()</code> is called.  The application object, and data dictionary are passed as arguments.  Must return either the original data dictionary, or a modified one.</p>\n<p>Note: This does not affect anything that is ‘printed’ to console.</p>\n<h3 id=\"post-render\"><a href=\"#post-render\" class=\"headerlink\" title=\"post_render\"></a>post_render</h3><p>Run last when <code>CementApp.render()</code> is called.  The application object, and rendered output text are passed as arguments.  Must return either the original output text, or a modified version.</p>\n<h3 id=\"pre-close\"><a href=\"#pre-close\" class=\"headerlink\" title=\"pre_close\"></a>pre_close</h3><p>Run first when <code>app.close()</code> is called.  This hook should be used by plugins and extensions to do any ‘cleanup’ at the end of program execution.  Nothing is expected in return.</p>\n<h3 id=\"post-close\"><a href=\"#post-close\" class=\"headerlink\" title=\"post_close\"></a>post_close</h3><p>Run last when <code>app.close()</code> is called.  Most use cases need pre_close(), however this hook is available should one need to do anything after all other ‘close’ operations.</p>\n<h3 id=\"signal\"><a href=\"#signal\" class=\"headerlink\" title=\"signal\"></a>signal</h3><p>Run when signal handling is enabled, and the defined signal handler callback is executed.  This hook should be used by the application, plugins, and extensions to perform any actions when a specific signal is caught.  Nothing is expected in return.</p>\n"},{"title":"Extending CementApp","type":"guide","version":"2.10","order":13,"_content":"\nCementApp provides a convenient `extend` mechanism that allows plugins, extensions, or the app itself to add objects/functions to the global application object.  For example, a plugin might extend the CementApp with an  `api` member allowing developers to call `app.api.get(...)`.  The application itself does not provide `app.api` however the plugin does.  As plugins are often third party, it is not possible for the plugin developer to simply sub-class the CementApp and add the functionality because the CementApp is already instantiated by the time plugins are loaded.\n\nTake the following for example:\n\n**myapp.py**\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    app.run()\n```\n\nThe above is a very simple Cement application, which obviously doesn't do much.  That said, we can add a plugin that extends the application to add an API client object, for example, pretty easily.  Note the following is an arbitrary and non-functional example using dRest:\n\n**/etc/myapp/plugins.d/api.conf**\n\n```\n[api]\nenable_plugin = true\nendpoint = https://example.com/api/v1\nuser = john.doe\npassword = XXXXXXXXXXXX\n```\n\n**/var/lib/myapp/plugins/api.py**\n\n```python\nimport drest\nfrom cement.core import hook\n\ndef extend_api_object(app):\n    # get api info from this plugins configuration\n    endpoint = app.config.get('api', 'endpoint')\n    user = app.config.get('api', 'user')\n    password = app.config.get('api', 'password')\n\n    # create an api object and authenticate\n    my_api_client = drest.API(endpoint)\n    my_api_client.auth(username, password)\n\n    # extend the global app object with an ``api`` member\n    app.extend('api', my_api_client)\n\ndef load(app):\n    hook.register('pre_run', extend_api_object)\n```\n\nIn the above plugin, we simply created a dRest API client within a `pre_run` hook and then extended the global `app` with it.  The developer can now reference `app.api` anywhere that the global `app` object is accessible.\n\nOur application code could now look like:\n\n**myapp.py**\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    app.run()\n\n    # use the api object that the plugin provides\n    app.api.get(...)\n```\n","source":"2.10/dev/extending_cementapp.md","raw":"---\ntitle: Extending CementApp\ntype: guide\nversion: \"2.10\"\norder: 13\n---\n\nCementApp provides a convenient `extend` mechanism that allows plugins, extensions, or the app itself to add objects/functions to the global application object.  For example, a plugin might extend the CementApp with an  `api` member allowing developers to call `app.api.get(...)`.  The application itself does not provide `app.api` however the plugin does.  As plugins are often third party, it is not possible for the plugin developer to simply sub-class the CementApp and add the functionality because the CementApp is already instantiated by the time plugins are loaded.\n\nTake the following for example:\n\n**myapp.py**\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    app.run()\n```\n\nThe above is a very simple Cement application, which obviously doesn't do much.  That said, we can add a plugin that extends the application to add an API client object, for example, pretty easily.  Note the following is an arbitrary and non-functional example using dRest:\n\n**/etc/myapp/plugins.d/api.conf**\n\n```\n[api]\nenable_plugin = true\nendpoint = https://example.com/api/v1\nuser = john.doe\npassword = XXXXXXXXXXXX\n```\n\n**/var/lib/myapp/plugins/api.py**\n\n```python\nimport drest\nfrom cement.core import hook\n\ndef extend_api_object(app):\n    # get api info from this plugins configuration\n    endpoint = app.config.get('api', 'endpoint')\n    user = app.config.get('api', 'user')\n    password = app.config.get('api', 'password')\n\n    # create an api object and authenticate\n    my_api_client = drest.API(endpoint)\n    my_api_client.auth(username, password)\n\n    # extend the global app object with an ``api`` member\n    app.extend('api', my_api_client)\n\ndef load(app):\n    hook.register('pre_run', extend_api_object)\n```\n\nIn the above plugin, we simply created a dRest API client within a `pre_run` hook and then extended the global `app` with it.  The developer can now reference `app.api` anywhere that the global `app` object is accessible.\n\nOur application code could now look like:\n\n**myapp.py**\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    app.run()\n\n    # use the api object that the plugin provides\n    app.api.get(...)\n```\n","date":"2017-08-09T05:08:32.000Z","updated":"2017-08-09T05:08:32.000Z","path":"2.10/dev/extending_cementapp.html","_id":"cj64jauqq0001wtpwfaz8q6ug","comments":1,"layout":"page","content":"<p>CementApp provides a convenient <code>extend</code> mechanism that allows plugins, extensions, or the app itself to add objects/functions to the global application object.  For example, a plugin might extend the CementApp with an  <code>api</code> member allowing developers to call <code>app.api.get(...)</code>.  The application itself does not provide <code>app.api</code> however the plugin does.  As plugins are often third party, it is not possible for the plugin developer to simply sub-class the CementApp and add the functionality because the CementApp is already instantiated by the time plugins are loaded.</p>\n<p>Take the following for example:</p>\n<p><strong>myapp.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>The above is a very simple Cement application, which obviously doesn’t do much.  That said, we can add a plugin that extends the application to add an API client object, for example, pretty easily.  Note the following is an arbitrary and non-functional example using dRest:</p>\n<p><strong>/etc/myapp/plugins.d/api.conf</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[api]</div><div class=\"line\">enable_plugin = true</div><div class=\"line\">endpoint = https://example.com/api/v1</div><div class=\"line\">user = john.doe</div><div class=\"line\">password = XXXXXXXXXXXX</div></pre></td></tr></table></figure>\n<p><strong>/var/lib/myapp/plugins/api.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> drest</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> hook</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">extend_api_object</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># get api info from this plugins configuration</span></div><div class=\"line\">    endpoint = app.config.get(<span class=\"string\">'api'</span>, <span class=\"string\">'endpoint'</span>)</div><div class=\"line\">    user = app.config.get(<span class=\"string\">'api'</span>, <span class=\"string\">'user'</span>)</div><div class=\"line\">    password = app.config.get(<span class=\"string\">'api'</span>, <span class=\"string\">'password'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># create an api object and authenticate</span></div><div class=\"line\">    my_api_client = drest.API(endpoint)</div><div class=\"line\">    my_api_client.auth(username, password)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># extend the global app object with an ``api`` member</span></div><div class=\"line\">    app.extend(<span class=\"string\">'api'</span>, my_api_client)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    hook.register(<span class=\"string\">'pre_run'</span>, extend_api_object)</div></pre></td></tr></table></figure>\n<p>In the above plugin, we simply created a dRest API client within a <code>pre_run</code> hook and then extended the global <code>app</code> with it.  The developer can now reference <code>app.api</code> anywhere that the global <code>app</code> object is accessible.</p>\n<p>Our application code could now look like:</p>\n<p><strong>myapp.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># use the api object that the plugin provides</span></div><div class=\"line\">    app.api.get(...)</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>CementApp provides a convenient <code>extend</code> mechanism that allows plugins, extensions, or the app itself to add objects/functions to the global application object.  For example, a plugin might extend the CementApp with an  <code>api</code> member allowing developers to call <code>app.api.get(...)</code>.  The application itself does not provide <code>app.api</code> however the plugin does.  As plugins are often third party, it is not possible for the plugin developer to simply sub-class the CementApp and add the functionality because the CementApp is already instantiated by the time plugins are loaded.</p>\n<p>Take the following for example:</p>\n<p><strong>myapp.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>The above is a very simple Cement application, which obviously doesn’t do much.  That said, we can add a plugin that extends the application to add an API client object, for example, pretty easily.  Note the following is an arbitrary and non-functional example using dRest:</p>\n<p><strong>/etc/myapp/plugins.d/api.conf</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[api]</div><div class=\"line\">enable_plugin = true</div><div class=\"line\">endpoint = https://example.com/api/v1</div><div class=\"line\">user = john.doe</div><div class=\"line\">password = XXXXXXXXXXXX</div></pre></td></tr></table></figure>\n<p><strong>/var/lib/myapp/plugins/api.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> drest</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> hook</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">extend_api_object</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># get api info from this plugins configuration</span></div><div class=\"line\">    endpoint = app.config.get(<span class=\"string\">'api'</span>, <span class=\"string\">'endpoint'</span>)</div><div class=\"line\">    user = app.config.get(<span class=\"string\">'api'</span>, <span class=\"string\">'user'</span>)</div><div class=\"line\">    password = app.config.get(<span class=\"string\">'api'</span>, <span class=\"string\">'password'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># create an api object and authenticate</span></div><div class=\"line\">    my_api_client = drest.API(endpoint)</div><div class=\"line\">    my_api_client.auth(username, password)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># extend the global app object with an ``api`` member</span></div><div class=\"line\">    app.extend(<span class=\"string\">'api'</span>, my_api_client)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">load</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    hook.register(<span class=\"string\">'pre_run'</span>, extend_api_object)</div></pre></td></tr></table></figure>\n<p>In the above plugin, we simply created a dRest API client within a <code>pre_run</code> hook and then extended the global <code>app</code> with it.  The developer can now reference <code>app.api</code> anywhere that the global <code>app</code> object is accessible.</p>\n<p>Our application code could now look like:</p>\n<p><strong>myapp.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># use the api object that the plugin provides</span></div><div class=\"line\">    app.api.get(...)</div></pre></td></tr></table></figure>\n"},{"title":"Signal Handling","type":"guide","version":"2.10","order":14,"_content":"\nPython provides the [Signal](http://docs.python.org/library/signal.html) library allowing developers to catch Unix signals and set handlers for asynchronous events.  For example, the `SIGTERM` (Terminate) signal is received when issuing a `kill` command for a given Unix process.  Via the signal library, we can set a handler (function) callback that will be executed when that signal is received.  Some signals however can not be handled/caught, such as the `SIGKILL` signal (i.e. `kill -9`).  Please refer to the [Signal](http://docs.python.org/library/signal.html) library documentation for a full understanding of its use and capabilities.\n\nA caveat when setting a signal handler is that only one handler can be defined for a given signal.  Therefore, all handling must be done from a single callback function.  This is a slight roadblock for applications built on Cement in that many pieces of the framework are broken out into independent extensions as well as applications that have 3rd party plugins.  The trouble happens when the application, plugins, and framework extensions all need to perform some action when a signal is caught.  This section outlines the recommended way of handling signals with Cement versus manually setting signal handlers that may collide.\n\n**Important Note**\n\nIt is important to note that it is not necessary to use the Cement mechanisms for signal handling, what-so-ever.  That said, the primary concern of the framework is that `app.close()` is called no matter what the situation. Therefore, if you decide to disable signal handling all together you **must** ensure that you at the very least catch `signal.SIGTERM` and `signal.SIGINT` with the ability to call `app.close()`.  You will likely find that it is more complex than you might think.  The reason we put these mechanisms in place is primarily that we found it was the best way to a) handle a signal, and b) have access to our `app` object in order to be able to call `app.close()` when a process is terminated.\n\n\n## Signals Caught by Default\n\nBy default Cement catches the signals `SIGTERM` and `SIGINT`.  When these signals are caught, Cement raises the exception `CaughtSignal(signum, frame)` where `signum` and `frame` are the parameters passed to the signal handler. By raising an exception, we are able to pass runtime back to our applications main process (within a try/except block) and maintain the ability to access our 'application' object without using global objects.\n\nA basic application using default handling might look like:\n\n```python\nimport signal\nfrom cement.core.foundation import CementApp\nfrom cement.core.exc import CaughtSignal\n\nwith CementApp('myapp') as app:\n    try:\n        app.run()\n    except CaughtSignal as e:\n        # do something with e.signum or e.frame (passed from signal)\n        if e.signum == signal.SIGTERM:\n            print(\"Caught SIGTERM...\")\n        elif e.signum == signal.SIGINT:\n            print(\"Caught SIGINT...\")\n```\n\n\nThe above provides a very simple means of handling the most common signals, which in turns allows our application to \"exit clean\" by running `app.close()` and any `pre_close` or `post_close` hooks.  If we don't catch the signals, then the exceptions will be unhandled and the application will not exit clean.\n\n\n## Using The Signal Hook\n\nAn alternative way of adding multiple callbacks to a signal handler is by using the Cement signal hook.  This hook is called anytime a handled signal is encountered.\n\n```python\nimport signal\nfrom cement.core.foundation import CementApp\nfrom cement.core.exc import CaughtSignal\n\ndef my_signal_handler(app, signum, frame):\n    # do something with app?\n    pass\n\n    # or do something with signum or frame\n    if signum == signal.SIGTERM:\n        print(\"Caught SIGTERM...\")\n    elif signum == signal.SIGINT:\n        print(\"Caught SIGINT...\")\n\nwith CementApp('myapp') as app:\n    hook.register('signal', my_signal_handler)\n\n    try:\n        app.run()\n    except CaughtSignal as e:\n        # do soemthing with e.signum, e.frame\n        pass\n```\n\nThe key thing to note here is that the main application itself can easily handle the `CaughtSignal` exception without using hooks, however using the `signal` hook is useful for plugins and extensions to be able to tie into the signal handling outside of the main application.  Both serve the same purpose.\n\nRegardless of how signals are handled, all extensions or plugins should use the `pre_close` hook for cleanup purposes as much as possible as it is always run when `app.close()` is called.\n\n\n## Configuring Which Signals To Catch\n\nYou can define other signals to catch by passing a list of `catch_signals` to `foundation.CementApp()`:\n\n```python\nimport signal\nfrom cement.core.foundation import CementApp\n\nSIGNALS = [signal.SIGTERM, signal.SIGINT, signal.SIGHUP]\n\nCementApp('myapp', catch_signals=SIGNALS)\n# ...\n```\n\nWhat happens is, Cement iterates over the catch_signals list and adds a generic handler function (the same) for each signal.  Because the handler calls the cement `signal` hook, and then raises an exception which both pass the `signum` and `frame` parameters, you are able to handle the logic elsewhere rather than assigning a unique callback function for every signal.\n\n\n## What If I Don't Like Your Signal Handler Callback?\n\nIf you want more control over what happens when a signal is caught, you are more than welcome to override the default signal handler callback.  That said, please be kind and be sure to at least run the cement `signal` hook within your callback.\n\nThe following is an example taken from the builtin callback handler.  Note that there is a bit of hackery in how we are acquiring the `CementApp` from the frame.  This is because the signal is picked up outside of our control so we need to find it.\n\n```python\nimport signal\nfrom cement.core.foundation import CementApp\n\ndef cement_signal_handler(signum, frame):\n    \"\"\"\n    Catch a signal, run the `signal` hook, and then raise an exception\n    allowing the app to handle logic elsewhere.\n\n    :param signum: The signal number\n    :param frame: The signal frame.\n    :raises: cement.core.exc.CaughtSignal\n\n    \"\"\"\n    LOG.debug('Caught signal %s' % signum)\n\n    # hackish, but we do not have direct access to the CementApp object\n    for f_global in frame.f_globals.values():\n        if isinstance(f_global, CementApp):\n            app = f_global\n            for res in app.hook.run('signal', app, signum, frame):\n                pass\n    raise exc.CaughtSignal(signum, frame)\n\n\nwith CementApp('myapp') as app:\n    try:\n        app.run()\n    except CaughtSignal as e:\n        # do something with e.signum, or e.frame\n        pass\n```\n\n\n## This Is Stupid, and UnPythonic - How Do I Disable It?\n\nTo each their own.  If you simply do not want any kind of signal handling performed, just set `catch_signals=None`.\n\n```python\nfrom cement.core.foundation import foundation\n\nCementApp('myapp', catch_signals=None)\n```\n","source":"2.10/dev/signal_handling.md","raw":"---\ntitle: Signal Handling\ntype: guide\nversion: \"2.10\"\norder: 14\n---\n\nPython provides the [Signal](http://docs.python.org/library/signal.html) library allowing developers to catch Unix signals and set handlers for asynchronous events.  For example, the `SIGTERM` (Terminate) signal is received when issuing a `kill` command for a given Unix process.  Via the signal library, we can set a handler (function) callback that will be executed when that signal is received.  Some signals however can not be handled/caught, such as the `SIGKILL` signal (i.e. `kill -9`).  Please refer to the [Signal](http://docs.python.org/library/signal.html) library documentation for a full understanding of its use and capabilities.\n\nA caveat when setting a signal handler is that only one handler can be defined for a given signal.  Therefore, all handling must be done from a single callback function.  This is a slight roadblock for applications built on Cement in that many pieces of the framework are broken out into independent extensions as well as applications that have 3rd party plugins.  The trouble happens when the application, plugins, and framework extensions all need to perform some action when a signal is caught.  This section outlines the recommended way of handling signals with Cement versus manually setting signal handlers that may collide.\n\n**Important Note**\n\nIt is important to note that it is not necessary to use the Cement mechanisms for signal handling, what-so-ever.  That said, the primary concern of the framework is that `app.close()` is called no matter what the situation. Therefore, if you decide to disable signal handling all together you **must** ensure that you at the very least catch `signal.SIGTERM` and `signal.SIGINT` with the ability to call `app.close()`.  You will likely find that it is more complex than you might think.  The reason we put these mechanisms in place is primarily that we found it was the best way to a) handle a signal, and b) have access to our `app` object in order to be able to call `app.close()` when a process is terminated.\n\n\n## Signals Caught by Default\n\nBy default Cement catches the signals `SIGTERM` and `SIGINT`.  When these signals are caught, Cement raises the exception `CaughtSignal(signum, frame)` where `signum` and `frame` are the parameters passed to the signal handler. By raising an exception, we are able to pass runtime back to our applications main process (within a try/except block) and maintain the ability to access our 'application' object without using global objects.\n\nA basic application using default handling might look like:\n\n```python\nimport signal\nfrom cement.core.foundation import CementApp\nfrom cement.core.exc import CaughtSignal\n\nwith CementApp('myapp') as app:\n    try:\n        app.run()\n    except CaughtSignal as e:\n        # do something with e.signum or e.frame (passed from signal)\n        if e.signum == signal.SIGTERM:\n            print(\"Caught SIGTERM...\")\n        elif e.signum == signal.SIGINT:\n            print(\"Caught SIGINT...\")\n```\n\n\nThe above provides a very simple means of handling the most common signals, which in turns allows our application to \"exit clean\" by running `app.close()` and any `pre_close` or `post_close` hooks.  If we don't catch the signals, then the exceptions will be unhandled and the application will not exit clean.\n\n\n## Using The Signal Hook\n\nAn alternative way of adding multiple callbacks to a signal handler is by using the Cement signal hook.  This hook is called anytime a handled signal is encountered.\n\n```python\nimport signal\nfrom cement.core.foundation import CementApp\nfrom cement.core.exc import CaughtSignal\n\ndef my_signal_handler(app, signum, frame):\n    # do something with app?\n    pass\n\n    # or do something with signum or frame\n    if signum == signal.SIGTERM:\n        print(\"Caught SIGTERM...\")\n    elif signum == signal.SIGINT:\n        print(\"Caught SIGINT...\")\n\nwith CementApp('myapp') as app:\n    hook.register('signal', my_signal_handler)\n\n    try:\n        app.run()\n    except CaughtSignal as e:\n        # do soemthing with e.signum, e.frame\n        pass\n```\n\nThe key thing to note here is that the main application itself can easily handle the `CaughtSignal` exception without using hooks, however using the `signal` hook is useful for plugins and extensions to be able to tie into the signal handling outside of the main application.  Both serve the same purpose.\n\nRegardless of how signals are handled, all extensions or plugins should use the `pre_close` hook for cleanup purposes as much as possible as it is always run when `app.close()` is called.\n\n\n## Configuring Which Signals To Catch\n\nYou can define other signals to catch by passing a list of `catch_signals` to `foundation.CementApp()`:\n\n```python\nimport signal\nfrom cement.core.foundation import CementApp\n\nSIGNALS = [signal.SIGTERM, signal.SIGINT, signal.SIGHUP]\n\nCementApp('myapp', catch_signals=SIGNALS)\n# ...\n```\n\nWhat happens is, Cement iterates over the catch_signals list and adds a generic handler function (the same) for each signal.  Because the handler calls the cement `signal` hook, and then raises an exception which both pass the `signum` and `frame` parameters, you are able to handle the logic elsewhere rather than assigning a unique callback function for every signal.\n\n\n## What If I Don't Like Your Signal Handler Callback?\n\nIf you want more control over what happens when a signal is caught, you are more than welcome to override the default signal handler callback.  That said, please be kind and be sure to at least run the cement `signal` hook within your callback.\n\nThe following is an example taken from the builtin callback handler.  Note that there is a bit of hackery in how we are acquiring the `CementApp` from the frame.  This is because the signal is picked up outside of our control so we need to find it.\n\n```python\nimport signal\nfrom cement.core.foundation import CementApp\n\ndef cement_signal_handler(signum, frame):\n    \"\"\"\n    Catch a signal, run the `signal` hook, and then raise an exception\n    allowing the app to handle logic elsewhere.\n\n    :param signum: The signal number\n    :param frame: The signal frame.\n    :raises: cement.core.exc.CaughtSignal\n\n    \"\"\"\n    LOG.debug('Caught signal %s' % signum)\n\n    # hackish, but we do not have direct access to the CementApp object\n    for f_global in frame.f_globals.values():\n        if isinstance(f_global, CementApp):\n            app = f_global\n            for res in app.hook.run('signal', app, signum, frame):\n                pass\n    raise exc.CaughtSignal(signum, frame)\n\n\nwith CementApp('myapp') as app:\n    try:\n        app.run()\n    except CaughtSignal as e:\n        # do something with e.signum, or e.frame\n        pass\n```\n\n\n## This Is Stupid, and UnPythonic - How Do I Disable It?\n\nTo each their own.  If you simply do not want any kind of signal handling performed, just set `catch_signals=None`.\n\n```python\nfrom cement.core.foundation import foundation\n\nCementApp('myapp', catch_signals=None)\n```\n","date":"2017-08-09T05:34:50.000Z","updated":"2017-08-09T05:34:50.000Z","path":"2.10/dev/signal_handling.html","_id":"cj64kbvnh0002wtpwwysnkcxn","comments":1,"layout":"page","content":"<p>Python provides the <a href=\"http://docs.python.org/library/signal.html\" target=\"_blank\" rel=\"external\">Signal</a> library allowing developers to catch Unix signals and set handlers for asynchronous events.  For example, the <code>SIGTERM</code> (Terminate) signal is received when issuing a <code>kill</code> command for a given Unix process.  Via the signal library, we can set a handler (function) callback that will be executed when that signal is received.  Some signals however can not be handled/caught, such as the <code>SIGKILL</code> signal (i.e. <code>kill -9</code>).  Please refer to the <a href=\"http://docs.python.org/library/signal.html\" target=\"_blank\" rel=\"external\">Signal</a> library documentation for a full understanding of its use and capabilities.</p>\n<p>A caveat when setting a signal handler is that only one handler can be defined for a given signal.  Therefore, all handling must be done from a single callback function.  This is a slight roadblock for applications built on Cement in that many pieces of the framework are broken out into independent extensions as well as applications that have 3rd party plugins.  The trouble happens when the application, plugins, and framework extensions all need to perform some action when a signal is caught.  This section outlines the recommended way of handling signals with Cement versus manually setting signal handlers that may collide.</p>\n<p><strong>Important Note</strong></p>\n<p>It is important to note that it is not necessary to use the Cement mechanisms for signal handling, what-so-ever.  That said, the primary concern of the framework is that <code>app.close()</code> is called no matter what the situation. Therefore, if you decide to disable signal handling all together you <strong>must</strong> ensure that you at the very least catch <code>signal.SIGTERM</code> and <code>signal.SIGINT</code> with the ability to call <code>app.close()</code>.  You will likely find that it is more complex than you might think.  The reason we put these mechanisms in place is primarily that we found it was the best way to a) handle a signal, and b) have access to our <code>app</code> object in order to be able to call <code>app.close()</code> when a process is terminated.</p>\n<h2 id=\"Signals-Caught-by-Default\"><a href=\"#Signals-Caught-by-Default\" class=\"headerlink\" title=\"Signals Caught by Default\"></a>Signals Caught by Default</h2><p>By default Cement catches the signals <code>SIGTERM</code> and <code>SIGINT</code>.  When these signals are caught, Cement raises the exception <code>CaughtSignal(signum, frame)</code> where <code>signum</code> and <code>frame</code> are the parameters passed to the signal handler. By raising an exception, we are able to pass runtime back to our applications main process (within a try/except block) and maintain the ability to access our ‘application’ object without using global objects.</p>\n<p>A basic application using default handling might look like:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> signal</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.exc <span class=\"keyword\">import</span> CaughtSignal</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        app.run()</div><div class=\"line\">    <span class=\"keyword\">except</span> CaughtSignal <span class=\"keyword\">as</span> e:</div><div class=\"line\">        <span class=\"comment\"># do something with e.signum or e.frame (passed from signal)</span></div><div class=\"line\">        <span class=\"keyword\">if</span> e.signum == signal.SIGTERM:</div><div class=\"line\">            print(<span class=\"string\">\"Caught SIGTERM...\"</span>)</div><div class=\"line\">        <span class=\"keyword\">elif</span> e.signum == signal.SIGINT:</div><div class=\"line\">            print(<span class=\"string\">\"Caught SIGINT...\"</span>)</div></pre></td></tr></table></figure>\n<p>The above provides a very simple means of handling the most common signals, which in turns allows our application to “exit clean” by running <code>app.close()</code> and any <code>pre_close</code> or <code>post_close</code> hooks.  If we don’t catch the signals, then the exceptions will be unhandled and the application will not exit clean.</p>\n<h2 id=\"Using-The-Signal-Hook\"><a href=\"#Using-The-Signal-Hook\" class=\"headerlink\" title=\"Using The Signal Hook\"></a>Using The Signal Hook</h2><p>An alternative way of adding multiple callbacks to a signal handler is by using the Cement signal hook.  This hook is called anytime a handled signal is encountered.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> signal</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.exc <span class=\"keyword\">import</span> CaughtSignal</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_signal_handler</span><span class=\"params\">(app, signum, frame)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># do something with app?</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># or do something with signum or frame</span></div><div class=\"line\">    <span class=\"keyword\">if</span> signum == signal.SIGTERM:</div><div class=\"line\">        print(<span class=\"string\">\"Caught SIGTERM...\"</span>)</div><div class=\"line\">    <span class=\"keyword\">elif</span> signum == signal.SIGINT:</div><div class=\"line\">        print(<span class=\"string\">\"Caught SIGINT...\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    hook.register(<span class=\"string\">'signal'</span>, my_signal_handler)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        app.run()</div><div class=\"line\">    <span class=\"keyword\">except</span> CaughtSignal <span class=\"keyword\">as</span> e:</div><div class=\"line\">        <span class=\"comment\"># do soemthing with e.signum, e.frame</span></div><div class=\"line\">        <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure>\n<p>The key thing to note here is that the main application itself can easily handle the <code>CaughtSignal</code> exception without using hooks, however using the <code>signal</code> hook is useful for plugins and extensions to be able to tie into the signal handling outside of the main application.  Both serve the same purpose.</p>\n<p>Regardless of how signals are handled, all extensions or plugins should use the <code>pre_close</code> hook for cleanup purposes as much as possible as it is always run when <code>app.close()</code> is called.</p>\n<h2 id=\"Configuring-Which-Signals-To-Catch\"><a href=\"#Configuring-Which-Signals-To-Catch\" class=\"headerlink\" title=\"Configuring Which Signals To Catch\"></a>Configuring Which Signals To Catch</h2><p>You can define other signals to catch by passing a list of <code>catch_signals</code> to <code>foundation.CementApp()</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> signal</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\">SIGNALS = [signal.SIGTERM, signal.SIGINT, signal.SIGHUP]</div><div class=\"line\"></div><div class=\"line\">CementApp(<span class=\"string\">'myapp'</span>, catch_signals=SIGNALS)</div><div class=\"line\"><span class=\"comment\"># ...</span></div></pre></td></tr></table></figure>\n<p>What happens is, Cement iterates over the catch_signals list and adds a generic handler function (the same) for each signal.  Because the handler calls the cement <code>signal</code> hook, and then raises an exception which both pass the <code>signum</code> and <code>frame</code> parameters, you are able to handle the logic elsewhere rather than assigning a unique callback function for every signal.</p>\n<h2 id=\"What-If-I-Don’t-Like-Your-Signal-Handler-Callback\"><a href=\"#What-If-I-Don’t-Like-Your-Signal-Handler-Callback\" class=\"headerlink\" title=\"What If I Don’t Like Your Signal Handler Callback?\"></a>What If I Don’t Like Your Signal Handler Callback?</h2><p>If you want more control over what happens when a signal is caught, you are more than welcome to override the default signal handler callback.  That said, please be kind and be sure to at least run the cement <code>signal</code> hook within your callback.</p>\n<p>The following is an example taken from the builtin callback handler.  Note that there is a bit of hackery in how we are acquiring the <code>CementApp</code> from the frame.  This is because the signal is picked up outside of our control so we need to find it.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> signal</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cement_signal_handler</span><span class=\"params\">(signum, frame)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    Catch a signal, run the `signal` hook, and then raise an exception</div><div class=\"line\">    allowing the app to handle logic elsewhere.</div><div class=\"line\"></div><div class=\"line\">    :param signum: The signal number</div><div class=\"line\">    :param frame: The signal frame.</div><div class=\"line\">    :raises: cement.core.exc.CaughtSignal</div><div class=\"line\"></div><div class=\"line\">    \"\"\"</div><div class=\"line\">    LOG.debug(<span class=\"string\">'Caught signal %s'</span> % signum)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># hackish, but we do not have direct access to the CementApp object</span></div><div class=\"line\">    <span class=\"keyword\">for</span> f_global <span class=\"keyword\">in</span> frame.f_globals.values():</div><div class=\"line\">        <span class=\"keyword\">if</span> isinstance(f_global, CementApp):</div><div class=\"line\">            app = f_global</div><div class=\"line\">            <span class=\"keyword\">for</span> res <span class=\"keyword\">in</span> app.hook.run(<span class=\"string\">'signal'</span>, app, signum, frame):</div><div class=\"line\">                <span class=\"keyword\">pass</span></div><div class=\"line\">    <span class=\"keyword\">raise</span> exc.CaughtSignal(signum, frame)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        app.run()</div><div class=\"line\">    <span class=\"keyword\">except</span> CaughtSignal <span class=\"keyword\">as</span> e:</div><div class=\"line\">        <span class=\"comment\"># do something with e.signum, or e.frame</span></div><div class=\"line\">        <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure>\n<h2 id=\"This-Is-Stupid-and-UnPythonic-How-Do-I-Disable-It\"><a href=\"#This-Is-Stupid-and-UnPythonic-How-Do-I-Disable-It\" class=\"headerlink\" title=\"This Is Stupid, and UnPythonic - How Do I Disable It?\"></a>This Is Stupid, and UnPythonic - How Do I Disable It?</h2><p>To each their own.  If you simply do not want any kind of signal handling performed, just set <code>catch_signals=None</code>.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> foundation</div><div class=\"line\"></div><div class=\"line\">CementApp(<span class=\"string\">'myapp'</span>, catch_signals=<span class=\"keyword\">None</span>)</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>Python provides the <a href=\"http://docs.python.org/library/signal.html\">Signal</a> library allowing developers to catch Unix signals and set handlers for asynchronous events.  For example, the <code>SIGTERM</code> (Terminate) signal is received when issuing a <code>kill</code> command for a given Unix process.  Via the signal library, we can set a handler (function) callback that will be executed when that signal is received.  Some signals however can not be handled/caught, such as the <code>SIGKILL</code> signal (i.e. <code>kill -9</code>).  Please refer to the <a href=\"http://docs.python.org/library/signal.html\">Signal</a> library documentation for a full understanding of its use and capabilities.</p>\n<p>A caveat when setting a signal handler is that only one handler can be defined for a given signal.  Therefore, all handling must be done from a single callback function.  This is a slight roadblock for applications built on Cement in that many pieces of the framework are broken out into independent extensions as well as applications that have 3rd party plugins.  The trouble happens when the application, plugins, and framework extensions all need to perform some action when a signal is caught.  This section outlines the recommended way of handling signals with Cement versus manually setting signal handlers that may collide.</p>\n<p><strong>Important Note</strong></p>\n<p>It is important to note that it is not necessary to use the Cement mechanisms for signal handling, what-so-ever.  That said, the primary concern of the framework is that <code>app.close()</code> is called no matter what the situation. Therefore, if you decide to disable signal handling all together you <strong>must</strong> ensure that you at the very least catch <code>signal.SIGTERM</code> and <code>signal.SIGINT</code> with the ability to call <code>app.close()</code>.  You will likely find that it is more complex than you might think.  The reason we put these mechanisms in place is primarily that we found it was the best way to a) handle a signal, and b) have access to our <code>app</code> object in order to be able to call <code>app.close()</code> when a process is terminated.</p>\n<h2 id=\"Signals-Caught-by-Default\"><a href=\"#Signals-Caught-by-Default\" class=\"headerlink\" title=\"Signals Caught by Default\"></a>Signals Caught by Default</h2><p>By default Cement catches the signals <code>SIGTERM</code> and <code>SIGINT</code>.  When these signals are caught, Cement raises the exception <code>CaughtSignal(signum, frame)</code> where <code>signum</code> and <code>frame</code> are the parameters passed to the signal handler. By raising an exception, we are able to pass runtime back to our applications main process (within a try/except block) and maintain the ability to access our ‘application’ object without using global objects.</p>\n<p>A basic application using default handling might look like:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> signal</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.exc <span class=\"keyword\">import</span> CaughtSignal</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        app.run()</div><div class=\"line\">    <span class=\"keyword\">except</span> CaughtSignal <span class=\"keyword\">as</span> e:</div><div class=\"line\">        <span class=\"comment\"># do something with e.signum or e.frame (passed from signal)</span></div><div class=\"line\">        <span class=\"keyword\">if</span> e.signum == signal.SIGTERM:</div><div class=\"line\">            print(<span class=\"string\">\"Caught SIGTERM...\"</span>)</div><div class=\"line\">        <span class=\"keyword\">elif</span> e.signum == signal.SIGINT:</div><div class=\"line\">            print(<span class=\"string\">\"Caught SIGINT...\"</span>)</div></pre></td></tr></table></figure>\n<p>The above provides a very simple means of handling the most common signals, which in turns allows our application to “exit clean” by running <code>app.close()</code> and any <code>pre_close</code> or <code>post_close</code> hooks.  If we don’t catch the signals, then the exceptions will be unhandled and the application will not exit clean.</p>\n<h2 id=\"Using-The-Signal-Hook\"><a href=\"#Using-The-Signal-Hook\" class=\"headerlink\" title=\"Using The Signal Hook\"></a>Using The Signal Hook</h2><p>An alternative way of adding multiple callbacks to a signal handler is by using the Cement signal hook.  This hook is called anytime a handled signal is encountered.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> signal</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.exc <span class=\"keyword\">import</span> CaughtSignal</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_signal_handler</span><span class=\"params\">(app, signum, frame)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># do something with app?</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># or do something with signum or frame</span></div><div class=\"line\">    <span class=\"keyword\">if</span> signum == signal.SIGTERM:</div><div class=\"line\">        print(<span class=\"string\">\"Caught SIGTERM...\"</span>)</div><div class=\"line\">    <span class=\"keyword\">elif</span> signum == signal.SIGINT:</div><div class=\"line\">        print(<span class=\"string\">\"Caught SIGINT...\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    hook.register(<span class=\"string\">'signal'</span>, my_signal_handler)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        app.run()</div><div class=\"line\">    <span class=\"keyword\">except</span> CaughtSignal <span class=\"keyword\">as</span> e:</div><div class=\"line\">        <span class=\"comment\"># do soemthing with e.signum, e.frame</span></div><div class=\"line\">        <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure>\n<p>The key thing to note here is that the main application itself can easily handle the <code>CaughtSignal</code> exception without using hooks, however using the <code>signal</code> hook is useful for plugins and extensions to be able to tie into the signal handling outside of the main application.  Both serve the same purpose.</p>\n<p>Regardless of how signals are handled, all extensions or plugins should use the <code>pre_close</code> hook for cleanup purposes as much as possible as it is always run when <code>app.close()</code> is called.</p>\n<h2 id=\"Configuring-Which-Signals-To-Catch\"><a href=\"#Configuring-Which-Signals-To-Catch\" class=\"headerlink\" title=\"Configuring Which Signals To Catch\"></a>Configuring Which Signals To Catch</h2><p>You can define other signals to catch by passing a list of <code>catch_signals</code> to <code>foundation.CementApp()</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> signal</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\">SIGNALS = [signal.SIGTERM, signal.SIGINT, signal.SIGHUP]</div><div class=\"line\"></div><div class=\"line\">CementApp(<span class=\"string\">'myapp'</span>, catch_signals=SIGNALS)</div><div class=\"line\"><span class=\"comment\"># ...</span></div></pre></td></tr></table></figure>\n<p>What happens is, Cement iterates over the catch_signals list and adds a generic handler function (the same) for each signal.  Because the handler calls the cement <code>signal</code> hook, and then raises an exception which both pass the <code>signum</code> and <code>frame</code> parameters, you are able to handle the logic elsewhere rather than assigning a unique callback function for every signal.</p>\n<h2 id=\"What-If-I-Don’t-Like-Your-Signal-Handler-Callback\"><a href=\"#What-If-I-Don’t-Like-Your-Signal-Handler-Callback\" class=\"headerlink\" title=\"What If I Don’t Like Your Signal Handler Callback?\"></a>What If I Don’t Like Your Signal Handler Callback?</h2><p>If you want more control over what happens when a signal is caught, you are more than welcome to override the default signal handler callback.  That said, please be kind and be sure to at least run the cement <code>signal</code> hook within your callback.</p>\n<p>The following is an example taken from the builtin callback handler.  Note that there is a bit of hackery in how we are acquiring the <code>CementApp</code> from the frame.  This is because the signal is picked up outside of our control so we need to find it.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> signal</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cement_signal_handler</span><span class=\"params\">(signum, frame)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</div><div class=\"line\">    Catch a signal, run the `signal` hook, and then raise an exception</div><div class=\"line\">    allowing the app to handle logic elsewhere.</div><div class=\"line\"></div><div class=\"line\">    :param signum: The signal number</div><div class=\"line\">    :param frame: The signal frame.</div><div class=\"line\">    :raises: cement.core.exc.CaughtSignal</div><div class=\"line\"></div><div class=\"line\">    \"\"\"</span></div><div class=\"line\">    LOG.debug(<span class=\"string\">'Caught signal %s'</span> % signum)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># hackish, but we do not have direct access to the CementApp object</span></div><div class=\"line\">    <span class=\"keyword\">for</span> f_global <span class=\"keyword\">in</span> frame.f_globals.values():</div><div class=\"line\">        <span class=\"keyword\">if</span> isinstance(f_global, CementApp):</div><div class=\"line\">            app = f_global</div><div class=\"line\">            <span class=\"keyword\">for</span> res <span class=\"keyword\">in</span> app.hook.run(<span class=\"string\">'signal'</span>, app, signum, frame):</div><div class=\"line\">                <span class=\"keyword\">pass</span></div><div class=\"line\">    <span class=\"keyword\">raise</span> exc.CaughtSignal(signum, frame)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        app.run()</div><div class=\"line\">    <span class=\"keyword\">except</span> CaughtSignal <span class=\"keyword\">as</span> e:</div><div class=\"line\">        <span class=\"comment\"># do something with e.signum, or e.frame</span></div><div class=\"line\">        <span class=\"keyword\">pass</span></div></pre></td></tr></table></figure>\n<h2 id=\"This-Is-Stupid-and-UnPythonic-How-Do-I-Disable-It\"><a href=\"#This-Is-Stupid-and-UnPythonic-How-Do-I-Disable-It\" class=\"headerlink\" title=\"This Is Stupid, and UnPythonic - How Do I Disable It?\"></a>This Is Stupid, and UnPythonic - How Do I Disable It?</h2><p>To each their own.  If you simply do not want any kind of signal handling performed, just set <code>catch_signals=None</code>.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> foundation</div><div class=\"line\"></div><div class=\"line\">CementApp(<span class=\"string\">'myapp'</span>, catch_signals=<span class=\"keyword\">None</span>)</div></pre></td></tr></table></figure>\n"},{"title":"Application Cleanup","type":"guide","version":"2.10","order":15,"_content":"\nThe concept of 'cleanup' after application run time is nothing new.  What happens during 'cleanup' all depends on the application.  This might mean closing and deleting temporary files, removing session data, or deleting a PID (Process ID) file.\n\nTo allow for application cleanup not only within your program, but also external plugins and extensions, there is the `app.close()` function that must be called after ``app.run()`` regardless of any exceptions or runtime errors.\n\nFor example:\n\n```python\nfrom cement.core.foundation import CementApp\n\napp = CementApp('helloworld')\napp.setup()\napp.run()\napp.close()\n```\n\n\nCalling `app.close()` ensures that the `pre_close` and `post_close` framework hooks are run, allowing extensions/plugins/etc to cleanup after the program runs.\n\nNote that when using the Python `with` operator, the `setup()` and `close()` methods are automatically called.  For example, the following is exactly the same as the above example:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('helloworld') as app:\n    app.run()\n```\n\n## Exit Status and Error Codes\n\nYou can optionally set the status code that your application exists with via the meta options [CementApp.Meta.exit_on_close]/{{ version }}/api/core/foundation.html#cement.core.foundation.CementApp.Meta.exit_on_close).\n\n```python\napp = CementApp('helloworld', exit_on_close=True)\napp.setup()\napp.run()\napp.close(27)\n```\n\nOr Alternatively:\n\n```python\nclass MyApp(CementApp):\n    class Meta:\n        label = 'helloworld'\n        exit_on_close = True\n\nwith MyApp() as app:\n    app.run()\n    app.exit_code = 123\n```\n\nNote the use of the `exit_on_close` meta option.  Cement **will not** call  `sys.exit()` unless `CementApp.Meta.exit_on_close == True`.  You will find that calling `sys.exit()` in testing is very problematic, therefore you will likely want to enable `exit_on_close` in production, but not for testing as in this example:\n\n```python\nclass MyApp(CementApp):\n    class Meta:\n        label = 'helloworld'\n        exit_on_close = True\n\nclass MyAppForTesting(MyApp):\n    class Meta:\n        exit_on_close = False\n\n# ...\n```\n\nAlso note that the default exit code is `0`, however any uncaught exceptions will cause the application to exit with a code of `1` (error).\n\n\n## Running Cleanup Code\n\nAny extension, or plugin, or even the application itself that has 'cleanup' code should do so within the `pre_close` or `post_close` hooks to ensure that it gets run.  For example:\n\n```python\nfrom cement.core import hook\n\ndef my_cleanup(app):\n    # do something when app.close() is called\n    pass\n\nhook.register('pre_close', my_cleanup)\n```\n","source":"2.10/dev/cleanup.md","raw":"---\ntitle: Application Cleanup\ntype: guide\nversion: \"2.10\"\norder: 15\n---\n\nThe concept of 'cleanup' after application run time is nothing new.  What happens during 'cleanup' all depends on the application.  This might mean closing and deleting temporary files, removing session data, or deleting a PID (Process ID) file.\n\nTo allow for application cleanup not only within your program, but also external plugins and extensions, there is the `app.close()` function that must be called after ``app.run()`` regardless of any exceptions or runtime errors.\n\nFor example:\n\n```python\nfrom cement.core.foundation import CementApp\n\napp = CementApp('helloworld')\napp.setup()\napp.run()\napp.close()\n```\n\n\nCalling `app.close()` ensures that the `pre_close` and `post_close` framework hooks are run, allowing extensions/plugins/etc to cleanup after the program runs.\n\nNote that when using the Python `with` operator, the `setup()` and `close()` methods are automatically called.  For example, the following is exactly the same as the above example:\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('helloworld') as app:\n    app.run()\n```\n\n## Exit Status and Error Codes\n\nYou can optionally set the status code that your application exists with via the meta options [CementApp.Meta.exit_on_close]/{{ version }}/api/core/foundation.html#cement.core.foundation.CementApp.Meta.exit_on_close).\n\n```python\napp = CementApp('helloworld', exit_on_close=True)\napp.setup()\napp.run()\napp.close(27)\n```\n\nOr Alternatively:\n\n```python\nclass MyApp(CementApp):\n    class Meta:\n        label = 'helloworld'\n        exit_on_close = True\n\nwith MyApp() as app:\n    app.run()\n    app.exit_code = 123\n```\n\nNote the use of the `exit_on_close` meta option.  Cement **will not** call  `sys.exit()` unless `CementApp.Meta.exit_on_close == True`.  You will find that calling `sys.exit()` in testing is very problematic, therefore you will likely want to enable `exit_on_close` in production, but not for testing as in this example:\n\n```python\nclass MyApp(CementApp):\n    class Meta:\n        label = 'helloworld'\n        exit_on_close = True\n\nclass MyAppForTesting(MyApp):\n    class Meta:\n        exit_on_close = False\n\n# ...\n```\n\nAlso note that the default exit code is `0`, however any uncaught exceptions will cause the application to exit with a code of `1` (error).\n\n\n## Running Cleanup Code\n\nAny extension, or plugin, or even the application itself that has 'cleanup' code should do so within the `pre_close` or `post_close` hooks to ensure that it gets run.  For example:\n\n```python\nfrom cement.core import hook\n\ndef my_cleanup(app):\n    # do something when app.close() is called\n    pass\n\nhook.register('pre_close', my_cleanup)\n```\n","date":"2017-08-09T05:42:06.000Z","updated":"2017-08-09T05:42:06.000Z","path":"2.10/dev/cleanup.html","_id":"cj64l12ff0003wtpw85r64e9l","comments":1,"layout":"page","content":"<p>The concept of ‘cleanup’ after application run time is nothing new.  What happens during ‘cleanup’ all depends on the application.  This might mean closing and deleting temporary files, removing session data, or deleting a PID (Process ID) file.</p>\n<p>To allow for application cleanup not only within your program, but also external plugins and extensions, there is the <code>app.close()</code> function that must be called after <code>app.run()</code> regardless of any exceptions or runtime errors.</p>\n<p>For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\">app = CementApp(<span class=\"string\">'helloworld'</span>)</div><div class=\"line\">app.setup()</div><div class=\"line\">app.run()</div><div class=\"line\">app.close()</div></pre></td></tr></table></figure>\n<p>Calling <code>app.close()</code> ensures that the <code>pre_close</code> and <code>post_close</code> framework hooks are run, allowing extensions/plugins/etc to cleanup after the program runs.</p>\n<p>Note that when using the Python <code>with</code> operator, the <code>setup()</code> and <code>close()</code> methods are automatically called.  For example, the following is exactly the same as the above example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'helloworld'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<h2 id=\"Exit-Status-and-Error-Codes\"><a href=\"#Exit-Status-and-Error-Codes\" class=\"headerlink\" title=\"Exit Status and Error Codes\"></a>Exit Status and Error Codes</h2><p>You can optionally set the status code that your application exists with via the meta options [CementApp.Meta.exit_on_close]/2.10/api/core/foundation.html#cement.core.foundation.CementApp.Meta.exit_on_close).</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">app = CementApp(<span class=\"string\">'helloworld'</span>, exit_on_close=<span class=\"keyword\">True</span>)</div><div class=\"line\">app.setup()</div><div class=\"line\">app.run()</div><div class=\"line\">app.close(<span class=\"number\">27</span>)</div></pre></td></tr></table></figure>\n<p>Or Alternatively:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'helloworld'</span></div><div class=\"line\">        exit_on_close = <span class=\"keyword\">True</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\">    app.exit_code = <span class=\"number\">123</span></div></pre></td></tr></table></figure>\n<p>Note the use of the <code>exit_on_close</code> meta option.  Cement <strong>will not</strong> call  <code>sys.exit()</code> unless <code>CementApp.Meta.exit_on_close == True</code>.  You will find that calling <code>sys.exit()</code> in testing is very problematic, therefore you will likely want to enable <code>exit_on_close</code> in production, but not for testing as in this example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'helloworld'</span></div><div class=\"line\">        exit_on_close = <span class=\"keyword\">True</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAppForTesting</span><span class=\"params\">(MyApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        exit_on_close = <span class=\"keyword\">False</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># ...</span></div></pre></td></tr></table></figure>\n<p>Also note that the default exit code is <code>0</code>, however any uncaught exceptions will cause the application to exit with a code of <code>1</code> (error).</p>\n<h2 id=\"Running-Cleanup-Code\"><a href=\"#Running-Cleanup-Code\" class=\"headerlink\" title=\"Running Cleanup Code\"></a>Running Cleanup Code</h2><p>Any extension, or plugin, or even the application itself that has ‘cleanup’ code should do so within the <code>pre_close</code> or <code>post_close</code> hooks to ensure that it gets run.  For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> hook</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_cleanup</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># do something when app.close() is called</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\">hook.register(<span class=\"string\">'pre_close'</span>, my_cleanup)</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>The concept of ‘cleanup’ after application run time is nothing new.  What happens during ‘cleanup’ all depends on the application.  This might mean closing and deleting temporary files, removing session data, or deleting a PID (Process ID) file.</p>\n<p>To allow for application cleanup not only within your program, but also external plugins and extensions, there is the <code>app.close()</code> function that must be called after <code>app.run()</code> regardless of any exceptions or runtime errors.</p>\n<p>For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\">app = CementApp(<span class=\"string\">'helloworld'</span>)</div><div class=\"line\">app.setup()</div><div class=\"line\">app.run()</div><div class=\"line\">app.close()</div></pre></td></tr></table></figure>\n<p>Calling <code>app.close()</code> ensures that the <code>pre_close</code> and <code>post_close</code> framework hooks are run, allowing extensions/plugins/etc to cleanup after the program runs.</p>\n<p>Note that when using the Python <code>with</code> operator, the <code>setup()</code> and <code>close()</code> methods are automatically called.  For example, the following is exactly the same as the above example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'helloworld'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<h2 id=\"Exit-Status-and-Error-Codes\"><a href=\"#Exit-Status-and-Error-Codes\" class=\"headerlink\" title=\"Exit Status and Error Codes\"></a>Exit Status and Error Codes</h2><p>You can optionally set the status code that your application exists with via the meta options [CementApp.Meta.exit_on_close]/2.10/api/core/foundation.html#cement.core.foundation.CementApp.Meta.exit_on_close).</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">app = CementApp(<span class=\"string\">'helloworld'</span>, exit_on_close=<span class=\"keyword\">True</span>)</div><div class=\"line\">app.setup()</div><div class=\"line\">app.run()</div><div class=\"line\">app.close(<span class=\"number\">27</span>)</div></pre></td></tr></table></figure>\n<p>Or Alternatively:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'helloworld'</span></div><div class=\"line\">        exit_on_close = <span class=\"keyword\">True</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\">    app.exit_code = <span class=\"number\">123</span></div></pre></td></tr></table></figure>\n<p>Note the use of the <code>exit_on_close</code> meta option.  Cement <strong>will not</strong> call  <code>sys.exit()</code> unless <code>CementApp.Meta.exit_on_close == True</code>.  You will find that calling <code>sys.exit()</code> in testing is very problematic, therefore you will likely want to enable <code>exit_on_close</code> in production, but not for testing as in this example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'helloworld'</span></div><div class=\"line\">        exit_on_close = <span class=\"keyword\">True</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAppForTesting</span><span class=\"params\">(MyApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        exit_on_close = <span class=\"keyword\">False</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># ...</span></div></pre></td></tr></table></figure>\n<p>Also note that the default exit code is <code>0</code>, however any uncaught exceptions will cause the application to exit with a code of <code>1</code> (error).</p>\n<h2 id=\"Running-Cleanup-Code\"><a href=\"#Running-Cleanup-Code\" class=\"headerlink\" title=\"Running Cleanup Code\"></a>Running Cleanup Code</h2><p>Any extension, or plugin, or even the application itself that has ‘cleanup’ code should do so within the <code>pre_close</code> or <code>post_close</code> hooks to ensure that it gets run.  For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> hook</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_cleanup</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"comment\"># do something when app.close() is called</span></div><div class=\"line\">    <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\">hook.register(<span class=\"string\">'pre_close'</span>, my_cleanup)</div></pre></td></tr></table></figure>\n"},{"title":"Caching","type":"guide","version":"2.10","order":16,"_content":"\nCement defines a cache interface called [ICache](/{{ version }}/api/core/cache.html#cement.core.cache.ICache), but does not implement caching by default.  The documentation below references usage based on the interface and not the full capabilities of any given implementation.\n\nThe following cache handlers are included and maintained with Cement:\n\n- [MemcachedCacheHandler](/{{ version }}/api/ext/ext_memcached.html#cement.ext.ext_memcached.MemcachedCacheHandler)\n- [RedisCacheHandler](/{{ version }}/api/ext/ext_redis.html#cement.ext.ext_redis.RedisCacheHandler)\n\n\nPlease reference the [ICache](/{{ version }}/api/core/cache.html#cement.core.cache.ICache) interface documentation for writing your own cache handler.\n\n## General Usage\n\nFor this example we use the Memcached extension, which requires the `pylibmc` library to be installed, as well as a Memcached server running on localhost.\n\nExample:\n\n**/path/to/myapp.conf**\n\n```\n[myapp]\nextensions = memcached\n\n[cache.memcached]\n# comma separated list of hosts to use\nhosts = 127.0.0.1\n\n# time in milliseconds\nexpire_time = 300\n```\n\n**myapp.py**\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    # run the application\n    app.run()\n\n    # set a cached value\n    app.cache.set('my_key', 'my value')\n\n    # get a cached value\n    app.cache.get('my_key')\n\n    # delete a cached value\n    app.cache.delete('my_key')\n\n    # delete the entire cache\n    app.cache.purge()\n```\n","source":"2.10/dev/caching.md","raw":"---\ntitle: Caching\ntype: guide\nversion: \"2.10\"\norder: 16\n---\n\nCement defines a cache interface called [ICache](/{{ version }}/api/core/cache.html#cement.core.cache.ICache), but does not implement caching by default.  The documentation below references usage based on the interface and not the full capabilities of any given implementation.\n\nThe following cache handlers are included and maintained with Cement:\n\n- [MemcachedCacheHandler](/{{ version }}/api/ext/ext_memcached.html#cement.ext.ext_memcached.MemcachedCacheHandler)\n- [RedisCacheHandler](/{{ version }}/api/ext/ext_redis.html#cement.ext.ext_redis.RedisCacheHandler)\n\n\nPlease reference the [ICache](/{{ version }}/api/core/cache.html#cement.core.cache.ICache) interface documentation for writing your own cache handler.\n\n## General Usage\n\nFor this example we use the Memcached extension, which requires the `pylibmc` library to be installed, as well as a Memcached server running on localhost.\n\nExample:\n\n**/path/to/myapp.conf**\n\n```\n[myapp]\nextensions = memcached\n\n[cache.memcached]\n# comma separated list of hosts to use\nhosts = 127.0.0.1\n\n# time in milliseconds\nexpire_time = 300\n```\n\n**myapp.py**\n\n```python\nfrom cement.core.foundation import CementApp\n\nwith CementApp('myapp') as app:\n    # run the application\n    app.run()\n\n    # set a cached value\n    app.cache.set('my_key', 'my value')\n\n    # get a cached value\n    app.cache.get('my_key')\n\n    # delete a cached value\n    app.cache.delete('my_key')\n\n    # delete the entire cache\n    app.cache.purge()\n```\n","date":"2017-08-09T05:48:00.000Z","updated":"2017-08-09T05:48:00.000Z","path":"2.10/dev/caching.html","_id":"cj64l9ptz0004wtpw6xfvvsmt","comments":1,"layout":"page","content":"<p>Cement defines a cache interface called <a href=\"/2.10/api/core/cache.html#cement.core.cache.ICache\">ICache</a>, but does not implement caching by default.  The documentation below references usage based on the interface and not the full capabilities of any given implementation.</p>\n<p>The following cache handlers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/ext/ext_memcached.html#cement.ext.ext_memcached.MemcachedCacheHandler\">MemcachedCacheHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_redis.html#cement.ext.ext_redis.RedisCacheHandler\">RedisCacheHandler</a></li>\n</ul>\n<p>Please reference the <a href=\"/2.10/api/core/cache.html#cement.core.cache.ICache\">ICache</a> interface documentation for writing your own cache handler.</p>\n<h2 id=\"General-Usage\"><a href=\"#General-Usage\" class=\"headerlink\" title=\"General Usage\"></a>General Usage</h2><p>For this example we use the Memcached extension, which requires the <code>pylibmc</code> library to be installed, as well as a Memcached server running on localhost.</p>\n<p>Example:</p>\n<p><strong>/path/to/myapp.conf</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">extensions = memcached</div><div class=\"line\"></div><div class=\"line\">[cache.memcached]</div><div class=\"line\"># comma separated list of hosts to use</div><div class=\"line\">hosts = 127.0.0.1</div><div class=\"line\"></div><div class=\"line\"># time in milliseconds</div><div class=\"line\">expire_time = 300</div></pre></td></tr></table></figure>\n<p><strong>myapp.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># run the application</span></div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># set a cached value</span></div><div class=\"line\">    app.cache.set(<span class=\"string\">'my_key'</span>, <span class=\"string\">'my value'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># get a cached value</span></div><div class=\"line\">    app.cache.get(<span class=\"string\">'my_key'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># delete a cached value</span></div><div class=\"line\">    app.cache.delete(<span class=\"string\">'my_key'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># delete the entire cache</span></div><div class=\"line\">    app.cache.purge()</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>Cement defines a cache interface called <a href=\"/2.10/api/core/cache.html#cement.core.cache.ICache\">ICache</a>, but does not implement caching by default.  The documentation below references usage based on the interface and not the full capabilities of any given implementation.</p>\n<p>The following cache handlers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/ext/ext_memcached.html#cement.ext.ext_memcached.MemcachedCacheHandler\">MemcachedCacheHandler</a></li>\n<li><a href=\"/2.10/api/ext/ext_redis.html#cement.ext.ext_redis.RedisCacheHandler\">RedisCacheHandler</a></li>\n</ul>\n<p>Please reference the <a href=\"/2.10/api/core/cache.html#cement.core.cache.ICache\">ICache</a> interface documentation for writing your own cache handler.</p>\n<h2 id=\"General-Usage\"><a href=\"#General-Usage\" class=\"headerlink\" title=\"General Usage\"></a>General Usage</h2><p>For this example we use the Memcached extension, which requires the <code>pylibmc</code> library to be installed, as well as a Memcached server running on localhost.</p>\n<p>Example:</p>\n<p><strong>/path/to/myapp.conf</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">extensions = memcached</div><div class=\"line\"></div><div class=\"line\">[cache.memcached]</div><div class=\"line\"># comma separated list of hosts to use</div><div class=\"line\">hosts = 127.0.0.1</div><div class=\"line\"></div><div class=\"line\"># time in milliseconds</div><div class=\"line\">expire_time = 300</div></pre></td></tr></table></figure>\n<p><strong>myapp.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\"># run the application</span></div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># set a cached value</span></div><div class=\"line\">    app.cache.set(<span class=\"string\">'my_key'</span>, <span class=\"string\">'my value'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># get a cached value</span></div><div class=\"line\">    app.cache.get(<span class=\"string\">'my_key'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># delete a cached value</span></div><div class=\"line\">    app.cache.delete(<span class=\"string\">'my_key'</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># delete the entire cache</span></div><div class=\"line\">    app.cache.purge()</div></pre></td></tr></table></figure>\n"},{"title":"Sending Mail Messages","type":"guide","version":"2.10","order":17,"_content":"\nCement defines a mail interface called [IMail](/{{ version }}/api/core/mail.html#cement.core.mail.IMail), as well as the default [DummyMailHandler](/{{ version }}/api/ext/ext_dummy.html#cement.ext.ext_dummy.DummyMailHandler) that implements the interface.\n\nPlease note that there are other handlers that implement the `IMail` interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.\n\nThe following mail handlers are included and maintained with Cement:\n\n- [DummyMailHandler](/{{ version }}/api/ext/ext_dummy.html#cement.ext.ext_dummy.DummyMailHandler) *(default)*\n- [SMTPMailHandler](/{{ version }}/api/ext/ext_smtp#cement.ext.ext_smtp.SMTPMailHandler)\n\n\nPlease reference the [IMail](/{{ version }}/api/core/mail.html#cement.core.mail.IMail) interface documentation for writing your own mail handler.\n\n\n## Example Usage\n\n```python\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n\nwith MyApp() as app:\n    app.run()\n\n    # send an email message\n    app.mail.send('This is my message',\n        subject='This is my subject',\n        to=['you@example.com'],\n        from_addr='me@example.com',\n        cc=['him@example.com', 'her@example.com'],\n        bcc=['boss@example.com']\n        )\n```\n\nNote that the default mail handler simply prints messages to the screen, and does not actually send anything.  You can override this pretty easily without changing any code by using the built-in [SMTPMailHandler](/{{ version }}/api/ext/ext_smtp#cement.ext.ext_smtp.SMTPMailHandler).  Simply modify the application configuration to something like:\n\n**myapp.conf**\n\n```\n[myapp]\nmail_handler = smtp\n\n[mail.smtp]\nssl = 1\ntls = 1\nauth = 1\nusername = john.doe\npassword = oober_secure_password\n```\n","source":"2.10/dev/mail.md","raw":"---\ntitle: Sending Mail Messages\ntype: guide\nversion: \"2.10\"\norder: 17\n---\n\nCement defines a mail interface called [IMail](/{{ version }}/api/core/mail.html#cement.core.mail.IMail), as well as the default [DummyMailHandler](/{{ version }}/api/ext/ext_dummy.html#cement.ext.ext_dummy.DummyMailHandler) that implements the interface.\n\nPlease note that there are other handlers that implement the `IMail` interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.\n\nThe following mail handlers are included and maintained with Cement:\n\n- [DummyMailHandler](/{{ version }}/api/ext/ext_dummy.html#cement.ext.ext_dummy.DummyMailHandler) *(default)*\n- [SMTPMailHandler](/{{ version }}/api/ext/ext_smtp#cement.ext.ext_smtp.SMTPMailHandler)\n\n\nPlease reference the [IMail](/{{ version }}/api/core/mail.html#cement.core.mail.IMail) interface documentation for writing your own mail handler.\n\n\n## Example Usage\n\n```python\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n\nwith MyApp() as app:\n    app.run()\n\n    # send an email message\n    app.mail.send('This is my message',\n        subject='This is my subject',\n        to=['you@example.com'],\n        from_addr='me@example.com',\n        cc=['him@example.com', 'her@example.com'],\n        bcc=['boss@example.com']\n        )\n```\n\nNote that the default mail handler simply prints messages to the screen, and does not actually send anything.  You can override this pretty easily without changing any code by using the built-in [SMTPMailHandler](/{{ version }}/api/ext/ext_smtp#cement.ext.ext_smtp.SMTPMailHandler).  Simply modify the application configuration to something like:\n\n**myapp.conf**\n\n```\n[myapp]\nmail_handler = smtp\n\n[mail.smtp]\nssl = 1\ntls = 1\nauth = 1\nusername = john.doe\npassword = oober_secure_password\n```\n","date":"2017-08-09T05:56:38.000Z","updated":"2017-08-09T05:56:38.000Z","path":"2.10/dev/mail.html","_id":"cj64lr88l0006wtpwda1b5fxm","comments":1,"layout":"page","content":"<p>Cement defines a mail interface called <a href=\"/2.10/api/core/mail.html#cement.core.mail.IMail\">IMail</a>, as well as the default <a href=\"/2.10/api/ext/ext_dummy.html#cement.ext.ext_dummy.DummyMailHandler\">DummyMailHandler</a> that implements the interface.</p>\n<p>Please note that there are other handlers that implement the <code>IMail</code> interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.</p>\n<p>The following mail handlers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/ext/ext_dummy.html#cement.ext.ext_dummy.DummyMailHandler\">DummyMailHandler</a> <em>(default)</em></li>\n<li><a href=\"/2.10/api/ext/ext_smtp#cement.ext.ext_smtp.SMTPMailHandler\">SMTPMailHandler</a></li>\n</ul>\n<p>Please reference the <a href=\"/2.10/api/core/mail.html#cement.core.mail.IMail\">IMail</a> interface documentation for writing your own mail handler.</p>\n<h2 id=\"Example-Usage\"><a href=\"#Example-Usage\" class=\"headerlink\" title=\"Example Usage\"></a>Example Usage</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># send an email message</span></div><div class=\"line\">    app.mail.send(<span class=\"string\">'This is my message'</span>,</div><div class=\"line\">        subject=<span class=\"string\">'This is my subject'</span>,</div><div class=\"line\">        to=[<span class=\"string\">'you@example.com'</span>],</div><div class=\"line\">        from_addr=<span class=\"string\">'me@example.com'</span>,</div><div class=\"line\">        cc=[<span class=\"string\">'him@example.com'</span>, <span class=\"string\">'her@example.com'</span>],</div><div class=\"line\">        bcc=[<span class=\"string\">'boss@example.com'</span>]</div><div class=\"line\">        )</div></pre></td></tr></table></figure>\n<p>Note that the default mail handler simply prints messages to the screen, and does not actually send anything.  You can override this pretty easily without changing any code by using the built-in <a href=\"/2.10/api/ext/ext_smtp#cement.ext.ext_smtp.SMTPMailHandler\">SMTPMailHandler</a>.  Simply modify the application configuration to something like:</p>\n<p><strong>myapp.conf</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">mail_handler = smtp</div><div class=\"line\"></div><div class=\"line\">[mail.smtp]</div><div class=\"line\">ssl = 1</div><div class=\"line\">tls = 1</div><div class=\"line\">auth = 1</div><div class=\"line\">username = john.doe</div><div class=\"line\">password = oober_secure_password</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>Cement defines a mail interface called <a href=\"/2.10/api/core/mail.html#cement.core.mail.IMail\">IMail</a>, as well as the default <a href=\"/2.10/api/ext/ext_dummy.html#cement.ext.ext_dummy.DummyMailHandler\">DummyMailHandler</a> that implements the interface.</p>\n<p>Please note that there are other handlers that implement the <code>IMail</code> interface.  The documentation below only references usage based on the interface and not the full capabilities of the implementation.</p>\n<p>The following mail handlers are included and maintained with Cement:</p>\n<ul>\n<li><a href=\"/2.10/api/ext/ext_dummy.html#cement.ext.ext_dummy.DummyMailHandler\">DummyMailHandler</a> <em>(default)</em></li>\n<li><a href=\"/2.10/api/ext/ext_smtp#cement.ext.ext_smtp.SMTPMailHandler\">SMTPMailHandler</a></li>\n</ul>\n<p>Please reference the <a href=\"/2.10/api/core/mail.html#cement.core.mail.IMail\">IMail</a> interface documentation for writing your own mail handler.</p>\n<h2 id=\"Example-Usage\"><a href=\"#Example-Usage\" class=\"headerlink\" title=\"Example Usage\"></a>Example Usage</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># send an email message</span></div><div class=\"line\">    app.mail.send(<span class=\"string\">'This is my message'</span>,</div><div class=\"line\">        subject=<span class=\"string\">'This is my subject'</span>,</div><div class=\"line\">        to=[<span class=\"string\">'you@example.com'</span>],</div><div class=\"line\">        from_addr=<span class=\"string\">'me@example.com'</span>,</div><div class=\"line\">        cc=[<span class=\"string\">'him@example.com'</span>, <span class=\"string\">'her@example.com'</span>],</div><div class=\"line\">        bcc=[<span class=\"string\">'boss@example.com'</span>]</div><div class=\"line\">        )</div></pre></td></tr></table></figure>\n<p>Note that the default mail handler simply prints messages to the screen, and does not actually send anything.  You can override this pretty easily without changing any code by using the built-in <a href=\"/2.10/api/ext/ext_smtp#cement.ext.ext_smtp.SMTPMailHandler\">SMTPMailHandler</a>.  Simply modify the application configuration to something like:</p>\n<p><strong>myapp.conf</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">mail_handler = smtp</div><div class=\"line\"></div><div class=\"line\">[mail.smtp]</div><div class=\"line\">ssl = 1</div><div class=\"line\">tls = 1</div><div class=\"line\">auth = 1</div><div class=\"line\">username = john.doe</div><div class=\"line\">password = oober_secure_password</div></pre></td></tr></table></figure>\n"},{"title":"Unit Testing","type":"guide","version":"2.10","order":18,"_content":"\nTesting is an incredibly important part of the application development process.  The Cement framework provides some simple helpers and shortcuts for executing basic tests of your application. Please note that [cement.utils.test](/{{ version }}/api/utils/test.html) *does* require the `nose` package.  That said, using `cement.utils.test` is not required to test a Cement based application.  It is merely here for convenience, and is used by Cement when performing its own Nose tests.\n\nFor more information on testing, please see the following:\n\n- [UnitTest](http://docs.python.org/library/unittest.html)\n- [Nose](https://nose.readthedocs.io/en/latest/)\n- [Coverage](http://nedbatchelder.com/code/coverage/)\n\nAPI Reference:\n\n- [cement.utils.test](/{{ version }}/api/utils/test.html)\n\n\n## An Example Test Case\n\nThe following outlines a basic test case using the cement.utils.test module.\n\n```python\nfrom cement.utils import test\nfrom myapp.cli.main import MyApp\n\nclass MyTestCase(test.CementTestCase):\n    app_class = MyApp\n\n    def setUp(self):\n        super(MyTestCase, self).setUp()\n\n        # Create a default application for the test functions to use.\n        # Note that some tests may require you to perform this in the\n        # test function in order to alter functionality.  That's perfectly\n        # fine, this is only here for convenience.\n        self.app = MyApp(argv=[], config_files=[])\n\n    def test_myapp(self):\n        with self.app as app:\n\n            # Perform basic assertion checks.  You can do this anywhere\n            # in the test function, depending on what the assertion is\n            # checking.\n            self.ok(app.config.has_key('myapp', 'debug'))\n            self.eq(app.config.get('myapp', 'debug'), False)\n\n            # Run the applicaion, if necessary\n            app.run()\n\n            # Test the last rendered output (if app.render was used)\n            data, output = app.get_last_rendered()\n            self.eq(data, {'foo':'bar'})\n            self.eq(output, 'some rendered output text')\n\n    @test.raises(Exception)\n    def test_exception(self):\n        try:\n            # Perform tests that intentionally cause an exception.  The\n            # test passes only if the exception is raised.\n            raise Exception('test')\n        except Exception as e:\n            # Do further checks to ensure the proper exception was raised\n            self.eq(e.args[0], 'Some Exception Message')\n\n            # Finally, call raise again which re-raises the exception that\n            # we just caught.  This completes our test (to actually\n            # verify that the exception was raised)\n            raise\n```\n\n## Cement Testing Caveats\n\nIn general, testing Cement applications should be no different than testing anything else in Python.  That said, the following are some things to keep in mind.\n\n**Command Line Arguments**\n\nNever rely on `sys.argv` for command line arguments.  The `CementApp()` class accepts the `argv` keyword argument allowing you to pass the arguments that you would like to test for.  Using `sys.argv` will cause issues with the calling script (i.e. `nosetests`, etc) and other issues. Always pass `argv` to `CementApp()` in tests.\n\n**Config Files**\n\nIt is recommended to always set your apps `config_files` setting to an empty list, or to something relative to your current working directory.  Using default config files settings while testing will introduce unexpected results.  For example, if a `~/myapp.conf` user configuration exists it can alter the runtime of your application in a way that might cause tests to fail.\n\n**Making Things Easy**\n\nThe easiest way to accomplish the above is by sub-classing your `CementApp` into a special 'testing' version.  For example:\n\n```python\nfrom cement.utils import test\nfrom myapp.cli.main import MyApp\n\nclass MyTestApp(MyApp):\n    class Meta:\n        argv = []\n        config_files = []\n\nclass MyTestCase(test.CementTestCase):\n    app_class = MyTestApp\n\n    def test_myapp_default(self):\n        with self.app as app:\n            app.run()\n\n    def test_myapp_foo(self):\n        with MyTestApp(argv=['--foo', 'bar']) as app:\n            app.run()\n```\n","source":"2.10/dev/testing.md","raw":"---\ntitle: Unit Testing\ntype: guide\nversion: \"2.10\"\norder: 18\n---\n\nTesting is an incredibly important part of the application development process.  The Cement framework provides some simple helpers and shortcuts for executing basic tests of your application. Please note that [cement.utils.test](/{{ version }}/api/utils/test.html) *does* require the `nose` package.  That said, using `cement.utils.test` is not required to test a Cement based application.  It is merely here for convenience, and is used by Cement when performing its own Nose tests.\n\nFor more information on testing, please see the following:\n\n- [UnitTest](http://docs.python.org/library/unittest.html)\n- [Nose](https://nose.readthedocs.io/en/latest/)\n- [Coverage](http://nedbatchelder.com/code/coverage/)\n\nAPI Reference:\n\n- [cement.utils.test](/{{ version }}/api/utils/test.html)\n\n\n## An Example Test Case\n\nThe following outlines a basic test case using the cement.utils.test module.\n\n```python\nfrom cement.utils import test\nfrom myapp.cli.main import MyApp\n\nclass MyTestCase(test.CementTestCase):\n    app_class = MyApp\n\n    def setUp(self):\n        super(MyTestCase, self).setUp()\n\n        # Create a default application for the test functions to use.\n        # Note that some tests may require you to perform this in the\n        # test function in order to alter functionality.  That's perfectly\n        # fine, this is only here for convenience.\n        self.app = MyApp(argv=[], config_files=[])\n\n    def test_myapp(self):\n        with self.app as app:\n\n            # Perform basic assertion checks.  You can do this anywhere\n            # in the test function, depending on what the assertion is\n            # checking.\n            self.ok(app.config.has_key('myapp', 'debug'))\n            self.eq(app.config.get('myapp', 'debug'), False)\n\n            # Run the applicaion, if necessary\n            app.run()\n\n            # Test the last rendered output (if app.render was used)\n            data, output = app.get_last_rendered()\n            self.eq(data, {'foo':'bar'})\n            self.eq(output, 'some rendered output text')\n\n    @test.raises(Exception)\n    def test_exception(self):\n        try:\n            # Perform tests that intentionally cause an exception.  The\n            # test passes only if the exception is raised.\n            raise Exception('test')\n        except Exception as e:\n            # Do further checks to ensure the proper exception was raised\n            self.eq(e.args[0], 'Some Exception Message')\n\n            # Finally, call raise again which re-raises the exception that\n            # we just caught.  This completes our test (to actually\n            # verify that the exception was raised)\n            raise\n```\n\n## Cement Testing Caveats\n\nIn general, testing Cement applications should be no different than testing anything else in Python.  That said, the following are some things to keep in mind.\n\n**Command Line Arguments**\n\nNever rely on `sys.argv` for command line arguments.  The `CementApp()` class accepts the `argv` keyword argument allowing you to pass the arguments that you would like to test for.  Using `sys.argv` will cause issues with the calling script (i.e. `nosetests`, etc) and other issues. Always pass `argv` to `CementApp()` in tests.\n\n**Config Files**\n\nIt is recommended to always set your apps `config_files` setting to an empty list, or to something relative to your current working directory.  Using default config files settings while testing will introduce unexpected results.  For example, if a `~/myapp.conf` user configuration exists it can alter the runtime of your application in a way that might cause tests to fail.\n\n**Making Things Easy**\n\nThe easiest way to accomplish the above is by sub-classing your `CementApp` into a special 'testing' version.  For example:\n\n```python\nfrom cement.utils import test\nfrom myapp.cli.main import MyApp\n\nclass MyTestApp(MyApp):\n    class Meta:\n        argv = []\n        config_files = []\n\nclass MyTestCase(test.CementTestCase):\n    app_class = MyTestApp\n\n    def test_myapp_default(self):\n        with self.app as app:\n            app.run()\n\n    def test_myapp_foo(self):\n        with MyTestApp(argv=['--foo', 'bar']) as app:\n            app.run()\n```\n","date":"2017-08-09T06:05:45.000Z","updated":"2017-08-09T06:05:45.000Z","path":"2.10/dev/testing.html","_id":"cj64m2i2r0008wtpwuf5ahgb0","comments":1,"layout":"page","content":"<p>Testing is an incredibly important part of the application development process.  The Cement framework provides some simple helpers and shortcuts for executing basic tests of your application. Please note that <a href=\"/2.10/api/utils/test.html\">cement.utils.test</a> <em>does</em> require the <code>nose</code> package.  That said, using <code>cement.utils.test</code> is not required to test a Cement based application.  It is merely here for convenience, and is used by Cement when performing its own Nose tests.</p>\n<p>For more information on testing, please see the following:</p>\n<ul>\n<li><a href=\"http://docs.python.org/library/unittest.html\" target=\"_blank\" rel=\"external\">UnitTest</a></li>\n<li><a href=\"https://nose.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"external\">Nose</a></li>\n<li><a href=\"http://nedbatchelder.com/code/coverage/\" target=\"_blank\" rel=\"external\">Coverage</a></li>\n</ul>\n<p>API Reference:</p>\n<ul>\n<li><a href=\"/2.10/api/utils/test.html\">cement.utils.test</a></li>\n</ul>\n<h2 id=\"An-Example-Test-Case\"><a href=\"#An-Example-Test-Case\" class=\"headerlink\" title=\"An Example Test Case\"></a>An Example Test Case</h2><p>The following outlines a basic test case using the cement.utils.test module.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.utils <span class=\"keyword\">import</span> test</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.cli.main <span class=\"keyword\">import</span> MyApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTestCase</span><span class=\"params\">(test.CementTestCase)</span>:</span></div><div class=\"line\">    app_class = MyApp</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">setUp</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        super(MyTestCase, self).setUp()</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># Create a default application for the test functions to use.</span></div><div class=\"line\">        <span class=\"comment\"># Note that some tests may require you to perform this in the</span></div><div class=\"line\">        <span class=\"comment\"># test function in order to alter functionality.  That's perfectly</span></div><div class=\"line\">        <span class=\"comment\"># fine, this is only here for convenience.</span></div><div class=\"line\">        self.app = MyApp(argv=[], config_files=[])</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_myapp</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">with</span> self.app <span class=\"keyword\">as</span> app:</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># Perform basic assertion checks.  You can do this anywhere</span></div><div class=\"line\">            <span class=\"comment\"># in the test function, depending on what the assertion is</span></div><div class=\"line\">            <span class=\"comment\"># checking.</span></div><div class=\"line\">            self.ok(app.config.has_key(<span class=\"string\">'myapp'</span>, <span class=\"string\">'debug'</span>))</div><div class=\"line\">            self.eq(app.config.get(<span class=\"string\">'myapp'</span>, <span class=\"string\">'debug'</span>), <span class=\"keyword\">False</span>)</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># Run the applicaion, if necessary</span></div><div class=\"line\">            app.run()</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># Test the last rendered output (if app.render was used)</span></div><div class=\"line\">            data, output = app.get_last_rendered()</div><div class=\"line\">            self.eq(data, &#123;<span class=\"string\">'foo'</span>:<span class=\"string\">'bar'</span>&#125;)</div><div class=\"line\">            self.eq(output, <span class=\"string\">'some rendered output text'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @test.raises(Exception)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_exception</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            <span class=\"comment\"># Perform tests that intentionally cause an exception.  The</span></div><div class=\"line\">            <span class=\"comment\"># test passes only if the exception is raised.</span></div><div class=\"line\">            <span class=\"keyword\">raise</span> Exception(<span class=\"string\">'test'</span>)</div><div class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</div><div class=\"line\">            <span class=\"comment\"># Do further checks to ensure the proper exception was raised</span></div><div class=\"line\">            self.eq(e.args[<span class=\"number\">0</span>], <span class=\"string\">'Some Exception Message'</span>)</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># Finally, call raise again which re-raises the exception that</span></div><div class=\"line\">            <span class=\"comment\"># we just caught.  This completes our test (to actually</span></div><div class=\"line\">            <span class=\"comment\"># verify that the exception was raised)</span></div><div class=\"line\">            <span class=\"keyword\">raise</span></div></pre></td></tr></table></figure>\n<h2 id=\"Cement-Testing-Caveats\"><a href=\"#Cement-Testing-Caveats\" class=\"headerlink\" title=\"Cement Testing Caveats\"></a>Cement Testing Caveats</h2><p>In general, testing Cement applications should be no different than testing anything else in Python.  That said, the following are some things to keep in mind.</p>\n<p><strong>Command Line Arguments</strong></p>\n<p>Never rely on <code>sys.argv</code> for command line arguments.  The <code>CementApp()</code> class accepts the <code>argv</code> keyword argument allowing you to pass the arguments that you would like to test for.  Using <code>sys.argv</code> will cause issues with the calling script (i.e. <code>nosetests</code>, etc) and other issues. Always pass <code>argv</code> to <code>CementApp()</code> in tests.</p>\n<p><strong>Config Files</strong></p>\n<p>It is recommended to always set your apps <code>config_files</code> setting to an empty list, or to something relative to your current working directory.  Using default config files settings while testing will introduce unexpected results.  For example, if a <code>~/myapp.conf</code> user configuration exists it can alter the runtime of your application in a way that might cause tests to fail.</p>\n<p><strong>Making Things Easy</strong></p>\n<p>The easiest way to accomplish the above is by sub-classing your <code>CementApp</code> into a special ‘testing’ version.  For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.utils <span class=\"keyword\">import</span> test</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.cli.main <span class=\"keyword\">import</span> MyApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTestApp</span><span class=\"params\">(MyApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        argv = []</div><div class=\"line\">        config_files = []</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTestCase</span><span class=\"params\">(test.CementTestCase)</span>:</span></div><div class=\"line\">    app_class = MyTestApp</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_myapp_default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">with</span> self.app <span class=\"keyword\">as</span> app:</div><div class=\"line\">            app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_myapp_foo</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">with</span> MyTestApp(argv=[<span class=\"string\">'--foo'</span>, <span class=\"string\">'bar'</span>]) <span class=\"keyword\">as</span> app:</div><div class=\"line\">            app.run()</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>Testing is an incredibly important part of the application development process.  The Cement framework provides some simple helpers and shortcuts for executing basic tests of your application. Please note that <a href=\"/2.10/api/utils/test.html\">cement.utils.test</a> <em>does</em> require the <code>nose</code> package.  That said, using <code>cement.utils.test</code> is not required to test a Cement based application.  It is merely here for convenience, and is used by Cement when performing its own Nose tests.</p>\n<p>For more information on testing, please see the following:</p>\n<ul>\n<li><a href=\"http://docs.python.org/library/unittest.html\">UnitTest</a></li>\n<li><a href=\"https://nose.readthedocs.io/en/latest/\">Nose</a></li>\n<li><a href=\"http://nedbatchelder.com/code/coverage/\">Coverage</a></li>\n</ul>\n<p>API Reference:</p>\n<ul>\n<li><a href=\"/2.10/api/utils/test.html\">cement.utils.test</a></li>\n</ul>\n<h2 id=\"An-Example-Test-Case\"><a href=\"#An-Example-Test-Case\" class=\"headerlink\" title=\"An Example Test Case\"></a>An Example Test Case</h2><p>The following outlines a basic test case using the cement.utils.test module.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.utils <span class=\"keyword\">import</span> test</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.cli.main <span class=\"keyword\">import</span> MyApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTestCase</span><span class=\"params\">(test.CementTestCase)</span>:</span></div><div class=\"line\">    app_class = MyApp</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">setUp</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        super(MyTestCase, self).setUp()</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># Create a default application for the test functions to use.</span></div><div class=\"line\">        <span class=\"comment\"># Note that some tests may require you to perform this in the</span></div><div class=\"line\">        <span class=\"comment\"># test function in order to alter functionality.  That's perfectly</span></div><div class=\"line\">        <span class=\"comment\"># fine, this is only here for convenience.</span></div><div class=\"line\">        self.app = MyApp(argv=[], config_files=[])</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_myapp</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">with</span> self.app <span class=\"keyword\">as</span> app:</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># Perform basic assertion checks.  You can do this anywhere</span></div><div class=\"line\">            <span class=\"comment\"># in the test function, depending on what the assertion is</span></div><div class=\"line\">            <span class=\"comment\"># checking.</span></div><div class=\"line\">            self.ok(app.config.has_key(<span class=\"string\">'myapp'</span>, <span class=\"string\">'debug'</span>))</div><div class=\"line\">            self.eq(app.config.get(<span class=\"string\">'myapp'</span>, <span class=\"string\">'debug'</span>), <span class=\"keyword\">False</span>)</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># Run the applicaion, if necessary</span></div><div class=\"line\">            app.run()</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># Test the last rendered output (if app.render was used)</span></div><div class=\"line\">            data, output = app.get_last_rendered()</div><div class=\"line\">            self.eq(data, &#123;<span class=\"string\">'foo'</span>:<span class=\"string\">'bar'</span>&#125;)</div><div class=\"line\">            self.eq(output, <span class=\"string\">'some rendered output text'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @test.raises(Exception)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_exception</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            <span class=\"comment\"># Perform tests that intentionally cause an exception.  The</span></div><div class=\"line\">            <span class=\"comment\"># test passes only if the exception is raised.</span></div><div class=\"line\">            <span class=\"keyword\">raise</span> Exception(<span class=\"string\">'test'</span>)</div><div class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</div><div class=\"line\">            <span class=\"comment\"># Do further checks to ensure the proper exception was raised</span></div><div class=\"line\">            self.eq(e.args[<span class=\"number\">0</span>], <span class=\"string\">'Some Exception Message'</span>)</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># Finally, call raise again which re-raises the exception that</span></div><div class=\"line\">            <span class=\"comment\"># we just caught.  This completes our test (to actually</span></div><div class=\"line\">            <span class=\"comment\"># verify that the exception was raised)</span></div><div class=\"line\">            <span class=\"keyword\">raise</span></div></pre></td></tr></table></figure>\n<h2 id=\"Cement-Testing-Caveats\"><a href=\"#Cement-Testing-Caveats\" class=\"headerlink\" title=\"Cement Testing Caveats\"></a>Cement Testing Caveats</h2><p>In general, testing Cement applications should be no different than testing anything else in Python.  That said, the following are some things to keep in mind.</p>\n<p><strong>Command Line Arguments</strong></p>\n<p>Never rely on <code>sys.argv</code> for command line arguments.  The <code>CementApp()</code> class accepts the <code>argv</code> keyword argument allowing you to pass the arguments that you would like to test for.  Using <code>sys.argv</code> will cause issues with the calling script (i.e. <code>nosetests</code>, etc) and other issues. Always pass <code>argv</code> to <code>CementApp()</code> in tests.</p>\n<p><strong>Config Files</strong></p>\n<p>It is recommended to always set your apps <code>config_files</code> setting to an empty list, or to something relative to your current working directory.  Using default config files settings while testing will introduce unexpected results.  For example, if a <code>~/myapp.conf</code> user configuration exists it can alter the runtime of your application in a way that might cause tests to fail.</p>\n<p><strong>Making Things Easy</strong></p>\n<p>The easiest way to accomplish the above is by sub-classing your <code>CementApp</code> into a special ‘testing’ version.  For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.utils <span class=\"keyword\">import</span> test</div><div class=\"line\"><span class=\"keyword\">from</span> myapp.cli.main <span class=\"keyword\">import</span> MyApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTestApp</span><span class=\"params\">(MyApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        argv = []</div><div class=\"line\">        config_files = []</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyTestCase</span><span class=\"params\">(test.CementTestCase)</span>:</span></div><div class=\"line\">    app_class = MyTestApp</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_myapp_default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">with</span> self.app <span class=\"keyword\">as</span> app:</div><div class=\"line\">            app.run()</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_myapp_foo</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">with</span> MyTestApp(argv=[<span class=\"string\">'--foo'</span>, <span class=\"string\">'bar'</span>]) <span class=\"keyword\">as</span> app:</div><div class=\"line\">            app.run()</div></pre></td></tr></table></figure>\n"},{"title":"Application Design","type":"guide","version":"2.10","order":19,"_content":"\n<p class=\"tip-info\">\nThe following is best-practice, recommendation and guidance.  Do not feel as if you must follow everything here to the \"T\".  Take it, bend it, make it work for you however you need.\n</p>\n\nCement does not enforce any form of application layout, or design.  That said, there are a number of best practices that can help newcomers get settled into using Cement as a foundation to build their application.\n\n## Single File Scripts\n\nCement can easily be used for quick applications and scripts that are based out of a single file.  The following is a minimal example that creates a `CementApp` with several sub-commands:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\n\nclass BaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n        description = \"MyApp Does Amazing Things\"\n        arguments = [\n            (['-f, '--foo'], dict(help='notorious foo option')),\n            (['-b', '--bar'], dict(help='infamous bar option')),\n            ]\n\n    @expose(hide=True)\n    def default(self):\n        print(\"Inside MyAppBaseController.default()\")\n\n    @expose(help=\"this is some help text about the cmd1\")\n    def cmd1(self):\n        print(\"Inside BaseController.cmd1()\")\n\n    @expose(help=\"this is some help text about the cmd2\")\n    def cmd2(self):\n        print(\"Inside BaseController.cmd2()\")\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        base_controller = BaseController\n\n\ndef main():\n    with MyApp() as app:\n        app.run()\n\nif __name__ == '__main__':\n    main()\n```\n\nIn this example, we've defined a base controller to handler the heavy lifting of what this script does, while providing sub-commands to handler different tasks.  We've also included a number of command line arguments/options that can be used to alter how the script operates, and to allow user input.\n\nNotice that we have defined a `main()` function, and then beyond that where we call `main()` if `__name__` is `__main__`.  This essentially says, if the script was called directly (not imported by another Python library) then execute the `main()` function.\n\n\n## Multi-File Applications\n\nLarger applications need to be properly organized to keep code clean, and to keep a high level of maintainability (read: to keep things from getting shitty). [The Boss Project](https://boss.readthedocs.io) provides our recommended application layout, and is a great starting point for anyone new to Cement.\n\nThe primary detail about how to layout your code is this:  All CLI/Cement related code should live separate from the \"core logic\" of your application. Most likely, you will have some code that is re-usable by other people and you do not want to mix this with your Cement code, because that will rely on Cement being loaded to function properly (like it is when called from command line).\n\nFor this reason, we recommend a structure similar to the following:\n\n```\n- myapp/\n- myapp/cli\n- myapp/core\n```\n\nAll code related to your CLI, which relies on Cement, should live in `myapp/cli/`, and all code that is the \"core logic\" of your application should live in a module like `myapp/core`.  The idea being that, should anyone wish to re-use your library, they should not be required to run your CLI application to do so.  You want people to be able to do the following:\n\n```python\nfrom yourapp.core.some_library import SomeClass\n```\n\nThe `SomeClass` should not rely on `CementApp` (i.e. the `app` object). In this case, the code under `myapp/cli/` would import from `myapp/core/` and add the \"CLI\" stuff on top of it.\n\nIn short, the CLI code should handle interaction with the user via the shell, and the core code should handle application logic un-reliant on the CLI being loaded.\n\nSee the [Starting Projects from Boss Templates](/{{ version }}/dev/boss_templates.html) section for more info on using Boss.\n\n\n## Handling High Level Exceptions\n\nThe following expands on the above to give an example of how you might handle exceptions at the highest level (wrapped around the app object).  It is very well known that exception handling should happen as close to the source of the exception as possible, and you should do that.  However at the top level (generally in your `main.py` or similar) you want to handle certain exceptions (such as argument errors, or user interaction related errors) so that they are presented nicely to the user.  End-users don't like stack traces!\n\nThe below example catches common framework exceptions that Cement might throw, but you could also catch your own application specific exception this way:\n\n```python\nimport sys\n\nfrom cement.core.foundation import CementApp\nfrom cement.core.exc import FrameworkError, CaughtSignal\n\n\ndef main():\n    with CementApp('myapp') as app:\n        try:\n            app.run()\n\n        except CaughtSignal as e:\n            # determine what the signal is, and do something with it?\n            from signal import SIGINT, SIGABRT\n\n            if e.signum == SIGINT:\n                # do something... maybe change the exit code?\n                app.exit_code = 110\n            elif e.signum == SIGABRT:\n                # do something else...\n                app.exit_code = 111\n\n        except FrameworkError as e:\n            # do something when a framework error happens\n            print(\"FrameworkError => %s\" % e)\n\n            # and maybe set the exit code to something unique as well\n            app.exit_code = 300\n\n        finally:\n            # Maybe we want to see a full-stack trace for the above\n            # exceptions, but only if --debug was passed?\n            if app.debug:\n                import traceback\n                traceback.print_exc()\n\nif __name__ == '__main__':\n    main()\n```\n","source":"2.10/dev/application_design.md","raw":"---\ntitle: Application Design\ntype: guide\nversion: \"2.10\"\norder: 19\n---\n\n<p class=\"tip-info\">\nThe following is best-practice, recommendation and guidance.  Do not feel as if you must follow everything here to the \"T\".  Take it, bend it, make it work for you however you need.\n</p>\n\nCement does not enforce any form of application layout, or design.  That said, there are a number of best practices that can help newcomers get settled into using Cement as a foundation to build their application.\n\n## Single File Scripts\n\nCement can easily be used for quick applications and scripts that are based out of a single file.  The following is a minimal example that creates a `CementApp` with several sub-commands:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\n\nclass BaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n        description = \"MyApp Does Amazing Things\"\n        arguments = [\n            (['-f, '--foo'], dict(help='notorious foo option')),\n            (['-b', '--bar'], dict(help='infamous bar option')),\n            ]\n\n    @expose(hide=True)\n    def default(self):\n        print(\"Inside MyAppBaseController.default()\")\n\n    @expose(help=\"this is some help text about the cmd1\")\n    def cmd1(self):\n        print(\"Inside BaseController.cmd1()\")\n\n    @expose(help=\"this is some help text about the cmd2\")\n    def cmd2(self):\n        print(\"Inside BaseController.cmd2()\")\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        base_controller = BaseController\n\n\ndef main():\n    with MyApp() as app:\n        app.run()\n\nif __name__ == '__main__':\n    main()\n```\n\nIn this example, we've defined a base controller to handler the heavy lifting of what this script does, while providing sub-commands to handler different tasks.  We've also included a number of command line arguments/options that can be used to alter how the script operates, and to allow user input.\n\nNotice that we have defined a `main()` function, and then beyond that where we call `main()` if `__name__` is `__main__`.  This essentially says, if the script was called directly (not imported by another Python library) then execute the `main()` function.\n\n\n## Multi-File Applications\n\nLarger applications need to be properly organized to keep code clean, and to keep a high level of maintainability (read: to keep things from getting shitty). [The Boss Project](https://boss.readthedocs.io) provides our recommended application layout, and is a great starting point for anyone new to Cement.\n\nThe primary detail about how to layout your code is this:  All CLI/Cement related code should live separate from the \"core logic\" of your application. Most likely, you will have some code that is re-usable by other people and you do not want to mix this with your Cement code, because that will rely on Cement being loaded to function properly (like it is when called from command line).\n\nFor this reason, we recommend a structure similar to the following:\n\n```\n- myapp/\n- myapp/cli\n- myapp/core\n```\n\nAll code related to your CLI, which relies on Cement, should live in `myapp/cli/`, and all code that is the \"core logic\" of your application should live in a module like `myapp/core`.  The idea being that, should anyone wish to re-use your library, they should not be required to run your CLI application to do so.  You want people to be able to do the following:\n\n```python\nfrom yourapp.core.some_library import SomeClass\n```\n\nThe `SomeClass` should not rely on `CementApp` (i.e. the `app` object). In this case, the code under `myapp/cli/` would import from `myapp/core/` and add the \"CLI\" stuff on top of it.\n\nIn short, the CLI code should handle interaction with the user via the shell, and the core code should handle application logic un-reliant on the CLI being loaded.\n\nSee the [Starting Projects from Boss Templates](/{{ version }}/dev/boss_templates.html) section for more info on using Boss.\n\n\n## Handling High Level Exceptions\n\nThe following expands on the above to give an example of how you might handle exceptions at the highest level (wrapped around the app object).  It is very well known that exception handling should happen as close to the source of the exception as possible, and you should do that.  However at the top level (generally in your `main.py` or similar) you want to handle certain exceptions (such as argument errors, or user interaction related errors) so that they are presented nicely to the user.  End-users don't like stack traces!\n\nThe below example catches common framework exceptions that Cement might throw, but you could also catch your own application specific exception this way:\n\n```python\nimport sys\n\nfrom cement.core.foundation import CementApp\nfrom cement.core.exc import FrameworkError, CaughtSignal\n\n\ndef main():\n    with CementApp('myapp') as app:\n        try:\n            app.run()\n\n        except CaughtSignal as e:\n            # determine what the signal is, and do something with it?\n            from signal import SIGINT, SIGABRT\n\n            if e.signum == SIGINT:\n                # do something... maybe change the exit code?\n                app.exit_code = 110\n            elif e.signum == SIGABRT:\n                # do something else...\n                app.exit_code = 111\n\n        except FrameworkError as e:\n            # do something when a framework error happens\n            print(\"FrameworkError => %s\" % e)\n\n            # and maybe set the exit code to something unique as well\n            app.exit_code = 300\n\n        finally:\n            # Maybe we want to see a full-stack trace for the above\n            # exceptions, but only if --debug was passed?\n            if app.debug:\n                import traceback\n                traceback.print_exc()\n\nif __name__ == '__main__':\n    main()\n```\n","date":"2017-08-09T06:23:28.000Z","updated":"2017-08-09T06:23:28.000Z","path":"2.10/dev/application_design.html","_id":"cj64m3h6t0009wtpwbbon93ds","comments":1,"layout":"page","content":"<p class=\"tip-info\"><br>The following is best-practice, recommendation and guidance.  Do not feel as if you must follow everything here to the “T”.  Take it, bend it, make it work for you however you need.<br></p>\n\n<p>Cement does not enforce any form of application layout, or design.  That said, there are a number of best practices that can help newcomers get settled into using Cement as a foundation to build their application.</p>\n<h2 id=\"Single-File-Scripts\"><a href=\"#Single-File-Scripts\" class=\"headerlink\" title=\"Single File Scripts\"></a>Single File Scripts</h2><p>Cement can easily be used for quick applications and scripts that are based out of a single file.  The following is a minimal example that creates a <code>CementApp</code> with several sub-commands:</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">from cement.core.foundation import CementApp</div><div class=\"line\">from cement.core.controller import CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class BaseController(CementBaseController):</div><div class=\"line\">    class Meta:</div><div class=\"line\">        label = 'base'</div><div class=\"line\">        description = \"MyApp Does Amazing Things\"</div><div class=\"line\">        arguments = [</div><div class=\"line\">            (['-f, '--foo'], dict(help='notorious foo option')),</div><div class=\"line\">            (['-b', '--bar'], dict(help='infamous bar option')),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\">    @expose(hide=True)</div><div class=\"line\">    def default(self):</div><div class=\"line\">        print(\"Inside MyAppBaseController.default()\")</div><div class=\"line\"></div><div class=\"line\">    @expose(help=\"this is some help text about the cmd1\")</div><div class=\"line\">    def cmd1(self):</div><div class=\"line\">        print(\"Inside BaseController.cmd1()\")</div><div class=\"line\"></div><div class=\"line\">    @expose(help=\"this is some help text about the cmd2\")</div><div class=\"line\">    def cmd2(self):</div><div class=\"line\">        print(\"Inside BaseController.cmd2()\")</div><div class=\"line\"></div><div class=\"line\">class MyApp(CementApp):</div><div class=\"line\">    class Meta:</div><div class=\"line\">        label = 'myapp'</div><div class=\"line\">        base_controller = BaseController</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    with MyApp() as app:</div><div class=\"line\">        app.run()</div><div class=\"line\"></div><div class=\"line\">if __name__ == '__main__':</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<p>In this example, we’ve defined a base controller to handler the heavy lifting of what this script does, while providing sub-commands to handler different tasks.  We’ve also included a number of command line arguments/options that can be used to alter how the script operates, and to allow user input.</p>\n<p>Notice that we have defined a <code>main()</code> function, and then beyond that where we call <code>main()</code> if <code>__name__</code> is <code>__main__</code>.  This essentially says, if the script was called directly (not imported by another Python library) then execute the <code>main()</code> function.</p>\n<h2 id=\"Multi-File-Applications\"><a href=\"#Multi-File-Applications\" class=\"headerlink\" title=\"Multi-File Applications\"></a>Multi-File Applications</h2><p>Larger applications need to be properly organized to keep code clean, and to keep a high level of maintainability (read: to keep things from getting shitty). <a href=\"https://boss.readthedocs.io\" target=\"_blank\" rel=\"external\">The Boss Project</a> provides our recommended application layout, and is a great starting point for anyone new to Cement.</p>\n<p>The primary detail about how to layout your code is this:  All CLI/Cement related code should live separate from the “core logic” of your application. Most likely, you will have some code that is re-usable by other people and you do not want to mix this with your Cement code, because that will rely on Cement being loaded to function properly (like it is when called from command line).</p>\n<p>For this reason, we recommend a structure similar to the following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- myapp/</div><div class=\"line\">- myapp/cli</div><div class=\"line\">- myapp/core</div></pre></td></tr></table></figure>\n<p>All code related to your CLI, which relies on Cement, should live in <code>myapp/cli/</code>, and all code that is the “core logic” of your application should live in a module like <code>myapp/core</code>.  The idea being that, should anyone wish to re-use your library, they should not be required to run your CLI application to do so.  You want people to be able to do the following:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> yourapp.core.some_library <span class=\"keyword\">import</span> SomeClass</div></pre></td></tr></table></figure>\n<p>The <code>SomeClass</code> should not rely on <code>CementApp</code> (i.e. the <code>app</code> object). In this case, the code under <code>myapp/cli/</code> would import from <code>myapp/core/</code> and add the “CLI” stuff on top of it.</p>\n<p>In short, the CLI code should handle interaction with the user via the shell, and the core code should handle application logic un-reliant on the CLI being loaded.</p>\n<p>See the <a href=\"/2.10/dev/boss_templates.html\">Starting Projects from Boss Templates</a> section for more info on using Boss.</p>\n<h2 id=\"Handling-High-Level-Exceptions\"><a href=\"#Handling-High-Level-Exceptions\" class=\"headerlink\" title=\"Handling High Level Exceptions\"></a>Handling High Level Exceptions</h2><p>The following expands on the above to give an example of how you might handle exceptions at the highest level (wrapped around the app object).  It is very well known that exception handling should happen as close to the source of the exception as possible, and you should do that.  However at the top level (generally in your <code>main.py</code> or similar) you want to handle certain exceptions (such as argument errors, or user interaction related errors) so that they are presented nicely to the user.  End-users don’t like stack traces!</p>\n<p>The below example catches common framework exceptions that Cement might throw, but you could also catch your own application specific exception this way:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.exc <span class=\"keyword\">import</span> FrameworkError, CaughtSignal</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            app.run()</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">except</span> CaughtSignal <span class=\"keyword\">as</span> e:</div><div class=\"line\">            <span class=\"comment\"># determine what the signal is, and do something with it?</span></div><div class=\"line\">            <span class=\"keyword\">from</span> signal <span class=\"keyword\">import</span> SIGINT, SIGABRT</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> e.signum == SIGINT:</div><div class=\"line\">                <span class=\"comment\"># do something... maybe change the exit code?</span></div><div class=\"line\">                app.exit_code = <span class=\"number\">110</span></div><div class=\"line\">            <span class=\"keyword\">elif</span> e.signum == SIGABRT:</div><div class=\"line\">                <span class=\"comment\"># do something else...</span></div><div class=\"line\">                app.exit_code = <span class=\"number\">111</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">except</span> FrameworkError <span class=\"keyword\">as</span> e:</div><div class=\"line\">            <span class=\"comment\"># do something when a framework error happens</span></div><div class=\"line\">            print(<span class=\"string\">\"FrameworkError =&gt; %s\"</span> % e)</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># and maybe set the exit code to something unique as well</span></div><div class=\"line\">            app.exit_code = <span class=\"number\">300</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">finally</span>:</div><div class=\"line\">            <span class=\"comment\"># Maybe we want to see a full-stack trace for the above</span></div><div class=\"line\">            <span class=\"comment\"># exceptions, but only if --debug was passed?</span></div><div class=\"line\">            <span class=\"keyword\">if</span> app.debug:</div><div class=\"line\">                <span class=\"keyword\">import</span> traceback</div><div class=\"line\">                traceback.print_exc()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p class=\"tip-info\"><br>The following is best-practice, recommendation and guidance.  Do not feel as if you must follow everything here to the “T”.  Take it, bend it, make it work for you however you need.<br></p>\n\n<p>Cement does not enforce any form of application layout, or design.  That said, there are a number of best practices that can help newcomers get settled into using Cement as a foundation to build their application.</p>\n<h2 id=\"Single-File-Scripts\"><a href=\"#Single-File-Scripts\" class=\"headerlink\" title=\"Single File Scripts\"></a>Single File Scripts</h2><p>Cement can easily be used for quick applications and scripts that are based out of a single file.  The following is a minimal example that creates a <code>CementApp</code> with several sub-commands:</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><div class=\"line\">from cement.core.foundation import CementApp</div><div class=\"line\">from cement.core.controller import CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">class BaseController(CementBaseController):</div><div class=\"line\">    class Meta:</div><div class=\"line\">        label = 'base'</div><div class=\"line\">        description = \"MyApp Does Amazing Things\"</div><div class=\"line\">        arguments = [</div><div class=\"line\">            (['-f, '--foo'], dict(help='notorious foo option')),</div><div class=\"line\">            (['-b', '--bar'], dict(help='infamous bar option')),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\">    @expose(hide=True)</div><div class=\"line\">    def default(self):</div><div class=\"line\">        print(\"Inside MyAppBaseController.default()\")</div><div class=\"line\"></div><div class=\"line\">    @expose(help=\"this is some help text about the cmd1\")</div><div class=\"line\">    def cmd1(self):</div><div class=\"line\">        print(\"Inside BaseController.cmd1()\")</div><div class=\"line\"></div><div class=\"line\">    @expose(help=\"this is some help text about the cmd2\")</div><div class=\"line\">    def cmd2(self):</div><div class=\"line\">        print(\"Inside BaseController.cmd2()\")</div><div class=\"line\"></div><div class=\"line\">class MyApp(CementApp):</div><div class=\"line\">    class Meta:</div><div class=\"line\">        label = 'myapp'</div><div class=\"line\">        base_controller = BaseController</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">def main():</div><div class=\"line\">    with MyApp() as app:</div><div class=\"line\">        app.run()</div><div class=\"line\"></div><div class=\"line\">if __name__ == '__main__':</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<p>In this example, we’ve defined a base controller to handler the heavy lifting of what this script does, while providing sub-commands to handler different tasks.  We’ve also included a number of command line arguments/options that can be used to alter how the script operates, and to allow user input.</p>\n<p>Notice that we have defined a <code>main()</code> function, and then beyond that where we call <code>main()</code> if <code>__name__</code> is <code>__main__</code>.  This essentially says, if the script was called directly (not imported by another Python library) then execute the <code>main()</code> function.</p>\n<h2 id=\"Multi-File-Applications\"><a href=\"#Multi-File-Applications\" class=\"headerlink\" title=\"Multi-File Applications\"></a>Multi-File Applications</h2><p>Larger applications need to be properly organized to keep code clean, and to keep a high level of maintainability (read: to keep things from getting shitty). <a href=\"https://boss.readthedocs.io\">The Boss Project</a> provides our recommended application layout, and is a great starting point for anyone new to Cement.</p>\n<p>The primary detail about how to layout your code is this:  All CLI/Cement related code should live separate from the “core logic” of your application. Most likely, you will have some code that is re-usable by other people and you do not want to mix this with your Cement code, because that will rely on Cement being loaded to function properly (like it is when called from command line).</p>\n<p>For this reason, we recommend a structure similar to the following:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">- myapp/</div><div class=\"line\">- myapp/cli</div><div class=\"line\">- myapp/core</div></pre></td></tr></table></figure>\n<p>All code related to your CLI, which relies on Cement, should live in <code>myapp/cli/</code>, and all code that is the “core logic” of your application should live in a module like <code>myapp/core</code>.  The idea being that, should anyone wish to re-use your library, they should not be required to run your CLI application to do so.  You want people to be able to do the following:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> yourapp.core.some_library <span class=\"keyword\">import</span> SomeClass</div></pre></td></tr></table></figure>\n<p>The <code>SomeClass</code> should not rely on <code>CementApp</code> (i.e. the <code>app</code> object). In this case, the code under <code>myapp/cli/</code> would import from <code>myapp/core/</code> and add the “CLI” stuff on top of it.</p>\n<p>In short, the CLI code should handle interaction with the user via the shell, and the core code should handle application logic un-reliant on the CLI being loaded.</p>\n<p>See the <a href=\"/2.10/dev/boss_templates.html\">Starting Projects from Boss Templates</a> section for more info on using Boss.</p>\n<h2 id=\"Handling-High-Level-Exceptions\"><a href=\"#Handling-High-Level-Exceptions\" class=\"headerlink\" title=\"Handling High Level Exceptions\"></a>Handling High Level Exceptions</h2><p>The following expands on the above to give an example of how you might handle exceptions at the highest level (wrapped around the app object).  It is very well known that exception handling should happen as close to the source of the exception as possible, and you should do that.  However at the top level (generally in your <code>main.py</code> or similar) you want to handle certain exceptions (such as argument errors, or user interaction related errors) so that they are presented nicely to the user.  End-users don’t like stack traces!</p>\n<p>The below example catches common framework exceptions that Cement might throw, but you could also catch your own application specific exception this way:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> sys</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.exc <span class=\"keyword\">import</span> FrameworkError, CaughtSignal</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">with</span> CementApp(<span class=\"string\">'myapp'</span>) <span class=\"keyword\">as</span> app:</div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            app.run()</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">except</span> CaughtSignal <span class=\"keyword\">as</span> e:</div><div class=\"line\">            <span class=\"comment\"># determine what the signal is, and do something with it?</span></div><div class=\"line\">            <span class=\"keyword\">from</span> signal <span class=\"keyword\">import</span> SIGINT, SIGABRT</div><div class=\"line\"></div><div class=\"line\">            <span class=\"keyword\">if</span> e.signum == SIGINT:</div><div class=\"line\">                <span class=\"comment\"># do something... maybe change the exit code?</span></div><div class=\"line\">                app.exit_code = <span class=\"number\">110</span></div><div class=\"line\">            <span class=\"keyword\">elif</span> e.signum == SIGABRT:</div><div class=\"line\">                <span class=\"comment\"># do something else...</span></div><div class=\"line\">                app.exit_code = <span class=\"number\">111</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">except</span> FrameworkError <span class=\"keyword\">as</span> e:</div><div class=\"line\">            <span class=\"comment\"># do something when a framework error happens</span></div><div class=\"line\">            print(<span class=\"string\">\"FrameworkError =&gt; %s\"</span> % e)</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># and maybe set the exit code to something unique as well</span></div><div class=\"line\">            app.exit_code = <span class=\"number\">300</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">finally</span>:</div><div class=\"line\">            <span class=\"comment\"># Maybe we want to see a full-stack trace for the above</span></div><div class=\"line\">            <span class=\"comment\"># exceptions, but only if --debug was passed?</span></div><div class=\"line\">            <span class=\"keyword\">if</span> app.debug:</div><div class=\"line\">                <span class=\"keyword\">import</span> traceback</div><div class=\"line\">                traceback.print_exc()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n"},{"title":"BOSS Templates","type":"guide","version":"2.10","order":20,"_content":"\n[The Boss Project](https://boss.readthedocs.io) provides 'Baseline Open Source Software' templates and development tools. It has similarities to PasteScript with regards to templating, but far easier to extend.  The official template repository includes a number of templates specifically for Cement, and are the recommended means of start Cement based projects.\n\nThis is just a quick overview of creating Cement Apps, Plugins, and Extensions with Boss.\n\n## Creating a Cement App\n\n```\n$ boss create ./myapp -t boss:cement-app\n\n$ cd myapp\n\n$ virtualenv /path/to/myapp/env\n\n$ source /path/to/myapp/env/bin/activate\n\n$ pip install -r requirements.txt\n\n$ python setup.py develop\n\n$ myapp --help\n\n$ pip install nose coverage\n\n$ python setup.py nosetests\n```\n\n\n## Creating a Cement Plugin\n\n```\n$ source /path/to/myapp/env/bin/activate\n\n$ cd /path/to/myapp\n\n$ mkdir plugins\n\n$ boss create ./plugins/myplugin -t boss:cement-plugin\n```\n\n\nAdd the following to `~/myapp.conf` (or whereever your config file is):\n\n```\n[myapp]\nplugin_config_dir = /path/to/myapp/config/plugins.d\nplugin_dir = /path/to/myapp/plugins\n\n# Enable the plugin here, or in a plugins.d/myplugin.conf\n[myplugin]\nenable_plugin = 1\n```\n\nAnd it should be enabled when you run your app (though it doesn't do anything out of the box).\n\n\n## Creating a Cement Extension\n\n3rd party extensions are generally created within the app they are being built with, but do not have to be.  In this case we are adding the extension to an existing Cement project:\n\n```\n$ boss create ./myapp -t boss:cement-ext\n```\n\nAt this point you would enable the extension in your app to utilize it.\n","source":"2.10/dev/boss_templates.md","raw":"---\ntitle: BOSS Templates\ntype: guide\nversion: \"2.10\"\norder: 20\n---\n\n[The Boss Project](https://boss.readthedocs.io) provides 'Baseline Open Source Software' templates and development tools. It has similarities to PasteScript with regards to templating, but far easier to extend.  The official template repository includes a number of templates specifically for Cement, and are the recommended means of start Cement based projects.\n\nThis is just a quick overview of creating Cement Apps, Plugins, and Extensions with Boss.\n\n## Creating a Cement App\n\n```\n$ boss create ./myapp -t boss:cement-app\n\n$ cd myapp\n\n$ virtualenv /path/to/myapp/env\n\n$ source /path/to/myapp/env/bin/activate\n\n$ pip install -r requirements.txt\n\n$ python setup.py develop\n\n$ myapp --help\n\n$ pip install nose coverage\n\n$ python setup.py nosetests\n```\n\n\n## Creating a Cement Plugin\n\n```\n$ source /path/to/myapp/env/bin/activate\n\n$ cd /path/to/myapp\n\n$ mkdir plugins\n\n$ boss create ./plugins/myplugin -t boss:cement-plugin\n```\n\n\nAdd the following to `~/myapp.conf` (or whereever your config file is):\n\n```\n[myapp]\nplugin_config_dir = /path/to/myapp/config/plugins.d\nplugin_dir = /path/to/myapp/plugins\n\n# Enable the plugin here, or in a plugins.d/myplugin.conf\n[myplugin]\nenable_plugin = 1\n```\n\nAnd it should be enabled when you run your app (though it doesn't do anything out of the box).\n\n\n## Creating a Cement Extension\n\n3rd party extensions are generally created within the app they are being built with, but do not have to be.  In this case we are adding the extension to an existing Cement project:\n\n```\n$ boss create ./myapp -t boss:cement-ext\n```\n\nAt this point you would enable the extension in your app to utilize it.\n","date":"2017-08-09T06:27:20.000Z","updated":"2017-08-09T06:27:20.000Z","path":"2.10/dev/boss_templates.html","_id":"cj64mu95t000bwtpwpa2l77pn","comments":1,"layout":"page","content":"<p><a href=\"https://boss.readthedocs.io\" target=\"_blank\" rel=\"external\">The Boss Project</a> provides ‘Baseline Open Source Software’ templates and development tools. It has similarities to PasteScript with regards to templating, but far easier to extend.  The official template repository includes a number of templates specifically for Cement, and are the recommended means of start Cement based projects.</p>\n<p>This is just a quick overview of creating Cement Apps, Plugins, and Extensions with Boss.</p>\n<h2 id=\"Creating-a-Cement-App\"><a href=\"#Creating-a-Cement-App\" class=\"headerlink\" title=\"Creating a Cement App\"></a>Creating a Cement App</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ boss create ./myapp -t boss:cement-app</div><div class=\"line\"></div><div class=\"line\">$ cd myapp</div><div class=\"line\"></div><div class=\"line\">$ virtualenv /path/to/myapp/env</div><div class=\"line\"></div><div class=\"line\">$ source /path/to/myapp/env/bin/activate</div><div class=\"line\"></div><div class=\"line\">$ pip install -r requirements.txt</div><div class=\"line\"></div><div class=\"line\">$ python setup.py develop</div><div class=\"line\"></div><div class=\"line\">$ myapp --help</div><div class=\"line\"></div><div class=\"line\">$ pip install nose coverage</div><div class=\"line\"></div><div class=\"line\">$ python setup.py nosetests</div></pre></td></tr></table></figure>\n<h2 id=\"Creating-a-Cement-Plugin\"><a href=\"#Creating-a-Cement-Plugin\" class=\"headerlink\" title=\"Creating a Cement Plugin\"></a>Creating a Cement Plugin</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ source /path/to/myapp/env/bin/activate</div><div class=\"line\"></div><div class=\"line\">$ cd /path/to/myapp</div><div class=\"line\"></div><div class=\"line\">$ mkdir plugins</div><div class=\"line\"></div><div class=\"line\">$ boss create ./plugins/myplugin -t boss:cement-plugin</div></pre></td></tr></table></figure>\n<p>Add the following to <code>~/myapp.conf</code> (or whereever your config file is):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">plugin_config_dir = /path/to/myapp/config/plugins.d</div><div class=\"line\">plugin_dir = /path/to/myapp/plugins</div><div class=\"line\"></div><div class=\"line\"># Enable the plugin here, or in a plugins.d/myplugin.conf</div><div class=\"line\">[myplugin]</div><div class=\"line\">enable_plugin = 1</div></pre></td></tr></table></figure>\n<p>And it should be enabled when you run your app (though it doesn’t do anything out of the box).</p>\n<h2 id=\"Creating-a-Cement-Extension\"><a href=\"#Creating-a-Cement-Extension\" class=\"headerlink\" title=\"Creating a Cement Extension\"></a>Creating a Cement Extension</h2><p>3rd party extensions are generally created within the app they are being built with, but do not have to be.  In this case we are adding the extension to an existing Cement project:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ boss create ./myapp -t boss:cement-ext</div></pre></td></tr></table></figure>\n<p>At this point you would enable the extension in your app to utilize it.</p>\n","excerpt":"","more":"<p><a href=\"https://boss.readthedocs.io\">The Boss Project</a> provides ‘Baseline Open Source Software’ templates and development tools. It has similarities to PasteScript with regards to templating, but far easier to extend.  The official template repository includes a number of templates specifically for Cement, and are the recommended means of start Cement based projects.</p>\n<p>This is just a quick overview of creating Cement Apps, Plugins, and Extensions with Boss.</p>\n<h2 id=\"Creating-a-Cement-App\"><a href=\"#Creating-a-Cement-App\" class=\"headerlink\" title=\"Creating a Cement App\"></a>Creating a Cement App</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ boss create ./myapp -t boss:cement-app</div><div class=\"line\"></div><div class=\"line\">$ cd myapp</div><div class=\"line\"></div><div class=\"line\">$ virtualenv /path/to/myapp/env</div><div class=\"line\"></div><div class=\"line\">$ source /path/to/myapp/env/bin/activate</div><div class=\"line\"></div><div class=\"line\">$ pip install -r requirements.txt</div><div class=\"line\"></div><div class=\"line\">$ python setup.py develop</div><div class=\"line\"></div><div class=\"line\">$ myapp --help</div><div class=\"line\"></div><div class=\"line\">$ pip install nose coverage</div><div class=\"line\"></div><div class=\"line\">$ python setup.py nosetests</div></pre></td></tr></table></figure>\n<h2 id=\"Creating-a-Cement-Plugin\"><a href=\"#Creating-a-Cement-Plugin\" class=\"headerlink\" title=\"Creating a Cement Plugin\"></a>Creating a Cement Plugin</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ source /path/to/myapp/env/bin/activate</div><div class=\"line\"></div><div class=\"line\">$ cd /path/to/myapp</div><div class=\"line\"></div><div class=\"line\">$ mkdir plugins</div><div class=\"line\"></div><div class=\"line\">$ boss create ./plugins/myplugin -t boss:cement-plugin</div></pre></td></tr></table></figure>\n<p>Add the following to <code>~/myapp.conf</code> (or whereever your config file is):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">plugin_config_dir = /path/to/myapp/config/plugins.d</div><div class=\"line\">plugin_dir = /path/to/myapp/plugins</div><div class=\"line\"></div><div class=\"line\"># Enable the plugin here, or in a plugins.d/myplugin.conf</div><div class=\"line\">[myplugin]</div><div class=\"line\">enable_plugin = 1</div></pre></td></tr></table></figure>\n<p>And it should be enabled when you run your app (though it doesn’t do anything out of the box).</p>\n<h2 id=\"Creating-a-Cement-Extension\"><a href=\"#Creating-a-Cement-Extension\" class=\"headerlink\" title=\"Creating a Cement Extension\"></a>Creating a Cement Extension</h2><p>3rd party extensions are generally created within the app they are being built with, but do not have to be.  In this case we are adding the extension to an existing Cement project:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ boss create ./myapp -t boss:cement-ext</div></pre></td></tr></table></figure>\n<p>At this point you would enable the extension in your app to utilize it.</p>\n"},{"title":"Contributing","type":"guide","version":"2.10","order":21,"_content":"\nCement is an open-source project, and is open to any and all contributions that other developers would like to provide.  This document provides some guidelines that all contributors must be aware of, and abide by to have their submissions included in the source.\n\n## Licensing\n\nThe Cement source code is licensed under the BSD three-clause license and is approved by the [Open Source Initiative](http://www.opensource.org).  All contributed source code must be either the original work of the contributing author, which will be contributed under the BSD license, or work taken from another project that is released under a BSD-compatible license.\n\n## Submitting Bug Reports and Feature Requests\n\nIf you've found a bug, or would like to request a feature please create a detailed issue for it at [github.com/datafolklabs/cement](http://github.com/datafolklabs/cement/issues).\n\n**The ideal bug report would include:**\n\n- Bug description\n- Include the version of Python, Cement, and any dependencies in use\n- Steps to reproduce the bug\n- Code samples that show the bug in action\n- A pull request including code that:\n    a. Fixes the bug\n    b. Atleast one test case that tests for the bug specifically\n\n\n**The ideal feature request would include:**\n\n- Feature description\n- Example code, or pseudo code of how you might use the feature\n- Example command line session showing how the feature would be used by the end-user\n- A pull request including:\n    a. The feature you would like added\n    b. At least one test case that tests the feature and maintains 100% code coverage when tests are run (meaning that your tests should cover 100% of your contributed code)\n    c. Documentation that outlines how to use the feature\n\n\n## Guidelines for Code Contributions\n\nIf you are new to Cement, looking for something quick to fix, or just want an opportunity to contribute to the project... the best place to start is to review the issues labeled as `low-hanging-fruit` on [Github](https://github.com/datafolklabs/cement/labels/low-hanging-fruit).\n\nAll contributors should attempt to abide by the following:\n\n- Contributors fork the project on GitHub onto their own account\n- All changes should be commited, and pushed to their repository\n- All pull requests are from a topic branch, not an existing Cement branch\n- Contributors make every effort to comply with [PEP8](http://www.python.org/dev/peps/pep-0008/)\n- Before starting on a new feature, or bug fix, always do the following:\n    - `git pull --rebase` to get latest changes from upstream\n    - Checkout a new branch.  For example:\n        - `git checkout -b feature/<feature_name>`\n        - `git checkout -b bug/<bug_number>`\n- Code must include the following:\n    - All tests pass successfully\n    - Coverage reports 100% code coverage when running tests\n    - New features are documented in the appropriate section of the doc\n    - Significant changes are mentioned in the ChangeLog\n- All contributions must be associated with at least one issue in GitHub. If the issue does not exist, create one (per the guidelines above).\n- Commit comments must include something like the following:\n    - `Resolves Issue #1127`\n    - `Partially Resolves Issue #9873`\n- A single commit per issue.\n- Contributors should add their full name, or handle, to the CONTRIBUTORS file.\n\nRegarding git commit messages, please read the following:\n\n- [Commit Guidelines](http://git-scm.com/book/en/Distributed-Git-Contributing-to-a-Project#Commit-Guidelines)\n\nThe majority of commits only require a single line commit message. That said, for more complex commits, please use the following as an example (as outlined in the ProGit link above):\n\n```\nShort (50 chars or less) summary of changes\n\nMore detailed explanatory text, if necessary.  Wrap it to about 72\ncharacters or so.  In some contexts, the first line is treated as the\nsubject of an email and the rest of the text as the body.  The blank\nline separating the summary from the body is critical (unless you omit\nthe body entirely); tools like rebase can get confused if you run the\ntwo together.\n\nFurther paragraphs come after blank lines.\n\n - Bullet points are okay, too\n\n - Typically a hyphen or asterisk is used for the bullet, preceded by a\n   single space, with blank lines in between, but conventions vary here\n```\n\n\n## Source Code and Versioning\n\nOne of the primary goals of Cement is stability in the source code.  For this reason we maintain a number of different git branches for focused development.\n\n**Development Branches**\n\nActive 'forward' development happens out of two branches:\n\n- `master` - Development for the next minor stable release.\n- `portland` - Development for the next major release.\n\n\nAdditionally, specific development branches might exist in the future for larger releases that may require iterative 'release candidate' handling before an official stable release.  These branches will have the format of:\n\n- `dev/3.1.x`\n- `dev/3.3.x`\n- `dev/4.1.x`\n- `dev/4.3.x`\n- `etc`\n\n**Stable Branches**\n\n- `stable/0.8.x`\n- `stable/1.0.x`\n- `stable/1.2.x`\n- `stable/2.0.x`\n- `stable/2.2.x`\n- `stable/3.0.x`\n- `stable/3.2.x`\n- `etc`\n\nThere is a system for versioning that may seem complex, and needs some explanation.  Version numbers are broken up into three parts:\n\n- `<Major>.<Minor>.<Bugfix>`\n\nThis means:\n\n- **Major** - The major version of the source code generally relates to extensive incompatible changes, or entire code base rewrites. Applications built on the `1.x.x` version of Cement will need to be completely rewritten for the `2.x.x` versions of Cement.\n- **Minor** - The minor version signifies the addition of new features.  It may also indicate minor incompatibilities with the previous stable version, but should be easily resolvable with minimal coding effort.\n- **Bugfix** - During the lifecycle of a stable release such as `2.2.x`, the only updates should be bug and/or security related.  At times, minor features may be introduced during a 'bugfix' release but that should not happen often.\n\nIt should be noted that both the Minor, and Bugfix versions follow a `even == stable`, and `odd == development` scheme.  Therefore, the current version in git will always end in an 'odd number'.  For example, if the current stable version is `2.0.18`, then the version in `stable/2.0.x` would be `2.0.19`.  That said, the `master` branch might then be `2.1.1` which is the first version of the next minor release. Bugfixes would get applied to both branches, however feature updates would only be applied to `master`. The next stable release would then be `2.2.0` and a new git branch of `stable/2.2.x` will be created.\n\nThe `portland` branch is always very forward looking, and will contain significant (and likely broken) code changes.  It should never be used for anything other than development and testing.\n","source":"2.10/dev/contributing.md","raw":"---\ntitle: Contributing\ntype: guide\nversion: \"2.10\"\norder: 21\n---\n\nCement is an open-source project, and is open to any and all contributions that other developers would like to provide.  This document provides some guidelines that all contributors must be aware of, and abide by to have their submissions included in the source.\n\n## Licensing\n\nThe Cement source code is licensed under the BSD three-clause license and is approved by the [Open Source Initiative](http://www.opensource.org).  All contributed source code must be either the original work of the contributing author, which will be contributed under the BSD license, or work taken from another project that is released under a BSD-compatible license.\n\n## Submitting Bug Reports and Feature Requests\n\nIf you've found a bug, or would like to request a feature please create a detailed issue for it at [github.com/datafolklabs/cement](http://github.com/datafolklabs/cement/issues).\n\n**The ideal bug report would include:**\n\n- Bug description\n- Include the version of Python, Cement, and any dependencies in use\n- Steps to reproduce the bug\n- Code samples that show the bug in action\n- A pull request including code that:\n    a. Fixes the bug\n    b. Atleast one test case that tests for the bug specifically\n\n\n**The ideal feature request would include:**\n\n- Feature description\n- Example code, or pseudo code of how you might use the feature\n- Example command line session showing how the feature would be used by the end-user\n- A pull request including:\n    a. The feature you would like added\n    b. At least one test case that tests the feature and maintains 100% code coverage when tests are run (meaning that your tests should cover 100% of your contributed code)\n    c. Documentation that outlines how to use the feature\n\n\n## Guidelines for Code Contributions\n\nIf you are new to Cement, looking for something quick to fix, or just want an opportunity to contribute to the project... the best place to start is to review the issues labeled as `low-hanging-fruit` on [Github](https://github.com/datafolklabs/cement/labels/low-hanging-fruit).\n\nAll contributors should attempt to abide by the following:\n\n- Contributors fork the project on GitHub onto their own account\n- All changes should be commited, and pushed to their repository\n- All pull requests are from a topic branch, not an existing Cement branch\n- Contributors make every effort to comply with [PEP8](http://www.python.org/dev/peps/pep-0008/)\n- Before starting on a new feature, or bug fix, always do the following:\n    - `git pull --rebase` to get latest changes from upstream\n    - Checkout a new branch.  For example:\n        - `git checkout -b feature/<feature_name>`\n        - `git checkout -b bug/<bug_number>`\n- Code must include the following:\n    - All tests pass successfully\n    - Coverage reports 100% code coverage when running tests\n    - New features are documented in the appropriate section of the doc\n    - Significant changes are mentioned in the ChangeLog\n- All contributions must be associated with at least one issue in GitHub. If the issue does not exist, create one (per the guidelines above).\n- Commit comments must include something like the following:\n    - `Resolves Issue #1127`\n    - `Partially Resolves Issue #9873`\n- A single commit per issue.\n- Contributors should add their full name, or handle, to the CONTRIBUTORS file.\n\nRegarding git commit messages, please read the following:\n\n- [Commit Guidelines](http://git-scm.com/book/en/Distributed-Git-Contributing-to-a-Project#Commit-Guidelines)\n\nThe majority of commits only require a single line commit message. That said, for more complex commits, please use the following as an example (as outlined in the ProGit link above):\n\n```\nShort (50 chars or less) summary of changes\n\nMore detailed explanatory text, if necessary.  Wrap it to about 72\ncharacters or so.  In some contexts, the first line is treated as the\nsubject of an email and the rest of the text as the body.  The blank\nline separating the summary from the body is critical (unless you omit\nthe body entirely); tools like rebase can get confused if you run the\ntwo together.\n\nFurther paragraphs come after blank lines.\n\n - Bullet points are okay, too\n\n - Typically a hyphen or asterisk is used for the bullet, preceded by a\n   single space, with blank lines in between, but conventions vary here\n```\n\n\n## Source Code and Versioning\n\nOne of the primary goals of Cement is stability in the source code.  For this reason we maintain a number of different git branches for focused development.\n\n**Development Branches**\n\nActive 'forward' development happens out of two branches:\n\n- `master` - Development for the next minor stable release.\n- `portland` - Development for the next major release.\n\n\nAdditionally, specific development branches might exist in the future for larger releases that may require iterative 'release candidate' handling before an official stable release.  These branches will have the format of:\n\n- `dev/3.1.x`\n- `dev/3.3.x`\n- `dev/4.1.x`\n- `dev/4.3.x`\n- `etc`\n\n**Stable Branches**\n\n- `stable/0.8.x`\n- `stable/1.0.x`\n- `stable/1.2.x`\n- `stable/2.0.x`\n- `stable/2.2.x`\n- `stable/3.0.x`\n- `stable/3.2.x`\n- `etc`\n\nThere is a system for versioning that may seem complex, and needs some explanation.  Version numbers are broken up into three parts:\n\n- `<Major>.<Minor>.<Bugfix>`\n\nThis means:\n\n- **Major** - The major version of the source code generally relates to extensive incompatible changes, or entire code base rewrites. Applications built on the `1.x.x` version of Cement will need to be completely rewritten for the `2.x.x` versions of Cement.\n- **Minor** - The minor version signifies the addition of new features.  It may also indicate minor incompatibilities with the previous stable version, but should be easily resolvable with minimal coding effort.\n- **Bugfix** - During the lifecycle of a stable release such as `2.2.x`, the only updates should be bug and/or security related.  At times, minor features may be introduced during a 'bugfix' release but that should not happen often.\n\nIt should be noted that both the Minor, and Bugfix versions follow a `even == stable`, and `odd == development` scheme.  Therefore, the current version in git will always end in an 'odd number'.  For example, if the current stable version is `2.0.18`, then the version in `stable/2.0.x` would be `2.0.19`.  That said, the `master` branch might then be `2.1.1` which is the first version of the next minor release. Bugfixes would get applied to both branches, however feature updates would only be applied to `master`. The next stable release would then be `2.2.0` and a new git branch of `stable/2.2.x` will be created.\n\nThe `portland` branch is always very forward looking, and will contain significant (and likely broken) code changes.  It should never be used for anything other than development and testing.\n","date":"2018-01-17T03:05:56.474Z","updated":"2018-01-17T03:05:56.474Z","path":"2.10/dev/contributing.html","_id":"cj64mvgr7000cwtpw8fv44kyo","comments":1,"layout":"page","content":"<p>Cement is an open-source project, and is open to any and all contributions that other developers would like to provide.  This document provides some guidelines that all contributors must be aware of, and abide by to have their submissions included in the source.</p>\n<h2 id=\"Licensing\"><a href=\"#Licensing\" class=\"headerlink\" title=\"Licensing\"></a>Licensing</h2><p>The Cement source code is licensed under the BSD three-clause license and is approved by the <a href=\"http://www.opensource.org\" target=\"_blank\" rel=\"external\">Open Source Initiative</a>.  All contributed source code must be either the original work of the contributing author, which will be contributed under the BSD license, or work taken from another project that is released under a BSD-compatible license.</p>\n<h2 id=\"Submitting-Bug-Reports-and-Feature-Requests\"><a href=\"#Submitting-Bug-Reports-and-Feature-Requests\" class=\"headerlink\" title=\"Submitting Bug Reports and Feature Requests\"></a>Submitting Bug Reports and Feature Requests</h2><p>If you’ve found a bug, or would like to request a feature please create a detailed issue for it at <a href=\"http://github.com/datafolklabs/cement/issues\" target=\"_blank\" rel=\"external\">github.com/datafolklabs/cement</a>.</p>\n<p><strong>The ideal bug report would include:</strong></p>\n<ul>\n<li>Bug description</li>\n<li>Include the version of Python, Cement, and any dependencies in use</li>\n<li>Steps to reproduce the bug</li>\n<li>Code samples that show the bug in action</li>\n<li>A pull request including code that:<br>  a. Fixes the bug<br>  b. Atleast one test case that tests for the bug specifically</li>\n</ul>\n<p><strong>The ideal feature request would include:</strong></p>\n<ul>\n<li>Feature description</li>\n<li>Example code, or pseudo code of how you might use the feature</li>\n<li>Example command line session showing how the feature would be used by the end-user</li>\n<li>A pull request including:<br>  a. The feature you would like added<br>  b. At least one test case that tests the feature and maintains 100% code coverage when tests are run (meaning that your tests should cover 100% of your contributed code)<br>  c. Documentation that outlines how to use the feature</li>\n</ul>\n<h2 id=\"Guidelines-for-Code-Contributions\"><a href=\"#Guidelines-for-Code-Contributions\" class=\"headerlink\" title=\"Guidelines for Code Contributions\"></a>Guidelines for Code Contributions</h2><p>If you are new to Cement, looking for something quick to fix, or just want an opportunity to contribute to the project… the best place to start is to review the issues labeled as <code>low-hanging-fruit</code> on <a href=\"https://github.com/datafolklabs/cement/labels/low-hanging-fruit\" target=\"_blank\" rel=\"external\">Github</a>.</p>\n<p>All contributors should attempt to abide by the following:</p>\n<ul>\n<li>Contributors fork the project on GitHub onto their own account</li>\n<li>All changes should be commited, and pushed to their repository</li>\n<li>All pull requests are from a topic branch, not an existing Cement branch</li>\n<li>Contributors make every effort to comply with <a href=\"http://www.python.org/dev/peps/pep-0008/\" target=\"_blank\" rel=\"external\">PEP8</a></li>\n<li>Before starting on a new feature, or bug fix, always do the following:<ul>\n<li><code>git pull --rebase</code> to get latest changes from upstream</li>\n<li>Checkout a new branch.  For example:<ul>\n<li><code>git checkout -b feature/&lt;feature_name&gt;</code></li>\n<li><code>git checkout -b bug/&lt;bug_number&gt;</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Code must include the following:<ul>\n<li>All tests pass successfully</li>\n<li>Coverage reports 100% code coverage when running tests</li>\n<li>New features are documented in the appropriate section of the doc</li>\n<li>Significant changes are mentioned in the ChangeLog</li>\n</ul>\n</li>\n<li>All contributions must be associated with at least one issue in GitHub. If the issue does not exist, create one (per the guidelines above).</li>\n<li>Commit comments must include something like the following:<ul>\n<li><code>Resolves Issue #1127</code></li>\n<li><code>Partially Resolves Issue #9873</code></li>\n</ul>\n</li>\n<li>A single commit per issue.</li>\n<li>Contributors should add their full name, or handle, to the CONTRIBUTORS file.</li>\n</ul>\n<p>Regarding git commit messages, please read the following:</p>\n<ul>\n<li><a href=\"http://git-scm.com/book/en/Distributed-Git-Contributing-to-a-Project#Commit-Guidelines\" target=\"_blank\" rel=\"external\">Commit Guidelines</a></li>\n</ul>\n<p>The majority of commits only require a single line commit message. That said, for more complex commits, please use the following as an example (as outlined in the ProGit link above):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Short (50 chars or less) summary of changes</div><div class=\"line\"></div><div class=\"line\">More detailed explanatory text, if necessary.  Wrap it to about 72</div><div class=\"line\">characters or so.  In some contexts, the first line is treated as the</div><div class=\"line\">subject of an email and the rest of the text as the body.  The blank</div><div class=\"line\">line separating the summary from the body is critical (unless you omit</div><div class=\"line\">the body entirely); tools like rebase can get confused if you run the</div><div class=\"line\">two together.</div><div class=\"line\"></div><div class=\"line\">Further paragraphs come after blank lines.</div><div class=\"line\"></div><div class=\"line\"> - Bullet points are okay, too</div><div class=\"line\"></div><div class=\"line\"> - Typically a hyphen or asterisk is used for the bullet, preceded by a</div><div class=\"line\">   single space, with blank lines in between, but conventions vary here</div></pre></td></tr></table></figure>\n<h2 id=\"Source-Code-and-Versioning\"><a href=\"#Source-Code-and-Versioning\" class=\"headerlink\" title=\"Source Code and Versioning\"></a>Source Code and Versioning</h2><p>One of the primary goals of Cement is stability in the source code.  For this reason we maintain a number of different git branches for focused development.</p>\n<p><strong>Development Branches</strong></p>\n<p>Active ‘forward’ development happens out of two branches:</p>\n<ul>\n<li><code>master</code> - Development for the next minor stable release.</li>\n<li><code>portland</code> - Development for the next major release.</li>\n</ul>\n<p>Additionally, specific development branches might exist in the future for larger releases that may require iterative ‘release candidate’ handling before an official stable release.  These branches will have the format of:</p>\n<ul>\n<li><code>dev/3.1.x</code></li>\n<li><code>dev/3.3.x</code></li>\n<li><code>dev/4.1.x</code></li>\n<li><code>dev/4.3.x</code></li>\n<li><code>etc</code></li>\n</ul>\n<p><strong>Stable Branches</strong></p>\n<ul>\n<li><code>stable/0.8.x</code></li>\n<li><code>stable/1.0.x</code></li>\n<li><code>stable/1.2.x</code></li>\n<li><code>stable/2.0.x</code></li>\n<li><code>stable/2.2.x</code></li>\n<li><code>stable/3.0.x</code></li>\n<li><code>stable/3.2.x</code></li>\n<li><code>etc</code></li>\n</ul>\n<p>There is a system for versioning that may seem complex, and needs some explanation.  Version numbers are broken up into three parts:</p>\n<ul>\n<li><code>&lt;Major&gt;.&lt;Minor&gt;.&lt;Bugfix&gt;</code></li>\n</ul>\n<p>This means:</p>\n<ul>\n<li><strong>Major</strong> - The major version of the source code generally relates to extensive incompatible changes, or entire code base rewrites. Applications built on the <code>1.x.x</code> version of Cement will need to be completely rewritten for the <code>2.x.x</code> versions of Cement.</li>\n<li><strong>Minor</strong> - The minor version signifies the addition of new features.  It may also indicate minor incompatibilities with the previous stable version, but should be easily resolvable with minimal coding effort.</li>\n<li><strong>Bugfix</strong> - During the lifecycle of a stable release such as <code>2.2.x</code>, the only updates should be bug and/or security related.  At times, minor features may be introduced during a ‘bugfix’ release but that should not happen often.</li>\n</ul>\n<p>It should be noted that both the Minor, and Bugfix versions follow a <code>even == stable</code>, and <code>odd == development</code> scheme.  Therefore, the current version in git will always end in an ‘odd number’.  For example, if the current stable version is <code>2.0.18</code>, then the version in <code>stable/2.0.x</code> would be <code>2.0.19</code>.  That said, the <code>master</code> branch might then be <code>2.1.1</code> which is the first version of the next minor release. Bugfixes would get applied to both branches, however feature updates would only be applied to <code>master</code>. The next stable release would then be <code>2.2.0</code> and a new git branch of <code>stable/2.2.x</code> will be created.</p>\n<p>The <code>portland</code> branch is always very forward looking, and will contain significant (and likely broken) code changes.  It should never be used for anything other than development and testing.</p>\n","excerpt":"","more":"<p>Cement is an open-source project, and is open to any and all contributions that other developers would like to provide.  This document provides some guidelines that all contributors must be aware of, and abide by to have their submissions included in the source.</p>\n<h2 id=\"Licensing\"><a href=\"#Licensing\" class=\"headerlink\" title=\"Licensing\"></a>Licensing</h2><p>The Cement source code is licensed under the BSD three-clause license and is approved by the <a href=\"http://www.opensource.org\">Open Source Initiative</a>.  All contributed source code must be either the original work of the contributing author, which will be contributed under the BSD license, or work taken from another project that is released under a BSD-compatible license.</p>\n<h2 id=\"Submitting-Bug-Reports-and-Feature-Requests\"><a href=\"#Submitting-Bug-Reports-and-Feature-Requests\" class=\"headerlink\" title=\"Submitting Bug Reports and Feature Requests\"></a>Submitting Bug Reports and Feature Requests</h2><p>If you’ve found a bug, or would like to request a feature please create a detailed issue for it at <a href=\"http://github.com/datafolklabs/cement/issues\">github.com/datafolklabs/cement</a>.</p>\n<p><strong>The ideal bug report would include:</strong></p>\n<ul>\n<li>Bug description</li>\n<li>Include the version of Python, Cement, and any dependencies in use</li>\n<li>Steps to reproduce the bug</li>\n<li>Code samples that show the bug in action</li>\n<li>A pull request including code that:<br>  a. Fixes the bug<br>  b. Atleast one test case that tests for the bug specifically</li>\n</ul>\n<p><strong>The ideal feature request would include:</strong></p>\n<ul>\n<li>Feature description</li>\n<li>Example code, or pseudo code of how you might use the feature</li>\n<li>Example command line session showing how the feature would be used by the end-user</li>\n<li>A pull request including:<br>  a. The feature you would like added<br>  b. At least one test case that tests the feature and maintains 100% code coverage when tests are run (meaning that your tests should cover 100% of your contributed code)<br>  c. Documentation that outlines how to use the feature</li>\n</ul>\n<h2 id=\"Guidelines-for-Code-Contributions\"><a href=\"#Guidelines-for-Code-Contributions\" class=\"headerlink\" title=\"Guidelines for Code Contributions\"></a>Guidelines for Code Contributions</h2><p>If you are new to Cement, looking for something quick to fix, or just want an opportunity to contribute to the project… the best place to start is to review the issues labeled as <code>low-hanging-fruit</code> on <a href=\"https://github.com/datafolklabs/cement/labels/low-hanging-fruit\">Github</a>.</p>\n<p>All contributors should attempt to abide by the following:</p>\n<ul>\n<li>Contributors fork the project on GitHub onto their own account</li>\n<li>All changes should be commited, and pushed to their repository</li>\n<li>All pull requests are from a topic branch, not an existing Cement branch</li>\n<li>Contributors make every effort to comply with <a href=\"http://www.python.org/dev/peps/pep-0008/\">PEP8</a></li>\n<li>Before starting on a new feature, or bug fix, always do the following:<ul>\n<li><code>git pull --rebase</code> to get latest changes from upstream</li>\n<li>Checkout a new branch.  For example:<ul>\n<li><code>git checkout -b feature/&lt;feature_name&gt;</code></li>\n<li><code>git checkout -b bug/&lt;bug_number&gt;</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Code must include the following:<ul>\n<li>All tests pass successfully</li>\n<li>Coverage reports 100% code coverage when running tests</li>\n<li>New features are documented in the appropriate section of the doc</li>\n<li>Significant changes are mentioned in the ChangeLog</li>\n</ul>\n</li>\n<li>All contributions must be associated with at least one issue in GitHub. If the issue does not exist, create one (per the guidelines above).</li>\n<li>Commit comments must include something like the following:<ul>\n<li><code>Resolves Issue #1127</code></li>\n<li><code>Partially Resolves Issue #9873</code></li>\n</ul>\n</li>\n<li>A single commit per issue.</li>\n<li>Contributors should add their full name, or handle, to the CONTRIBUTORS file.</li>\n</ul>\n<p>Regarding git commit messages, please read the following:</p>\n<ul>\n<li><a href=\"http://git-scm.com/book/en/Distributed-Git-Contributing-to-a-Project#Commit-Guidelines\">Commit Guidelines</a></li>\n</ul>\n<p>The majority of commits only require a single line commit message. That said, for more complex commits, please use the following as an example (as outlined in the ProGit link above):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Short (50 chars or less) summary of changes</div><div class=\"line\"></div><div class=\"line\">More detailed explanatory text, if necessary.  Wrap it to about 72</div><div class=\"line\">characters or so.  In some contexts, the first line is treated as the</div><div class=\"line\">subject of an email and the rest of the text as the body.  The blank</div><div class=\"line\">line separating the summary from the body is critical (unless you omit</div><div class=\"line\">the body entirely); tools like rebase can get confused if you run the</div><div class=\"line\">two together.</div><div class=\"line\"></div><div class=\"line\">Further paragraphs come after blank lines.</div><div class=\"line\"></div><div class=\"line\"> - Bullet points are okay, too</div><div class=\"line\"></div><div class=\"line\"> - Typically a hyphen or asterisk is used for the bullet, preceded by a</div><div class=\"line\">   single space, with blank lines in between, but conventions vary here</div></pre></td></tr></table></figure>\n<h2 id=\"Source-Code-and-Versioning\"><a href=\"#Source-Code-and-Versioning\" class=\"headerlink\" title=\"Source Code and Versioning\"></a>Source Code and Versioning</h2><p>One of the primary goals of Cement is stability in the source code.  For this reason we maintain a number of different git branches for focused development.</p>\n<p><strong>Development Branches</strong></p>\n<p>Active ‘forward’ development happens out of two branches:</p>\n<ul>\n<li><code>master</code> - Development for the next minor stable release.</li>\n<li><code>portland</code> - Development for the next major release.</li>\n</ul>\n<p>Additionally, specific development branches might exist in the future for larger releases that may require iterative ‘release candidate’ handling before an official stable release.  These branches will have the format of:</p>\n<ul>\n<li><code>dev/3.1.x</code></li>\n<li><code>dev/3.3.x</code></li>\n<li><code>dev/4.1.x</code></li>\n<li><code>dev/4.3.x</code></li>\n<li><code>etc</code></li>\n</ul>\n<p><strong>Stable Branches</strong></p>\n<ul>\n<li><code>stable/0.8.x</code></li>\n<li><code>stable/1.0.x</code></li>\n<li><code>stable/1.2.x</code></li>\n<li><code>stable/2.0.x</code></li>\n<li><code>stable/2.2.x</code></li>\n<li><code>stable/3.0.x</code></li>\n<li><code>stable/3.2.x</code></li>\n<li><code>etc</code></li>\n</ul>\n<p>There is a system for versioning that may seem complex, and needs some explanation.  Version numbers are broken up into three parts:</p>\n<ul>\n<li><code>&lt;Major&gt;.&lt;Minor&gt;.&lt;Bugfix&gt;</code></li>\n</ul>\n<p>This means:</p>\n<ul>\n<li><strong>Major</strong> - The major version of the source code generally relates to extensive incompatible changes, or entire code base rewrites. Applications built on the <code>1.x.x</code> version of Cement will need to be completely rewritten for the <code>2.x.x</code> versions of Cement.</li>\n<li><strong>Minor</strong> - The minor version signifies the addition of new features.  It may also indicate minor incompatibilities with the previous stable version, but should be easily resolvable with minimal coding effort.</li>\n<li><strong>Bugfix</strong> - During the lifecycle of a stable release such as <code>2.2.x</code>, the only updates should be bug and/or security related.  At times, minor features may be introduced during a ‘bugfix’ release but that should not happen often.</li>\n</ul>\n<p>It should be noted that both the Minor, and Bugfix versions follow a <code>even == stable</code>, and <code>odd == development</code> scheme.  Therefore, the current version in git will always end in an ‘odd number’.  For example, if the current stable version is <code>2.0.18</code>, then the version in <code>stable/2.0.x</code> would be <code>2.0.19</code>.  That said, the <code>master</code> branch might then be <code>2.1.1</code> which is the first version of the next minor release. Bugfixes would get applied to both branches, however feature updates would only be applied to <code>master</code>. The next stable release would then be <code>2.2.0</code> and a new git branch of <code>stable/2.2.x</code> will be created.</p>\n<p>The <code>portland</code> branch is always very forward looking, and will contain significant (and likely broken) code changes.  It should never be used for anything other than development and testing.</p>\n"},{"title":"App Version Option","type":"examples","version":"2.10","order":3,"_content":"\nAlmost every app out there supports a `--version` option of some sort that provides the end user with version information. This is pretty important to include, so we’ve added an example below.\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController\n\nVERSION = '0.9.1'\n\nBANNER = \"\"\"\nMy Awesome Application v%s\nCopyright (c) 2014 John Doe Enterprises\n\"\"\" % VERSION\n\nclass MyBaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n        description = 'MyApp Does Amazing Things'\n        arguments = [\n            (['-v', '--version'], dict(action='version', version=BANNER)),\n            ]\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        base_controller = MyBaseController\n\n\nwith MyApp() as app:\n    app.run()\n```\n\n\nThis looks like:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nMyApp Does Amazing Things\n\noptional arguments:\n  -h, --help     show this help message and exit\n  --debug        toggle debug output\n  --quiet        suppress all output\n  -v, --version  show program's version number and exit\n\n$ python myapp.py --version\nMy Awesome Application v0.9.1\nCopyright (c) 2014 John Doe Enterprises\n```\n","source":"2.10/examples/app_version.md","raw":"---\ntitle: App Version Option\ntype: examples\nversion: \"2.10\"\norder: 3\n---\n\nAlmost every app out there supports a `--version` option of some sort that provides the end user with version information. This is pretty important to include, so we’ve added an example below.\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController\n\nVERSION = '0.9.1'\n\nBANNER = \"\"\"\nMy Awesome Application v%s\nCopyright (c) 2014 John Doe Enterprises\n\"\"\" % VERSION\n\nclass MyBaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n        description = 'MyApp Does Amazing Things'\n        arguments = [\n            (['-v', '--version'], dict(action='version', version=BANNER)),\n            ]\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        base_controller = MyBaseController\n\n\nwith MyApp() as app:\n    app.run()\n```\n\n\nThis looks like:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nMyApp Does Amazing Things\n\noptional arguments:\n  -h, --help     show this help message and exit\n  --debug        toggle debug output\n  --quiet        suppress all output\n  -v, --version  show program's version number and exit\n\n$ python myapp.py --version\nMy Awesome Application v0.9.1\nCopyright (c) 2014 John Doe Enterprises\n```\n","date":"2017-10-30T02:07:32.000Z","updated":"2017-10-30T02:07:32.000Z","path":"2.10/examples/app_version.html","_id":"cj9djjgh90000iapw2vnuvg2p","comments":1,"layout":"page","content":"<p>Almost every app out there supports a <code>--version</code> option of some sort that provides the end user with version information. This is pretty important to include, so we’ve added an example below.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController</div><div class=\"line\"></div><div class=\"line\">VERSION = <span class=\"string\">'0.9.1'</span></div><div class=\"line\"></div><div class=\"line\">BANNER = <span class=\"string\">\"\"\"</span></div><div class=\"line\">My Awesome Application v%s</div><div class=\"line\">Copyright (c) 2014 John Doe Enterprises</div><div class=\"line\">\"\"\" % VERSION</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\">        description = <span class=\"string\">'MyApp Does Amazing Things'</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'-v'</span>, <span class=\"string\">'--version'</span>], dict(action=<span class=\"string\">'version'</span>, version=BANNER)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        base_controller = MyBaseController</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>This looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">MyApp Does Amazing Things</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help     show this help message and exit</div><div class=\"line\">  --debug        toggle debug output</div><div class=\"line\">  --quiet        suppress all output</div><div class=\"line\">  -v, --version  show program&apos;s version number and exit</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py --version</div><div class=\"line\">My Awesome Application v0.9.1</div><div class=\"line\">Copyright (c) 2014 John Doe Enterprises</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>Almost every app out there supports a <code>--version</code> option of some sort that provides the end user with version information. This is pretty important to include, so we’ve added an example below.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController</div><div class=\"line\"></div><div class=\"line\">VERSION = <span class=\"string\">'0.9.1'</span></div><div class=\"line\"></div><div class=\"line\">BANNER = <span class=\"string\">\"\"\"</div><div class=\"line\">My Awesome Application v%s</div><div class=\"line\">Copyright (c) 2014 John Doe Enterprises</div><div class=\"line\">\"\"\"</span> % VERSION</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\">        description = <span class=\"string\">'MyApp Does Amazing Things'</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'-v'</span>, <span class=\"string\">'--version'</span>], dict(action=<span class=\"string\">'version'</span>, version=BANNER)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        base_controller = MyBaseController</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>This looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">MyApp Does Amazing Things</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help     show this help message and exit</div><div class=\"line\">  --debug        toggle debug output</div><div class=\"line\">  --quiet        suppress all output</div><div class=\"line\">  -v, --version  show program&apos;s version number and exit</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py --version</div><div class=\"line\">My Awesome Application v0.9.1</div><div class=\"line\">Copyright (c) 2014 John Doe Enterprises</div></pre></td></tr></table></figure>\n"},{"title":"Multiple Stacked Controllers","type":"examples","version":"2.10","order":4,"_content":"\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\n# define application controllers\nclass MyAppBaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n        description = \"my application does amazing things\"\n        arguments = [\n            (['--base-opt'], dict(help=\"option under base controller\")),\n            ]\n\n    @expose(help=\"base controller default command\", hide=True)\n    def default(self):\n        print \"Inside MyAppBaseController.default()\"\n\n    @expose(help=\"another base controller command\")\n    def command1(self):\n        print \"Inside MyAppBaseController.command1()\"\n\nclass SecondController(CementBaseController):\n    class Meta:\n        label = 'second_controller'\n        stacked_on = 'base'\n        stacked_type = 'nested'\n        description = \"this is the second controller (stacked/nested on base)\"\n        arguments = [\n            (['--2nd-opt'], dict(help=\"another option under base controller\")),\n            ]\n\n    @expose(help=\"second-controller default command\", hide=True)\n    def default(self):\n        print \"Inside SecondController.default()\"\n\n    @expose(help=\"this is a command under the second-controller namespace\")\n    def command2(self):\n        print \"Inside SecondController.command2()\"\n\nclass ThirdController(CementBaseController):\n    class Meta:\n        label = 'third_controller'\n        stacked_on = 'second_controller'\n        stacked_type = 'embedded'\n        description = \"this controller is embedded in the second-controller\"\n        arguments = [\n            (['--3rd-opt'], dict(help=\"an option only under 3rd controller\")),\n            ]\n\n    @expose(help=\"another command under the second-controller namespace\")\n    def command3(self):\n        print \"Inside ThirdController.command3()\"\n\nclass FourthController(CementBaseController):\n    class Meta:\n        label = 'fourth_controller'\n        stacked_on = 'second_controller'\n        stacked_type = 'nested'\n        description = \"this controller is nested on the second-controller\"\n        arguments = [\n            (['--4th-opt'], dict(help=\"an option only under 3rd controller\")),\n            ]\n\n    @expose(help=\"a command only under the fourth-controller namespace\")\n    def command4(self):\n        print \"Inside FourthController.command4()\"\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        handlers = [\n            MyAppBaseController,\n            SecondController,\n            ThirdController,\n            FourthController,\n            ]\n\ndef main():\n    with MyApp() as app:\n        app.run()\n\n\nif __name__ == '__main__':\n    main()\n```\n\nIn the base controller output of `--help` notice that the `second-controller` is listed as a sub-command:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nmy application does amazing things\n\ncommands:\n\n  command1\n    another base controller command\n\n  second-controller\n    this is the second controller (stacked/nested on base)\n\noptional arguments:\n  -h, --help           show this help message and exit\n  --debug              toggle debug output\n  --quiet              suppress all output\n  --base-opt BASE_OPT  option under base controller\n\n\n$ python myapp.py\nInside MyAppBaseController.default()\n\n\n$ python myapp.py command1\nInside MyAppBaseController.command1()\n\n$ python myapp.py second-controller\nInside SecondController.default()\n\n$ python myapp.py second-controller --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nthis is the second controller (stacked/nested on base)\n\ncommands:\n\n  command2\n    this is a command under the second-controller namespace\n\n  command3\n    another command under the second-controller namespace\n\n  fourth-controller\n    this controller is nested on the second-controller\n\noptional arguments:\n  -h, --help         show this help message and exit\n  --debug            toggle debug output\n  --quiet            suppress all output\n  --2nd-opt 2ND_OPT  another option under base controller\n  --3rd-opt 3RD_OPT  an option only under 3rd controller\n```\n\nUnder the `second-controller` you can see the commands and options from the second and third controllers. In this example, the `second-controller` is nested on the `base` controller, and the `third-controller` is embedded on the second-controller. Finally, we see that the `fourth-controller` is also nested on the `second-controller` creating a sub-sub-command.\n\n```\n$ python myapp.py second-controller command3\nInside ThirdController.command3()\n\n\n$ python myapp.py second-controller fourth-controller --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nthis controller is nested on the second-controller\n\ncommands:\n\n  command4\n    a command only under the fourth-controller namespace\n\noptional arguments:\n  -h, --help         show this help message and exit\n  --debug            toggle debug output\n  --quiet            suppress all output\n  --4th-opt 4TH_OPT  an option only under 3rd controller\n\n\n$ python myapp.py second-controller fourth-controller command4\nInside FourthController.command4()\n```\n","source":"2.10/examples/multiple_stacked_controllers.md","raw":"---\ntitle: Multiple Stacked Controllers\ntype: examples\nversion: \"2.10\"\norder: 4\n---\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\n# define application controllers\nclass MyAppBaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n        description = \"my application does amazing things\"\n        arguments = [\n            (['--base-opt'], dict(help=\"option under base controller\")),\n            ]\n\n    @expose(help=\"base controller default command\", hide=True)\n    def default(self):\n        print \"Inside MyAppBaseController.default()\"\n\n    @expose(help=\"another base controller command\")\n    def command1(self):\n        print \"Inside MyAppBaseController.command1()\"\n\nclass SecondController(CementBaseController):\n    class Meta:\n        label = 'second_controller'\n        stacked_on = 'base'\n        stacked_type = 'nested'\n        description = \"this is the second controller (stacked/nested on base)\"\n        arguments = [\n            (['--2nd-opt'], dict(help=\"another option under base controller\")),\n            ]\n\n    @expose(help=\"second-controller default command\", hide=True)\n    def default(self):\n        print \"Inside SecondController.default()\"\n\n    @expose(help=\"this is a command under the second-controller namespace\")\n    def command2(self):\n        print \"Inside SecondController.command2()\"\n\nclass ThirdController(CementBaseController):\n    class Meta:\n        label = 'third_controller'\n        stacked_on = 'second_controller'\n        stacked_type = 'embedded'\n        description = \"this controller is embedded in the second-controller\"\n        arguments = [\n            (['--3rd-opt'], dict(help=\"an option only under 3rd controller\")),\n            ]\n\n    @expose(help=\"another command under the second-controller namespace\")\n    def command3(self):\n        print \"Inside ThirdController.command3()\"\n\nclass FourthController(CementBaseController):\n    class Meta:\n        label = 'fourth_controller'\n        stacked_on = 'second_controller'\n        stacked_type = 'nested'\n        description = \"this controller is nested on the second-controller\"\n        arguments = [\n            (['--4th-opt'], dict(help=\"an option only under 3rd controller\")),\n            ]\n\n    @expose(help=\"a command only under the fourth-controller namespace\")\n    def command4(self):\n        print \"Inside FourthController.command4()\"\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        handlers = [\n            MyAppBaseController,\n            SecondController,\n            ThirdController,\n            FourthController,\n            ]\n\ndef main():\n    with MyApp() as app:\n        app.run()\n\n\nif __name__ == '__main__':\n    main()\n```\n\nIn the base controller output of `--help` notice that the `second-controller` is listed as a sub-command:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nmy application does amazing things\n\ncommands:\n\n  command1\n    another base controller command\n\n  second-controller\n    this is the second controller (stacked/nested on base)\n\noptional arguments:\n  -h, --help           show this help message and exit\n  --debug              toggle debug output\n  --quiet              suppress all output\n  --base-opt BASE_OPT  option under base controller\n\n\n$ python myapp.py\nInside MyAppBaseController.default()\n\n\n$ python myapp.py command1\nInside MyAppBaseController.command1()\n\n$ python myapp.py second-controller\nInside SecondController.default()\n\n$ python myapp.py second-controller --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nthis is the second controller (stacked/nested on base)\n\ncommands:\n\n  command2\n    this is a command under the second-controller namespace\n\n  command3\n    another command under the second-controller namespace\n\n  fourth-controller\n    this controller is nested on the second-controller\n\noptional arguments:\n  -h, --help         show this help message and exit\n  --debug            toggle debug output\n  --quiet            suppress all output\n  --2nd-opt 2ND_OPT  another option under base controller\n  --3rd-opt 3RD_OPT  an option only under 3rd controller\n```\n\nUnder the `second-controller` you can see the commands and options from the second and third controllers. In this example, the `second-controller` is nested on the `base` controller, and the `third-controller` is embedded on the second-controller. Finally, we see that the `fourth-controller` is also nested on the `second-controller` creating a sub-sub-command.\n\n```\n$ python myapp.py second-controller command3\nInside ThirdController.command3()\n\n\n$ python myapp.py second-controller fourth-controller --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nthis controller is nested on the second-controller\n\ncommands:\n\n  command4\n    a command only under the fourth-controller namespace\n\noptional arguments:\n  -h, --help         show this help message and exit\n  --debug            toggle debug output\n  --quiet            suppress all output\n  --4th-opt 4TH_OPT  an option only under 3rd controller\n\n\n$ python myapp.py second-controller fourth-controller command4\nInside FourthController.command4()\n```\n","date":"2017-10-30T02:10:26.000Z","updated":"2017-10-30T02:10:26.000Z","path":"2.10/examples/multiple_stacked_controllers.html","_id":"cj9djouq50002iapw8o35aa2j","comments":1,"layout":"page","content":"<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># define application controllers</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAppBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\">        description = <span class=\"string\">\"my application does amazing things\"</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'--base-opt'</span>], dict(help=<span class=\"string\">\"option under base controller\"</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"base controller default command\", hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside MyAppBaseController.default()\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"another base controller command\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside MyAppBaseController.command1()\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'second_controller'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\">        description = <span class=\"string\">\"this is the second controller (stacked/nested on base)\"</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'--2nd-opt'</span>], dict(help=<span class=\"string\">\"another option under base controller\"</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"second-controller default command\", hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside SecondController.default()\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"this is a command under the second-controller namespace\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command2</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside SecondController.command2()\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThirdController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'third_controller'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'second_controller'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'embedded'</span></div><div class=\"line\">        description = <span class=\"string\">\"this controller is embedded in the second-controller\"</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'--3rd-opt'</span>], dict(help=<span class=\"string\">\"an option only under 3rd controller\"</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"another command under the second-controller namespace\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command3</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside ThirdController.command3()\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FourthController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'fourth_controller'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'second_controller'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\">        description = <span class=\"string\">\"this controller is nested on the second-controller\"</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'--4th-opt'</span>], dict(help=<span class=\"string\">\"an option only under 3rd controller\"</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"a command only under the fourth-controller namespace\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command4</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside FourthController.command4()\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        handlers = [</div><div class=\"line\">            MyAppBaseController,</div><div class=\"line\">            SecondController,</div><div class=\"line\">            ThirdController,</div><div class=\"line\">            FourthController,</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">        app.run()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<p>In the base controller output of <code>--help</code> notice that the <code>second-controller</code> is listed as a sub-command:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">my application does amazing things</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  command1</div><div class=\"line\">    another base controller command</div><div class=\"line\"></div><div class=\"line\">  second-controller</div><div class=\"line\">    this is the second controller (stacked/nested on base)</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help           show this help message and exit</div><div class=\"line\">  --debug              toggle debug output</div><div class=\"line\">  --quiet              suppress all output</div><div class=\"line\">  --base-opt BASE_OPT  option under base controller</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py</div><div class=\"line\">Inside MyAppBaseController.default()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py command1</div><div class=\"line\">Inside MyAppBaseController.command1()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py second-controller</div><div class=\"line\">Inside SecondController.default()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py second-controller --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">this is the second controller (stacked/nested on base)</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  command2</div><div class=\"line\">    this is a command under the second-controller namespace</div><div class=\"line\"></div><div class=\"line\">  command3</div><div class=\"line\">    another command under the second-controller namespace</div><div class=\"line\"></div><div class=\"line\">  fourth-controller</div><div class=\"line\">    this controller is nested on the second-controller</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help         show this help message and exit</div><div class=\"line\">  --debug            toggle debug output</div><div class=\"line\">  --quiet            suppress all output</div><div class=\"line\">  --2nd-opt 2ND_OPT  another option under base controller</div><div class=\"line\">  --3rd-opt 3RD_OPT  an option only under 3rd controller</div></pre></td></tr></table></figure>\n<p>Under the <code>second-controller</code> you can see the commands and options from the second and third controllers. In this example, the <code>second-controller</code> is nested on the <code>base</code> controller, and the <code>third-controller</code> is embedded on the second-controller. Finally, we see that the <code>fourth-controller</code> is also nested on the <code>second-controller</code> creating a sub-sub-command.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py second-controller command3</div><div class=\"line\">Inside ThirdController.command3()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py second-controller fourth-controller --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">this controller is nested on the second-controller</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  command4</div><div class=\"line\">    a command only under the fourth-controller namespace</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help         show this help message and exit</div><div class=\"line\">  --debug            toggle debug output</div><div class=\"line\">  --quiet            suppress all output</div><div class=\"line\">  --4th-opt 4TH_OPT  an option only under 3rd controller</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py second-controller fourth-controller command4</div><div class=\"line\">Inside FourthController.command4()</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># define application controllers</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAppBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\">        description = <span class=\"string\">\"my application does amazing things\"</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'--base-opt'</span>], dict(help=<span class=\"string\">\"option under base controller\"</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"base controller default command\", hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside MyAppBaseController.default()\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"another base controller command\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside MyAppBaseController.command1()\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'second_controller'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\">        description = <span class=\"string\">\"this is the second controller (stacked/nested on base)\"</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'--2nd-opt'</span>], dict(help=<span class=\"string\">\"another option under base controller\"</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"second-controller default command\", hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside SecondController.default()\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"this is a command under the second-controller namespace\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command2</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside SecondController.command2()\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThirdController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'third_controller'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'second_controller'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'embedded'</span></div><div class=\"line\">        description = <span class=\"string\">\"this controller is embedded in the second-controller\"</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'--3rd-opt'</span>], dict(help=<span class=\"string\">\"an option only under 3rd controller\"</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"another command under the second-controller namespace\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command3</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside ThirdController.command3()\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FourthController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'fourth_controller'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'second_controller'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\">        description = <span class=\"string\">\"this controller is nested on the second-controller\"</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'--4th-opt'</span>], dict(help=<span class=\"string\">\"an option only under 3rd controller\"</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(help=\"a command only under the fourth-controller namespace\")</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command4</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside FourthController.command4()\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        handlers = [</div><div class=\"line\">            MyAppBaseController,</div><div class=\"line\">            SecondController,</div><div class=\"line\">            ThirdController,</div><div class=\"line\">            FourthController,</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">        app.run()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<p>In the base controller output of <code>--help</code> notice that the <code>second-controller</code> is listed as a sub-command:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">my application does amazing things</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  command1</div><div class=\"line\">    another base controller command</div><div class=\"line\"></div><div class=\"line\">  second-controller</div><div class=\"line\">    this is the second controller (stacked/nested on base)</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help           show this help message and exit</div><div class=\"line\">  --debug              toggle debug output</div><div class=\"line\">  --quiet              suppress all output</div><div class=\"line\">  --base-opt BASE_OPT  option under base controller</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py</div><div class=\"line\">Inside MyAppBaseController.default()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py command1</div><div class=\"line\">Inside MyAppBaseController.command1()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py second-controller</div><div class=\"line\">Inside SecondController.default()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py second-controller --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">this is the second controller (stacked/nested on base)</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  command2</div><div class=\"line\">    this is a command under the second-controller namespace</div><div class=\"line\"></div><div class=\"line\">  command3</div><div class=\"line\">    another command under the second-controller namespace</div><div class=\"line\"></div><div class=\"line\">  fourth-controller</div><div class=\"line\">    this controller is nested on the second-controller</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help         show this help message and exit</div><div class=\"line\">  --debug            toggle debug output</div><div class=\"line\">  --quiet            suppress all output</div><div class=\"line\">  --2nd-opt 2ND_OPT  another option under base controller</div><div class=\"line\">  --3rd-opt 3RD_OPT  an option only under 3rd controller</div></pre></td></tr></table></figure>\n<p>Under the <code>second-controller</code> you can see the commands and options from the second and third controllers. In this example, the <code>second-controller</code> is nested on the <code>base</code> controller, and the <code>third-controller</code> is embedded on the second-controller. Finally, we see that the <code>fourth-controller</code> is also nested on the <code>second-controller</code> creating a sub-sub-command.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py second-controller command3</div><div class=\"line\">Inside ThirdController.command3()</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py second-controller fourth-controller --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">this controller is nested on the second-controller</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  command4</div><div class=\"line\">    a command only under the fourth-controller namespace</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help         show this help message and exit</div><div class=\"line\">  --debug            toggle debug output</div><div class=\"line\">  --quiet            suppress all output</div><div class=\"line\">  --4th-opt 4TH_OPT  an option only under 3rd controller</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py second-controller fourth-controller command4</div><div class=\"line\">Inside FourthController.command4()</div></pre></td></tr></table></figure>\n"},{"title":"Abstract Base Controllers","type":"examples","version":"2.10","order":5,"_content":"\nAbstract Base Controllers for Shared Arguments and Commands For larger, complex applications it is often very useful to have abstract base controllers that hold shared arguments and commands that a number of other controllers have in common. Note that in the example below, you can not override the Meta.arguments in a sub-class or you overwrite the shared arguments, but it is possible to append to them in order to maintain the defaults while having unique options/arguments for the sub-classed controller. As well, you can add any number of additional commands in the sub-class but still maintain the existing shared commands (or override them as necessary).\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\n\nclass AbstractBaseController(CementBaseController):\n    \"\"\"\n    This is an abstract base class that is useless on its own, but used\n    by other classes to sub-class from and to share common commands and\n    arguments.  This should not be confused with the `MyAppBaseController`\n    used as the ``base_controller`` namespace.\n\n    \"\"\"\n    class Meta:\n        stacked_on = 'base'\n        stacked_type = 'nested'\n        arguments = [\n            ( ['-f', '--foo'], dict(help='notorious foo option')),\n            ]\n\n    def _setup(self, base_app):\n        super(AbstractBaseController, self)._setup(base_app)\n\n        # add a common object that will be used in any sub-class\n        self.reusable_dict = dict()\n\n    @expose(hide=True)\n    def default(self):\n        \"\"\"\n        This command will be shared within all controllers that sub-class\n        from here.  It can also be overridden in the sub-class, but for\n        this example we are making it dynamic.\n\n        \"\"\"\n        # do something with self.my_shared_obj here?\n        if 'some_key' in self.reusable_dict.keys():\n            pass\n\n        # or do something with parsed args?\n        if self.app.pargs.foo:\n            print \"Foo option was passed with value: %s\" % self.app.pargs.foo\n\n        # or maybe do something dynamically\n        print(\"Inside %s.default()\" % self.__class__.__name__)\n\nclass MyAppBaseController(CementBaseController):\n    \"\"\"\n    This is the application base controller, but we don't want to use our\n    abstract base class here.\n\n    \"\"\"\n    class Meta:\n        label = 'base'\n\n    @expose(hide=True)\n    def default(self):\n        print(\"Inside MyAppBaseController.default()\")\n\nclass Controller1(AbstractBaseController):\n    \"\"\"\n    This controller sub-classes from the abstract base class as to inherite\n    shared arguments, and commands.\n\n    \"\"\"\n    class Meta:\n        label = 'controller1'\n\n    @expose()\n    def command1(self):\n        print(\"Inside Controller1.command1()\")\n\nclass Controller2(AbstractBaseController):\n    \"\"\"\n    This controller also sub-classes from the abstract base class as to\n    inherite shared arguments, and commands.\n\n    \"\"\"\n    class Meta:\n        label = 'controller2'\n\n    @expose()\n    def command2(self):\n        print(\"Inside Controller2.command2()\")\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        base_controller = 'base'\n        handlers = [\n            MyAppBaseController,\n            Controller1,\n            Controller2,\n            ]\n\ndef main():\n    with MyApp() as app:\n        app.run()\n\nif __name__ == '__main__':\n    main()\n```\n\nAnd:\n\n```\n$ python myapp.py\nInside MyAppBaseController.default()\n\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nBase Controller\n\ncommands:\n\n  controller1\n    Controller1 Controller\n\n  controller2\n    Controller2 Controller\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n\n\n$ python myapp.py controller1\nInside Controller1.default()\n\n$ python myapp.py controller1 --foo=bar\nFoo option was passed with value: bar\nInside Controller1.default()\n\n$ python myapp.py controller2\nInside Controller2.default()\n```\n","source":"2.10/examples/abstract_base_controllers.md","raw":"---\ntitle: Abstract Base Controllers\ntype: examples\nversion: \"2.10\"\norder: 5\n---\n\nAbstract Base Controllers for Shared Arguments and Commands For larger, complex applications it is often very useful to have abstract base controllers that hold shared arguments and commands that a number of other controllers have in common. Note that in the example below, you can not override the Meta.arguments in a sub-class or you overwrite the shared arguments, but it is possible to append to them in order to maintain the defaults while having unique options/arguments for the sub-classed controller. As well, you can add any number of additional commands in the sub-class but still maintain the existing shared commands (or override them as necessary).\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\n\nclass AbstractBaseController(CementBaseController):\n    \"\"\"\n    This is an abstract base class that is useless on its own, but used\n    by other classes to sub-class from and to share common commands and\n    arguments.  This should not be confused with the `MyAppBaseController`\n    used as the ``base_controller`` namespace.\n\n    \"\"\"\n    class Meta:\n        stacked_on = 'base'\n        stacked_type = 'nested'\n        arguments = [\n            ( ['-f', '--foo'], dict(help='notorious foo option')),\n            ]\n\n    def _setup(self, base_app):\n        super(AbstractBaseController, self)._setup(base_app)\n\n        # add a common object that will be used in any sub-class\n        self.reusable_dict = dict()\n\n    @expose(hide=True)\n    def default(self):\n        \"\"\"\n        This command will be shared within all controllers that sub-class\n        from here.  It can also be overridden in the sub-class, but for\n        this example we are making it dynamic.\n\n        \"\"\"\n        # do something with self.my_shared_obj here?\n        if 'some_key' in self.reusable_dict.keys():\n            pass\n\n        # or do something with parsed args?\n        if self.app.pargs.foo:\n            print \"Foo option was passed with value: %s\" % self.app.pargs.foo\n\n        # or maybe do something dynamically\n        print(\"Inside %s.default()\" % self.__class__.__name__)\n\nclass MyAppBaseController(CementBaseController):\n    \"\"\"\n    This is the application base controller, but we don't want to use our\n    abstract base class here.\n\n    \"\"\"\n    class Meta:\n        label = 'base'\n\n    @expose(hide=True)\n    def default(self):\n        print(\"Inside MyAppBaseController.default()\")\n\nclass Controller1(AbstractBaseController):\n    \"\"\"\n    This controller sub-classes from the abstract base class as to inherite\n    shared arguments, and commands.\n\n    \"\"\"\n    class Meta:\n        label = 'controller1'\n\n    @expose()\n    def command1(self):\n        print(\"Inside Controller1.command1()\")\n\nclass Controller2(AbstractBaseController):\n    \"\"\"\n    This controller also sub-classes from the abstract base class as to\n    inherite shared arguments, and commands.\n\n    \"\"\"\n    class Meta:\n        label = 'controller2'\n\n    @expose()\n    def command2(self):\n        print(\"Inside Controller2.command2()\")\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        base_controller = 'base'\n        handlers = [\n            MyAppBaseController,\n            Controller1,\n            Controller2,\n            ]\n\ndef main():\n    with MyApp() as app:\n        app.run()\n\nif __name__ == '__main__':\n    main()\n```\n\nAnd:\n\n```\n$ python myapp.py\nInside MyAppBaseController.default()\n\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nBase Controller\n\ncommands:\n\n  controller1\n    Controller1 Controller\n\n  controller2\n    Controller2 Controller\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n\n\n$ python myapp.py controller1\nInside Controller1.default()\n\n$ python myapp.py controller1 --foo=bar\nFoo option was passed with value: bar\nInside Controller1.default()\n\n$ python myapp.py controller2\nInside Controller2.default()\n```\n","date":"2017-10-30T02:14:09.000Z","updated":"2017-10-30T02:14:09.000Z","path":"2.10/examples/abstract_base_controllers.html","_id":"cj9djsuiz0003iapwpq81gqnv","comments":1,"layout":"page","content":"<p>Abstract Base Controllers for Shared Arguments and Commands For larger, complex applications it is often very useful to have abstract base controllers that hold shared arguments and commands that a number of other controllers have in common. Note that in the example below, you can not override the Meta.arguments in a sub-class or you overwrite the shared arguments, but it is possible to append to them in order to maintain the defaults while having unique options/arguments for the sub-classed controller. As well, you can add any number of additional commands in the sub-class but still maintain the existing shared commands (or override them as necessary).</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    This is an abstract base class that is useless on its own, but used</div><div class=\"line\">    by other classes to sub-class from and to share common commands and</div><div class=\"line\">    arguments.  This should not be confused with the `MyAppBaseController`</div><div class=\"line\">    used as the ``base_controller`` namespace.</div><div class=\"line\"></div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ( [<span class=\"string\">'-f'</span>, <span class=\"string\">'--foo'</span>], dict(help=<span class=\"string\">'notorious foo option'</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_setup</span><span class=\"params\">(self, base_app)</span>:</span></div><div class=\"line\">        super(AbstractBaseController, self)._setup(base_app)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># add a common object that will be used in any sub-class</span></div><div class=\"line\">        self.reusable_dict = dict()</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"string\">\"\"\"</span></div><div class=\"line\">        This command will be shared within all controllers that sub-class</div><div class=\"line\">        from here.  It can also be overridden in the sub-class, but for</div><div class=\"line\">        this example we are making it dynamic.</div><div class=\"line\"></div><div class=\"line\">        \"\"\"</div><div class=\"line\">        <span class=\"comment\"># do something with self.my_shared_obj here?</span></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">'some_key'</span> <span class=\"keyword\">in</span> self.reusable_dict.keys():</div><div class=\"line\">            <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># or do something with parsed args?</span></div><div class=\"line\">        <span class=\"keyword\">if</span> self.app.pargs.foo:</div><div class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"Foo option was passed with value: %s\"</span> % self.app.pargs.foo</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># or maybe do something dynamically</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside %s.default()\"</span> % self.__class__.__name__)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAppBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    This is the application base controller, but we don't want to use our</div><div class=\"line\">    abstract base class here.</div><div class=\"line\"></div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside MyAppBaseController.default()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Controller1</span><span class=\"params\">(AbstractBaseController)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    This controller sub-classes from the abstract base class as to inherite</div><div class=\"line\">    shared arguments, and commands.</div><div class=\"line\"></div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'controller1'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside Controller1.command1()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Controller2</span><span class=\"params\">(AbstractBaseController)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</span></div><div class=\"line\">    This controller also sub-classes from the abstract base class as to</div><div class=\"line\">    inherite shared arguments, and commands.</div><div class=\"line\"></div><div class=\"line\">    \"\"\"</div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'controller2'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command2</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside Controller2.command2()\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        base_controller = <span class=\"string\">'base'</span></div><div class=\"line\">        handlers = [</div><div class=\"line\">            MyAppBaseController,</div><div class=\"line\">            Controller1,</div><div class=\"line\">            Controller2,</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">        app.run()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<p>And:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">Inside MyAppBaseController.default()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">Base Controller</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  controller1</div><div class=\"line\">    Controller1 Controller</div><div class=\"line\"></div><div class=\"line\">  controller2</div><div class=\"line\">    Controller2 Controller</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py controller1</div><div class=\"line\">Inside Controller1.default()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py controller1 --foo=bar</div><div class=\"line\">Foo option was passed with value: bar</div><div class=\"line\">Inside Controller1.default()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py controller2</div><div class=\"line\">Inside Controller2.default()</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>Abstract Base Controllers for Shared Arguments and Commands For larger, complex applications it is often very useful to have abstract base controllers that hold shared arguments and commands that a number of other controllers have in common. Note that in the example below, you can not override the Meta.arguments in a sub-class or you overwrite the shared arguments, but it is possible to append to them in order to maintain the defaults while having unique options/arguments for the sub-classed controller. As well, you can add any number of additional commands in the sub-class but still maintain the existing shared commands (or override them as necessary).</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</div><div class=\"line\">    This is an abstract base class that is useless on its own, but used</div><div class=\"line\">    by other classes to sub-class from and to share common commands and</div><div class=\"line\">    arguments.  This should not be confused with the `MyAppBaseController`</div><div class=\"line\">    used as the ``base_controller`` namespace.</div><div class=\"line\"></div><div class=\"line\">    \"\"\"</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ( [<span class=\"string\">'-f'</span>, <span class=\"string\">'--foo'</span>], dict(help=<span class=\"string\">'notorious foo option'</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_setup</span><span class=\"params\">(self, base_app)</span>:</span></div><div class=\"line\">        super(AbstractBaseController, self)._setup(base_app)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># add a common object that will be used in any sub-class</span></div><div class=\"line\">        self.reusable_dict = dict()</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"string\">\"\"\"</div><div class=\"line\">        This command will be shared within all controllers that sub-class</div><div class=\"line\">        from here.  It can also be overridden in the sub-class, but for</div><div class=\"line\">        this example we are making it dynamic.</div><div class=\"line\"></div><div class=\"line\">        \"\"\"</span></div><div class=\"line\">        <span class=\"comment\"># do something with self.my_shared_obj here?</span></div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"string\">'some_key'</span> <span class=\"keyword\">in</span> self.reusable_dict.keys():</div><div class=\"line\">            <span class=\"keyword\">pass</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># or do something with parsed args?</span></div><div class=\"line\">        <span class=\"keyword\">if</span> self.app.pargs.foo:</div><div class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"Foo option was passed with value: %s\"</span> % self.app.pargs.foo</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># or maybe do something dynamically</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside %s.default()\"</span> % self.__class__.__name__)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAppBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</div><div class=\"line\">    This is the application base controller, but we don't want to use our</div><div class=\"line\">    abstract base class here.</div><div class=\"line\"></div><div class=\"line\">    \"\"\"</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside MyAppBaseController.default()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Controller1</span><span class=\"params\">(AbstractBaseController)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</div><div class=\"line\">    This controller sub-classes from the abstract base class as to inherite</div><div class=\"line\">    shared arguments, and commands.</div><div class=\"line\"></div><div class=\"line\">    \"\"\"</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'controller1'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside Controller1.command1()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Controller2</span><span class=\"params\">(AbstractBaseController)</span>:</span></div><div class=\"line\">    <span class=\"string\">\"\"\"</div><div class=\"line\">    This controller also sub-classes from the abstract base class as to</div><div class=\"line\">    inherite shared arguments, and commands.</div><div class=\"line\"></div><div class=\"line\">    \"\"\"</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'controller2'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">command2</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside Controller2.command2()\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        base_controller = <span class=\"string\">'base'</span></div><div class=\"line\">        handlers = [</div><div class=\"line\">            MyAppBaseController,</div><div class=\"line\">            Controller1,</div><div class=\"line\">            Controller2,</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">        app.run()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<p>And:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">Inside MyAppBaseController.default()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">Base Controller</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  controller1</div><div class=\"line\">    Controller1 Controller</div><div class=\"line\"></div><div class=\"line\">  controller2</div><div class=\"line\">    Controller2 Controller</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py controller1</div><div class=\"line\">Inside Controller1.default()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py controller1 --foo=bar</div><div class=\"line\">Foo option was passed with value: bar</div><div class=\"line\">Inside Controller1.default()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py controller2</div><div class=\"line\">Inside Controller2.default()</div></pre></td></tr></table></figure>\n"},{"title":"Controllers With Same Label","type":"examples","version":"2.10","order":6,"_content":"\nThere are many ways to use controllers. In some circumstances you might find that you want to have two controllers with the same label but stacked on different parent controllers. This is a problem because controller labels must be unique.\n\nTake for example the situation where you want to have a `list` controller, rather than a `list` function of another controller. You might call this as:\n\n```\n$ myapp <controller1> <list_controller>\n\n$ myapp <controller2> <some_other_list_controller>\n```\n\nIn both cases, you would probably want the sub-controller or sub-command to be `list`. This is possible with the use of the `aliases` and `aliases_only` meta options. Take the following code as an example where we have a `users` and a `hosts` controller and we want to have a `list` sub-command under both:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\n# define application controllers\nclass MyAppBaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n\nclass UsersController(CementBaseController):\n    class Meta:\n        label = 'users'\n        description = \"this is the users controller\"\n        stacked_on = 'base'\n        stacked_type = 'nested'\n\nclass HostsController(CementBaseController):\n    class Meta:\n        label = 'hosts'\n        description = \"this is the hosts controller\"\n        stacked_on = 'base'\n        stacked_type = 'nested'\n\nclass UsersListController(CementBaseController):\n    class Meta:\n        label = 'users_list'\n        description = 'list all available users'\n        aliases = ['list']\n        aliases_only = True\n        stacked_on = 'users'\n        stacked_type = 'nested'\n\n    @expose(hide=True)\n    def default(self):\n        print \"Inside UsersListController.default()\"\n\nclass HostsListController(CementBaseController):\n    class Meta:\n        label = 'hosts_list'\n        description = 'list all available hosts'\n        aliases = ['list']\n        aliases_only = True\n        stacked_on = 'hosts'\n        stacked_type = 'nested'\n\n    @expose(hide=True)\n    def default(self):\n        print \"Inside HostsListController.default()\"\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        handlers = [\n            MyAppBaseController,\n            UsersController,\n            HostsController,\n            UsersListController,\n            HostsListController,\n            ]\n\ndef main():\n    with MyApp() as app:\n        app.run()\n\nif __name__ == '__main__':\n    main()\n```\n\nUsage:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nBase Controller\n\ncommands:\n\n  hosts\n    this is the hosts controller\n\n  users\n    this is the users controller\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n\n\n$ python myapp.py users --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nthis is the users controller\n\ncommands:\n\n  list\n    list all available users\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n\n\n$ python myapp.py users list\nInside UsersListController.default()\n\n$ python myapp.py hosts list\nInside HostsListController.default()\n```\n","source":"2.10/examples/controllers_with_same_label.md","raw":"---\ntitle: Controllers With Same Label\ntype: examples\nversion: \"2.10\"\norder: 6\n---\n\nThere are many ways to use controllers. In some circumstances you might find that you want to have two controllers with the same label but stacked on different parent controllers. This is a problem because controller labels must be unique.\n\nTake for example the situation where you want to have a `list` controller, rather than a `list` function of another controller. You might call this as:\n\n```\n$ myapp <controller1> <list_controller>\n\n$ myapp <controller2> <some_other_list_controller>\n```\n\nIn both cases, you would probably want the sub-controller or sub-command to be `list`. This is possible with the use of the `aliases` and `aliases_only` meta options. Take the following code as an example where we have a `users` and a `hosts` controller and we want to have a `list` sub-command under both:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\n# define application controllers\nclass MyAppBaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n\nclass UsersController(CementBaseController):\n    class Meta:\n        label = 'users'\n        description = \"this is the users controller\"\n        stacked_on = 'base'\n        stacked_type = 'nested'\n\nclass HostsController(CementBaseController):\n    class Meta:\n        label = 'hosts'\n        description = \"this is the hosts controller\"\n        stacked_on = 'base'\n        stacked_type = 'nested'\n\nclass UsersListController(CementBaseController):\n    class Meta:\n        label = 'users_list'\n        description = 'list all available users'\n        aliases = ['list']\n        aliases_only = True\n        stacked_on = 'users'\n        stacked_type = 'nested'\n\n    @expose(hide=True)\n    def default(self):\n        print \"Inside UsersListController.default()\"\n\nclass HostsListController(CementBaseController):\n    class Meta:\n        label = 'hosts_list'\n        description = 'list all available hosts'\n        aliases = ['list']\n        aliases_only = True\n        stacked_on = 'hosts'\n        stacked_type = 'nested'\n\n    @expose(hide=True)\n    def default(self):\n        print \"Inside HostsListController.default()\"\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        handlers = [\n            MyAppBaseController,\n            UsersController,\n            HostsController,\n            UsersListController,\n            HostsListController,\n            ]\n\ndef main():\n    with MyApp() as app:\n        app.run()\n\nif __name__ == '__main__':\n    main()\n```\n\nUsage:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nBase Controller\n\ncommands:\n\n  hosts\n    this is the hosts controller\n\n  users\n    this is the users controller\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n\n\n$ python myapp.py users --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nthis is the users controller\n\ncommands:\n\n  list\n    list all available users\n\noptional arguments:\n  -h, --help  show this help message and exit\n  --debug     toggle debug output\n  --quiet     suppress all output\n\n\n$ python myapp.py users list\nInside UsersListController.default()\n\n$ python myapp.py hosts list\nInside HostsListController.default()\n```\n","date":"2017-10-30T02:17:43.000Z","updated":"2017-10-30T02:17:43.000Z","path":"2.10/examples/controllers_with_same_label.html","_id":"cj9djyb4l0004iapwri85dzun","comments":1,"layout":"page","content":"<p>There are many ways to use controllers. In some circumstances you might find that you want to have two controllers with the same label but stacked on different parent controllers. This is a problem because controller labels must be unique.</p>\n<p>Take for example the situation where you want to have a <code>list</code> controller, rather than a <code>list</code> function of another controller. You might call this as:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ myapp &lt;controller1&gt; &lt;list_controller&gt;</div><div class=\"line\"></div><div class=\"line\">$ myapp &lt;controller2&gt; &lt;some_other_list_controller&gt;</div></pre></td></tr></table></figure>\n<p>In both cases, you would probably want the sub-controller or sub-command to be <code>list</code>. This is possible with the use of the <code>aliases</code> and <code>aliases_only</code> meta options. Take the following code as an example where we have a <code>users</code> and a <code>hosts</code> controller and we want to have a <code>list</code> sub-command under both:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># define application controllers</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAppBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UsersController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'users'</span></div><div class=\"line\">        description = <span class=\"string\">\"this is the users controller\"</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HostsController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'hosts'</span></div><div class=\"line\">        description = <span class=\"string\">\"this is the hosts controller\"</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UsersListController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'users_list'</span></div><div class=\"line\">        description = <span class=\"string\">'list all available users'</span></div><div class=\"line\">        aliases = [<span class=\"string\">'list'</span>]</div><div class=\"line\">        aliases_only = <span class=\"keyword\">True</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'users'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside UsersListController.default()\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HostsListController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'hosts_list'</span></div><div class=\"line\">        description = <span class=\"string\">'list all available hosts'</span></div><div class=\"line\">        aliases = [<span class=\"string\">'list'</span>]</div><div class=\"line\">        aliases_only = <span class=\"keyword\">True</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'hosts'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside HostsListController.default()\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        handlers = [</div><div class=\"line\">            MyAppBaseController,</div><div class=\"line\">            UsersController,</div><div class=\"line\">            HostsController,</div><div class=\"line\">            UsersListController,</div><div class=\"line\">            HostsListController,</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">        app.run()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">Base Controller</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  hosts</div><div class=\"line\">    this is the hosts controller</div><div class=\"line\"></div><div class=\"line\">  users</div><div class=\"line\">    this is the users controller</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py users --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">this is the users controller</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  list</div><div class=\"line\">    list all available users</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py users list</div><div class=\"line\">Inside UsersListController.default()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py hosts list</div><div class=\"line\">Inside HostsListController.default()</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>There are many ways to use controllers. In some circumstances you might find that you want to have two controllers with the same label but stacked on different parent controllers. This is a problem because controller labels must be unique.</p>\n<p>Take for example the situation where you want to have a <code>list</code> controller, rather than a <code>list</code> function of another controller. You might call this as:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ myapp &lt;controller1&gt; &lt;list_controller&gt;</div><div class=\"line\"></div><div class=\"line\">$ myapp &lt;controller2&gt; &lt;some_other_list_controller&gt;</div></pre></td></tr></table></figure>\n<p>In both cases, you would probably want the sub-controller or sub-command to be <code>list</code>. This is possible with the use of the <code>aliases</code> and <code>aliases_only</code> meta options. Take the following code as an example where we have a <code>users</code> and a <code>hosts</code> controller and we want to have a <code>list</code> sub-command under both:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># define application controllers</span></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyAppBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UsersController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'users'</span></div><div class=\"line\">        description = <span class=\"string\">\"this is the users controller\"</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HostsController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'hosts'</span></div><div class=\"line\">        description = <span class=\"string\">\"this is the hosts controller\"</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UsersListController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'users_list'</span></div><div class=\"line\">        description = <span class=\"string\">'list all available users'</span></div><div class=\"line\">        aliases = [<span class=\"string\">'list'</span>]</div><div class=\"line\">        aliases_only = <span class=\"keyword\">True</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'users'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside UsersListController.default()\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HostsListController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'hosts_list'</span></div><div class=\"line\">        description = <span class=\"string\">'list all available hosts'</span></div><div class=\"line\">        aliases = [<span class=\"string\">'list'</span>]</div><div class=\"line\">        aliases_only = <span class=\"keyword\">True</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'hosts'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside HostsListController.default()\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        handlers = [</div><div class=\"line\">            MyAppBaseController,</div><div class=\"line\">            UsersController,</div><div class=\"line\">            HostsController,</div><div class=\"line\">            UsersListController,</div><div class=\"line\">            HostsListController,</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">        app.run()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<p>Usage:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">Base Controller</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  hosts</div><div class=\"line\">    this is the hosts controller</div><div class=\"line\"></div><div class=\"line\">  users</div><div class=\"line\">    this is the users controller</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py users --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">this is the users controller</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  list</div><div class=\"line\">    list all available users</div><div class=\"line\"></div><div class=\"line\">optional arguments:</div><div class=\"line\">  -h, --help  show this help message and exit</div><div class=\"line\">  --debug     toggle debug output</div><div class=\"line\">  --quiet     suppress all output</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py users list</div><div class=\"line\">Inside UsersListController.default()</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py hosts list</div><div class=\"line\">Inside HostsListController.default()</div></pre></td></tr></table></figure>\n"},{"title":"BASH Auto Completion","type":"examples","version":"2.10","order":7,"_content":"\nAuto Completion, or \"TAB Completion\" is a very common and familiar feature in BASH (and other modern shells). It is possible to auto-complete Cement apps (using BASH for this example) including sub-levels for nested controllers. The difficulty is that this auto-completion code must be maintained outside of Cement and your application code, and be implemented in the shell environment generally by use of an \"RC\" file, or similar means. This then must be updated anytime your application is modified (or atleast any time the sub-commands/controllers/arguments are modified).\n\nNote that, in the future, we would love to include some form of \"BASH RC Generator\" that will do this for you, however in the meantime the following is a working example that can be used as a model for adding BASH auto-completion to your app.\n\nUpdate: As of Cement 2.7.x, the Argcomplete Framework Extension can be used as an alternative to this example. Both are viable options though this route is much more manual, and the Argcomplete route might not fit your needs.\n\n**Example Cement App**\n\nThe following application code implements three levels of namespaces, or sub-commands, that are implemented via nested-controllers.\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\nclass BaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n\n    @expose()\n    def base_cmd1(self):\n        print(\"Inside BaseController.base_cmd1()\")\n\nclass EmbeddedController(CementBaseController):\n    class Meta:\n        label = 'embedded'\n        description = \"embedded with base namespace\"\n        stacked_on = 'base'\n        stacked_type = 'embedded'\n\n    @expose()\n    def base_cmd2(self):\n        print(\"Inside EmbeddedController.base_cmd2()\")\n\n    @expose()\n    def embedded_cmd3(self):\n        print(\"Inside EmbeddedController.embedded_cmd3()\")\n\nclass SecondLevelController(CementBaseController):\n    class Meta:\n        label = 'second'\n        description = ''\n        stacked_on = 'base'\n        stacked_type = 'nested'\n\n    @expose()\n    def second_cmd4(self):\n        print(\"Inside SecondLevelController.second_cmd4()\")\n\n    @expose()\n    def second_cmd5(self):\n        print(\"Inside SecondLevelController.second_cmd5()\")\n\nclass ThirdLevelController(CementBaseController):\n    class Meta:\n        label = 'third'\n        description = ''\n        stacked_on = 'second'\n        stacked_type = 'nested'\n\n    @expose()\n    def third_cmd6(self):\n        print(\"Inside ThirdLevelController.third_cmd6()\")\n\n    @expose()\n    def third_cmd7(self):\n        print(\"Inside ThirdLevelController.third_cmd7()\")\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        handlers = [\n            BaseController,\n            EmbeddedController,\n            SecondLevelController,\n            ThirdLevelController,\n            ]\n\n\ndef main():\n    with MyApp() as app:\n        app.run()\n\nif __name__ == '__main__':\n    main()\n```\n\nThis looks like:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nBase Controller\n\ncommands:\n\n  base-cmd1\n\n  base-cmd2\n\n  embedded-cmd3\n\n  second\n\n\n$ python myapp.py second --help\n\ncommands:\n\n  second-cmd4\n\n  second-cmd5\n\n  third\n\n\n$ python myapp.py second third --help\n\ncommands:\n\n  third-cmd6\n\n  third-cmd7\n```\n\nFor demonstration purposes, we are going to create a BASH alias here so that we can call our myapp command name as if we would in production (not development):\n\n```\n$ alias myapp=\"python ./myapp.py\"\n```\n\nIn the real world your actual `myapp` command would be setup/installed by something like this in `setup.py`:\n\n```python\nentry_points=\"\"\"\n    [console_scripts]\n    myapp = myapp.cli.main:main\n    \"\"\",\n```\n\nOr by simply copying `myapp.py` to `/usr/bin/myapp`, or similar.\n\n**Example BASH RC**\n\nThe following is a BASH RC script that will setup auto-completion for the above Cement App `myapp`. You will need to modify this, it is just an example and is not intended to be copy and pasted:\n\n```bash\nalias myapp=\"python ./myapp.py\"\n\n_myapp_complete()\n{\n    local cur prev BASE_LEVEL\n\n    COMPREPLY=()\n    cur=${COMP_WORDS[COMP_CWORD]}\n    prev=${COMP_WORDS[COMP_CWORD-1]}\n\n    # SETUP THE BASE LEVEL (everything after \"myapp\")\n    if [ $COMP_CWORD -eq 1 ]; then\n        COMPREPLY=( $(compgen \\\n                      -W \"base-cmd1 base-cmd2 embedded-cmd3 second\" \\\n                      -- $cur) )\n\n\n    # SETUP THE SECOND LEVEL (EVERYTHING AFTER \"myapp second\")\n    elif [ $COMP_CWORD -eq 2 ]; then\n        case \"$prev\" in\n\n            # HANDLE EVERYTHING AFTER THE SECOND LEVEL NAMESPACE\n            \"second\")\n                COMPREPLY=( $(compgen \\\n                              -W \"second-cmd4 second-cmd5 third\" \\\n                              -- $cur) )\n                ;;\n\n            # IF YOU HAD ANOTHER CONTROLLER, YOU'D HANDLE THAT HERE\n            \"some-other-controller\")\n                COMPREPLY=( $(compgen \\\n                              -W \"some-other-sub-command\" \\\n                              -- $cur) )\n                ;;\n\n            # EVERYTHING ELSE\n            *)\n                ;;\n        esac\n\n    # SETUP THE THIRD LEVEL (EVERYTHING AFTER \"myapp second third\")\n    elif [ $COMP_CWORD -eq 3 ]; then\n        case \"$prev\" in\n            # HANDLE EVERYTHING AFTER THE THIRD LEVEL NAMESPACE\n            \"third\")\n                COMPREPLY=( $(compgen \\\n                              -W \"third-cmd6 third-cmd7\" \\\n                              -- $cur) )\n                ;;\n\n            # IF YOU HAD ANOTHER CONTROLLER, YOU'D HANDLE THAT HERE\n            \"some-other-controller\")\n                COMPREPLY=( $(compgen \\\n                              -W \"some-other-sub-command\" \\\n                              -- $cur) )\n                ;;\n\n            *)\n                ;;\n        esac\n    fi\n\n    return 0\n\n} &&\ncomplete -F _myapp_complete myapp\n```\n\nYou would then `source` the RC file:\n\n```\n$ source myapp.rc\n```\n\nIn the real world you would probably put this in a system wide location such at `/etc/profile.d` or similar (in a production deployment).\n\nFinally, this is what it looks like:\n\n```\n### show all sub-commands at the base level\n\n$ myapp [tab] [tab]\nbase-cmd1      base-cmd2      embedded-cmd3      second\n\n\n### auto-complete a partial matching sub-command\n\n$ myapp base [tab]\n\n$ myapp base-cmd [tab] [tab]\nbase-cmd1      base-cmd2\n\n\n### auto-complete a full matching sub-command\n\n$ myapp sec [tab]\n\n$ myapp second\n\n\n### show all sub-commands under the second namespace\n\n$ myapp second [tab] [tab]\nsecond-cmd4      second-cmd5      third\n\n\n### show all sub-commands under the third namespace\n\n$ myapp second third [tab] [tab]\nthird-cmd6      third-cmd7\n```\n","source":"2.10/examples/bash_auto_completion.md","raw":"---\ntitle: BASH Auto Completion\ntype: examples\nversion: \"2.10\"\norder: 7\n---\n\nAuto Completion, or \"TAB Completion\" is a very common and familiar feature in BASH (and other modern shells). It is possible to auto-complete Cement apps (using BASH for this example) including sub-levels for nested controllers. The difficulty is that this auto-completion code must be maintained outside of Cement and your application code, and be implemented in the shell environment generally by use of an \"RC\" file, or similar means. This then must be updated anytime your application is modified (or atleast any time the sub-commands/controllers/arguments are modified).\n\nNote that, in the future, we would love to include some form of \"BASH RC Generator\" that will do this for you, however in the meantime the following is a working example that can be used as a model for adding BASH auto-completion to your app.\n\nUpdate: As of Cement 2.7.x, the Argcomplete Framework Extension can be used as an alternative to this example. Both are viable options though this route is much more manual, and the Argcomplete route might not fit your needs.\n\n**Example Cement App**\n\nThe following application code implements three levels of namespaces, or sub-commands, that are implemented via nested-controllers.\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\nclass BaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n\n    @expose()\n    def base_cmd1(self):\n        print(\"Inside BaseController.base_cmd1()\")\n\nclass EmbeddedController(CementBaseController):\n    class Meta:\n        label = 'embedded'\n        description = \"embedded with base namespace\"\n        stacked_on = 'base'\n        stacked_type = 'embedded'\n\n    @expose()\n    def base_cmd2(self):\n        print(\"Inside EmbeddedController.base_cmd2()\")\n\n    @expose()\n    def embedded_cmd3(self):\n        print(\"Inside EmbeddedController.embedded_cmd3()\")\n\nclass SecondLevelController(CementBaseController):\n    class Meta:\n        label = 'second'\n        description = ''\n        stacked_on = 'base'\n        stacked_type = 'nested'\n\n    @expose()\n    def second_cmd4(self):\n        print(\"Inside SecondLevelController.second_cmd4()\")\n\n    @expose()\n    def second_cmd5(self):\n        print(\"Inside SecondLevelController.second_cmd5()\")\n\nclass ThirdLevelController(CementBaseController):\n    class Meta:\n        label = 'third'\n        description = ''\n        stacked_on = 'second'\n        stacked_type = 'nested'\n\n    @expose()\n    def third_cmd6(self):\n        print(\"Inside ThirdLevelController.third_cmd6()\")\n\n    @expose()\n    def third_cmd7(self):\n        print(\"Inside ThirdLevelController.third_cmd7()\")\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        handlers = [\n            BaseController,\n            EmbeddedController,\n            SecondLevelController,\n            ThirdLevelController,\n            ]\n\n\ndef main():\n    with MyApp() as app:\n        app.run()\n\nif __name__ == '__main__':\n    main()\n```\n\nThis looks like:\n\n```\n$ python myapp.py --help\nusage: myapp.py (sub-commands ...) [options ...] {arguments ...}\n\nBase Controller\n\ncommands:\n\n  base-cmd1\n\n  base-cmd2\n\n  embedded-cmd3\n\n  second\n\n\n$ python myapp.py second --help\n\ncommands:\n\n  second-cmd4\n\n  second-cmd5\n\n  third\n\n\n$ python myapp.py second third --help\n\ncommands:\n\n  third-cmd6\n\n  third-cmd7\n```\n\nFor demonstration purposes, we are going to create a BASH alias here so that we can call our myapp command name as if we would in production (not development):\n\n```\n$ alias myapp=\"python ./myapp.py\"\n```\n\nIn the real world your actual `myapp` command would be setup/installed by something like this in `setup.py`:\n\n```python\nentry_points=\"\"\"\n    [console_scripts]\n    myapp = myapp.cli.main:main\n    \"\"\",\n```\n\nOr by simply copying `myapp.py` to `/usr/bin/myapp`, or similar.\n\n**Example BASH RC**\n\nThe following is a BASH RC script that will setup auto-completion for the above Cement App `myapp`. You will need to modify this, it is just an example and is not intended to be copy and pasted:\n\n```bash\nalias myapp=\"python ./myapp.py\"\n\n_myapp_complete()\n{\n    local cur prev BASE_LEVEL\n\n    COMPREPLY=()\n    cur=${COMP_WORDS[COMP_CWORD]}\n    prev=${COMP_WORDS[COMP_CWORD-1]}\n\n    # SETUP THE BASE LEVEL (everything after \"myapp\")\n    if [ $COMP_CWORD -eq 1 ]; then\n        COMPREPLY=( $(compgen \\\n                      -W \"base-cmd1 base-cmd2 embedded-cmd3 second\" \\\n                      -- $cur) )\n\n\n    # SETUP THE SECOND LEVEL (EVERYTHING AFTER \"myapp second\")\n    elif [ $COMP_CWORD -eq 2 ]; then\n        case \"$prev\" in\n\n            # HANDLE EVERYTHING AFTER THE SECOND LEVEL NAMESPACE\n            \"second\")\n                COMPREPLY=( $(compgen \\\n                              -W \"second-cmd4 second-cmd5 third\" \\\n                              -- $cur) )\n                ;;\n\n            # IF YOU HAD ANOTHER CONTROLLER, YOU'D HANDLE THAT HERE\n            \"some-other-controller\")\n                COMPREPLY=( $(compgen \\\n                              -W \"some-other-sub-command\" \\\n                              -- $cur) )\n                ;;\n\n            # EVERYTHING ELSE\n            *)\n                ;;\n        esac\n\n    # SETUP THE THIRD LEVEL (EVERYTHING AFTER \"myapp second third\")\n    elif [ $COMP_CWORD -eq 3 ]; then\n        case \"$prev\" in\n            # HANDLE EVERYTHING AFTER THE THIRD LEVEL NAMESPACE\n            \"third\")\n                COMPREPLY=( $(compgen \\\n                              -W \"third-cmd6 third-cmd7\" \\\n                              -- $cur) )\n                ;;\n\n            # IF YOU HAD ANOTHER CONTROLLER, YOU'D HANDLE THAT HERE\n            \"some-other-controller\")\n                COMPREPLY=( $(compgen \\\n                              -W \"some-other-sub-command\" \\\n                              -- $cur) )\n                ;;\n\n            *)\n                ;;\n        esac\n    fi\n\n    return 0\n\n} &&\ncomplete -F _myapp_complete myapp\n```\n\nYou would then `source` the RC file:\n\n```\n$ source myapp.rc\n```\n\nIn the real world you would probably put this in a system wide location such at `/etc/profile.d` or similar (in a production deployment).\n\nFinally, this is what it looks like:\n\n```\n### show all sub-commands at the base level\n\n$ myapp [tab] [tab]\nbase-cmd1      base-cmd2      embedded-cmd3      second\n\n\n### auto-complete a partial matching sub-command\n\n$ myapp base [tab]\n\n$ myapp base-cmd [tab] [tab]\nbase-cmd1      base-cmd2\n\n\n### auto-complete a full matching sub-command\n\n$ myapp sec [tab]\n\n$ myapp second\n\n\n### show all sub-commands under the second namespace\n\n$ myapp second [tab] [tab]\nsecond-cmd4      second-cmd5      third\n\n\n### show all sub-commands under the third namespace\n\n$ myapp second third [tab] [tab]\nthird-cmd6      third-cmd7\n```\n","date":"2017-10-30T02:22:51.000Z","updated":"2017-10-30T02:22:51.000Z","path":"2.10/examples/bash_auto_completion.html","_id":"cj9dk292t0005iapw1jsu1yrd","comments":1,"layout":"page","content":"<p>Auto Completion, or “TAB Completion” is a very common and familiar feature in BASH (and other modern shells). It is possible to auto-complete Cement apps (using BASH for this example) including sub-levels for nested controllers. The difficulty is that this auto-completion code must be maintained outside of Cement and your application code, and be implemented in the shell environment generally by use of an “RC” file, or similar means. This then must be updated anytime your application is modified (or atleast any time the sub-commands/controllers/arguments are modified).</p>\n<p>Note that, in the future, we would love to include some form of “BASH RC Generator” that will do this for you, however in the meantime the following is a working example that can be used as a model for adding BASH auto-completion to your app.</p>\n<p>Update: As of Cement 2.7.x, the Argcomplete Framework Extension can be used as an alternative to this example. Both are viable options though this route is much more manual, and the Argcomplete route might not fit your needs.</p>\n<p><strong>Example Cement App</strong></p>\n<p>The following application code implements three levels of namespaces, or sub-commands, that are implemented via nested-controllers.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">base_cmd1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside BaseController.base_cmd1()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmbeddedController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'embedded'</span></div><div class=\"line\">        description = <span class=\"string\">\"embedded with base namespace\"</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'embedded'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">base_cmd2</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside EmbeddedController.base_cmd2()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">embedded_cmd3</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside EmbeddedController.embedded_cmd3()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondLevelController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'second'</span></div><div class=\"line\">        description = <span class=\"string\">''</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">second_cmd4</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside SecondLevelController.second_cmd4()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">second_cmd5</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside SecondLevelController.second_cmd5()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThirdLevelController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'third'</span></div><div class=\"line\">        description = <span class=\"string\">''</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'second'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">third_cmd6</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside ThirdLevelController.third_cmd6()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">third_cmd7</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside ThirdLevelController.third_cmd7()\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        handlers = [</div><div class=\"line\">            BaseController,</div><div class=\"line\">            EmbeddedController,</div><div class=\"line\">            SecondLevelController,</div><div class=\"line\">            ThirdLevelController,</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">        app.run()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<p>This looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">Base Controller</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  base-cmd1</div><div class=\"line\"></div><div class=\"line\">  base-cmd2</div><div class=\"line\"></div><div class=\"line\">  embedded-cmd3</div><div class=\"line\"></div><div class=\"line\">  second</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py second --help</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  second-cmd4</div><div class=\"line\"></div><div class=\"line\">  second-cmd5</div><div class=\"line\"></div><div class=\"line\">  third</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py second third --help</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  third-cmd6</div><div class=\"line\"></div><div class=\"line\">  third-cmd7</div></pre></td></tr></table></figure>\n<p>For demonstration purposes, we are going to create a BASH alias here so that we can call our myapp command name as if we would in production (not development):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ alias myapp=&quot;python ./myapp.py&quot;</div></pre></td></tr></table></figure>\n<p>In the real world your actual <code>myapp</code> command would be setup/installed by something like this in <code>setup.py</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">entry_points=<span class=\"string\">\"\"\"</span></div><div class=\"line\">    [console_scripts]</div><div class=\"line\">    myapp = myapp.cli.main:main</div><div class=\"line\">    \"\"\",</div></pre></td></tr></table></figure>\n<p>Or by simply copying <code>myapp.py</code> to <code>/usr/bin/myapp</code>, or similar.</p>\n<p><strong>Example BASH RC</strong></p>\n<p>The following is a BASH RC script that will setup auto-completion for the above Cement App <code>myapp</code>. You will need to modify this, it is just an example and is not intended to be copy and pasted:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">alias</span> myapp=<span class=\"string\">\"python ./myapp.py\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">_myapp_complete</span></span>()</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">local</span> cur prev BASE_LEVEL</div><div class=\"line\"></div><div class=\"line\">    COMPREPLY=()</div><div class=\"line\">    cur=<span class=\"variable\">$&#123;COMP_WORDS[COMP_CWORD]&#125;</span></div><div class=\"line\">    prev=<span class=\"variable\">$&#123;COMP_WORDS[COMP_CWORD-1]&#125;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># SETUP THE BASE LEVEL (everything after \"myapp\")</span></div><div class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"variable\">$COMP_CWORD</span> -eq 1 ]; <span class=\"keyword\">then</span></div><div class=\"line\">        COMPREPLY=( $(compgen \\</div><div class=\"line\">                      -W <span class=\"string\">\"base-cmd1 base-cmd2 embedded-cmd3 second\"</span> \\</div><div class=\"line\">                      -- <span class=\"variable\">$cur</span>) )</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># SETUP THE SECOND LEVEL (EVERYTHING AFTER \"myapp second\")</span></div><div class=\"line\">    <span class=\"keyword\">elif</span> [ <span class=\"variable\">$COMP_CWORD</span> -eq 2 ]; <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"<span class=\"variable\">$prev</span>\"</span> <span class=\"keyword\">in</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># HANDLE EVERYTHING AFTER THE SECOND LEVEL NAMESPACE</span></div><div class=\"line\">            <span class=\"string\">\"second\"</span>)</div><div class=\"line\">                COMPREPLY=( $(compgen \\</div><div class=\"line\">                              -W <span class=\"string\">\"second-cmd4 second-cmd5 third\"</span> \\</div><div class=\"line\">                              -- <span class=\"variable\">$cur</span>) )</div><div class=\"line\">                ;;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># IF YOU HAD ANOTHER CONTROLLER, YOU'D HANDLE THAT HERE</span></div><div class=\"line\">            <span class=\"string\">\"some-other-controller\"</span>)</div><div class=\"line\">                COMPREPLY=( $(compgen \\</div><div class=\"line\">                              -W <span class=\"string\">\"some-other-sub-command\"</span> \\</div><div class=\"line\">                              -- <span class=\"variable\">$cur</span>) )</div><div class=\"line\">                ;;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># EVERYTHING ELSE</span></div><div class=\"line\">            *)</div><div class=\"line\">                ;;</div><div class=\"line\">        <span class=\"keyword\">esac</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># SETUP THE THIRD LEVEL (EVERYTHING AFTER \"myapp second third\")</span></div><div class=\"line\">    <span class=\"keyword\">elif</span> [ <span class=\"variable\">$COMP_CWORD</span> -eq 3 ]; <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"<span class=\"variable\">$prev</span>\"</span> <span class=\"keyword\">in</span></div><div class=\"line\">            <span class=\"comment\"># HANDLE EVERYTHING AFTER THE THIRD LEVEL NAMESPACE</span></div><div class=\"line\">            <span class=\"string\">\"third\"</span>)</div><div class=\"line\">                COMPREPLY=( $(compgen \\</div><div class=\"line\">                              -W <span class=\"string\">\"third-cmd6 third-cmd7\"</span> \\</div><div class=\"line\">                              -- <span class=\"variable\">$cur</span>) )</div><div class=\"line\">                ;;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># IF YOU HAD ANOTHER CONTROLLER, YOU'D HANDLE THAT HERE</span></div><div class=\"line\">            <span class=\"string\">\"some-other-controller\"</span>)</div><div class=\"line\">                COMPREPLY=( $(compgen \\</div><div class=\"line\">                              -W <span class=\"string\">\"some-other-sub-command\"</span> \\</div><div class=\"line\">                              -- <span class=\"variable\">$cur</span>) )</div><div class=\"line\">                ;;</div><div class=\"line\"></div><div class=\"line\">            *)</div><div class=\"line\">                ;;</div><div class=\"line\">        <span class=\"keyword\">esac</span></div><div class=\"line\">    <span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">return</span> 0</div><div class=\"line\"></div><div class=\"line\">&#125; &amp;&amp;</div><div class=\"line\">complete -F _myapp_complete myapp</div></pre></td></tr></table></figure>\n<p>You would then <code>source</code> the RC file:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ source myapp.rc</div></pre></td></tr></table></figure>\n<p>In the real world you would probably put this in a system wide location such at <code>/etc/profile.d</code> or similar (in a production deployment).</p>\n<p>Finally, this is what it looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">### show all sub-commands at the base level</div><div class=\"line\"></div><div class=\"line\">$ myapp [tab] [tab]</div><div class=\"line\">base-cmd1      base-cmd2      embedded-cmd3      second</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### auto-complete a partial matching sub-command</div><div class=\"line\"></div><div class=\"line\">$ myapp base [tab]</div><div class=\"line\"></div><div class=\"line\">$ myapp base-cmd [tab] [tab]</div><div class=\"line\">base-cmd1      base-cmd2</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### auto-complete a full matching sub-command</div><div class=\"line\"></div><div class=\"line\">$ myapp sec [tab]</div><div class=\"line\"></div><div class=\"line\">$ myapp second</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### show all sub-commands under the second namespace</div><div class=\"line\"></div><div class=\"line\">$ myapp second [tab] [tab]</div><div class=\"line\">second-cmd4      second-cmd5      third</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### show all sub-commands under the third namespace</div><div class=\"line\"></div><div class=\"line\">$ myapp second third [tab] [tab]</div><div class=\"line\">third-cmd6      third-cmd7</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>Auto Completion, or “TAB Completion” is a very common and familiar feature in BASH (and other modern shells). It is possible to auto-complete Cement apps (using BASH for this example) including sub-levels for nested controllers. The difficulty is that this auto-completion code must be maintained outside of Cement and your application code, and be implemented in the shell environment generally by use of an “RC” file, or similar means. This then must be updated anytime your application is modified (or atleast any time the sub-commands/controllers/arguments are modified).</p>\n<p>Note that, in the future, we would love to include some form of “BASH RC Generator” that will do this for you, however in the meantime the following is a working example that can be used as a model for adding BASH auto-completion to your app.</p>\n<p>Update: As of Cement 2.7.x, the Argcomplete Framework Extension can be used as an alternative to this example. Both are viable options though this route is much more manual, and the Argcomplete route might not fit your needs.</p>\n<p><strong>Example Cement App</strong></p>\n<p>The following application code implements three levels of namespaces, or sub-commands, that are implemented via nested-controllers.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">base_cmd1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside BaseController.base_cmd1()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmbeddedController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'embedded'</span></div><div class=\"line\">        description = <span class=\"string\">\"embedded with base namespace\"</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'embedded'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">base_cmd2</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside EmbeddedController.base_cmd2()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">embedded_cmd3</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside EmbeddedController.embedded_cmd3()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecondLevelController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'second'</span></div><div class=\"line\">        description = <span class=\"string\">''</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">second_cmd4</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside SecondLevelController.second_cmd4()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">second_cmd5</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside SecondLevelController.second_cmd5()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThirdLevelController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'third'</span></div><div class=\"line\">        description = <span class=\"string\">''</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'second'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">third_cmd6</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside ThirdLevelController.third_cmd6()\"</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">third_cmd7</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">\"Inside ThirdLevelController.third_cmd7()\"</span>)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        handlers = [</div><div class=\"line\">            BaseController,</div><div class=\"line\">            EmbeddedController,</div><div class=\"line\">            SecondLevelController,</div><div class=\"line\">            ThirdLevelController,</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">        app.run()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<p>This looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --help</div><div class=\"line\">usage: myapp.py (sub-commands ...) [options ...] &#123;arguments ...&#125;</div><div class=\"line\"></div><div class=\"line\">Base Controller</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  base-cmd1</div><div class=\"line\"></div><div class=\"line\">  base-cmd2</div><div class=\"line\"></div><div class=\"line\">  embedded-cmd3</div><div class=\"line\"></div><div class=\"line\">  second</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py second --help</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  second-cmd4</div><div class=\"line\"></div><div class=\"line\">  second-cmd5</div><div class=\"line\"></div><div class=\"line\">  third</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">$ python myapp.py second third --help</div><div class=\"line\"></div><div class=\"line\">commands:</div><div class=\"line\"></div><div class=\"line\">  third-cmd6</div><div class=\"line\"></div><div class=\"line\">  third-cmd7</div></pre></td></tr></table></figure>\n<p>For demonstration purposes, we are going to create a BASH alias here so that we can call our myapp command name as if we would in production (not development):</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ alias myapp=&quot;python ./myapp.py&quot;</div></pre></td></tr></table></figure>\n<p>In the real world your actual <code>myapp</code> command would be setup/installed by something like this in <code>setup.py</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\">entry_points=<span class=\"string\">\"\"\"</div><div class=\"line\">    [console_scripts]</div><div class=\"line\">    myapp = myapp.cli.main:main</div><div class=\"line\">    \"\"\"</span>,</div></pre></td></tr></table></figure>\n<p>Or by simply copying <code>myapp.py</code> to <code>/usr/bin/myapp</code>, or similar.</p>\n<p><strong>Example BASH RC</strong></p>\n<p>The following is a BASH RC script that will setup auto-completion for the above Cement App <code>myapp</code>. You will need to modify this, it is just an example and is not intended to be copy and pasted:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">alias</span> myapp=<span class=\"string\">\"python ./myapp.py\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"title\">_myapp_complete</span></span>()</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"built_in\">local</span> cur prev BASE_LEVEL</div><div class=\"line\"></div><div class=\"line\">    COMPREPLY=()</div><div class=\"line\">    cur=<span class=\"variable\">$&#123;COMP_WORDS[COMP_CWORD]&#125;</span></div><div class=\"line\">    prev=<span class=\"variable\">$&#123;COMP_WORDS[COMP_CWORD-1]&#125;</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># SETUP THE BASE LEVEL (everything after \"myapp\")</span></div><div class=\"line\">    <span class=\"keyword\">if</span> [ <span class=\"variable\">$COMP_CWORD</span> -eq 1 ]; <span class=\"keyword\">then</span></div><div class=\"line\">        COMPREPLY=( $(compgen \\</div><div class=\"line\">                      -W <span class=\"string\">\"base-cmd1 base-cmd2 embedded-cmd3 second\"</span> \\</div><div class=\"line\">                      -- <span class=\"variable\">$cur</span>) )</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># SETUP THE SECOND LEVEL (EVERYTHING AFTER \"myapp second\")</span></div><div class=\"line\">    <span class=\"keyword\">elif</span> [ <span class=\"variable\">$COMP_CWORD</span> -eq 2 ]; <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"<span class=\"variable\">$prev</span>\"</span> <span class=\"keyword\">in</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># HANDLE EVERYTHING AFTER THE SECOND LEVEL NAMESPACE</span></div><div class=\"line\">            <span class=\"string\">\"second\"</span>)</div><div class=\"line\">                COMPREPLY=( $(compgen \\</div><div class=\"line\">                              -W <span class=\"string\">\"second-cmd4 second-cmd5 third\"</span> \\</div><div class=\"line\">                              -- <span class=\"variable\">$cur</span>) )</div><div class=\"line\">                ;;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># IF YOU HAD ANOTHER CONTROLLER, YOU'D HANDLE THAT HERE</span></div><div class=\"line\">            <span class=\"string\">\"some-other-controller\"</span>)</div><div class=\"line\">                COMPREPLY=( $(compgen \\</div><div class=\"line\">                              -W <span class=\"string\">\"some-other-sub-command\"</span> \\</div><div class=\"line\">                              -- <span class=\"variable\">$cur</span>) )</div><div class=\"line\">                ;;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># EVERYTHING ELSE</span></div><div class=\"line\">            *)</div><div class=\"line\">                ;;</div><div class=\"line\">        <span class=\"keyword\">esac</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\"># SETUP THE THIRD LEVEL (EVERYTHING AFTER \"myapp second third\")</span></div><div class=\"line\">    <span class=\"keyword\">elif</span> [ <span class=\"variable\">$COMP_CWORD</span> -eq 3 ]; <span class=\"keyword\">then</span></div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">\"<span class=\"variable\">$prev</span>\"</span> <span class=\"keyword\">in</span></div><div class=\"line\">            <span class=\"comment\"># HANDLE EVERYTHING AFTER THE THIRD LEVEL NAMESPACE</span></div><div class=\"line\">            <span class=\"string\">\"third\"</span>)</div><div class=\"line\">                COMPREPLY=( $(compgen \\</div><div class=\"line\">                              -W <span class=\"string\">\"third-cmd6 third-cmd7\"</span> \\</div><div class=\"line\">                              -- <span class=\"variable\">$cur</span>) )</div><div class=\"line\">                ;;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\"># IF YOU HAD ANOTHER CONTROLLER, YOU'D HANDLE THAT HERE</span></div><div class=\"line\">            <span class=\"string\">\"some-other-controller\"</span>)</div><div class=\"line\">                COMPREPLY=( $(compgen \\</div><div class=\"line\">                              -W <span class=\"string\">\"some-other-sub-command\"</span> \\</div><div class=\"line\">                              -- <span class=\"variable\">$cur</span>) )</div><div class=\"line\">                ;;</div><div class=\"line\"></div><div class=\"line\">            *)</div><div class=\"line\">                ;;</div><div class=\"line\">        <span class=\"keyword\">esac</span></div><div class=\"line\">    <span class=\"keyword\">fi</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">return</span> 0</div><div class=\"line\"></div><div class=\"line\">&#125; &amp;&amp;</div><div class=\"line\">complete -F _myapp_complete myapp</div></pre></td></tr></table></figure>\n<p>You would then <code>source</code> the RC file:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ source myapp.rc</div></pre></td></tr></table></figure>\n<p>In the real world you would probably put this in a system wide location such at <code>/etc/profile.d</code> or similar (in a production deployment).</p>\n<p>Finally, this is what it looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">### show all sub-commands at the base level</div><div class=\"line\"></div><div class=\"line\">$ myapp [tab] [tab]</div><div class=\"line\">base-cmd1      base-cmd2      embedded-cmd3      second</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### auto-complete a partial matching sub-command</div><div class=\"line\"></div><div class=\"line\">$ myapp base [tab]</div><div class=\"line\"></div><div class=\"line\">$ myapp base-cmd [tab] [tab]</div><div class=\"line\">base-cmd1      base-cmd2</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### auto-complete a full matching sub-command</div><div class=\"line\"></div><div class=\"line\">$ myapp sec [tab]</div><div class=\"line\"></div><div class=\"line\">$ myapp second</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### show all sub-commands under the second namespace</div><div class=\"line\"></div><div class=\"line\">$ myapp second [tab] [tab]</div><div class=\"line\">second-cmd4      second-cmd5      third</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">### show all sub-commands under the third namespace</div><div class=\"line\"></div><div class=\"line\">$ myapp second third [tab] [tab]</div><div class=\"line\">third-cmd6      third-cmd7</div></pre></td></tr></table></figure>\n"},{"title":"Arbitrary Positional Arguments","type":"examples","version":"2.10","order":8,"_content":"\nIt is common practice to accept additional positional arguments at command line, rather than option flags. For example:\n\n```\n$ myapp some-command some-argument --foo=bar\n```\n\nIn the above, `some-command` would be the function under whatever controller it is exposed from, and some-argument would be just an arbitrary argument. In most cases, the argument within the code is generic, but its uses vary. For example:\n\n```\n$ myapp create-user john.doe\n\n$ myapp create-group admins\n```\n\nIn the above, the sub-commands are create-user and create-group, and in this use case they are under the same controller. The argument however differs for each command, though it is passed to the app the same (the first positional argument, that is not a controller/command).\n\nThe following example outlines how you might handle arbitrary (or generic) positional arguments.\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\nclass MyBaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n\nclass MySecondController(CementBaseController):\n    class Meta:\n        label = 'second'\n        stacked_type = 'nested'\n        stacked_on = 'base'\n        description = 'this is the second controller namespace'\n        arguments = [\n            (['-f', '--foo'],\n             dict(help='the notorious foo option', action='store')),\n            (['extra_arguments'],\n             dict(action='store', nargs='*')),\n        ]\n\n    @expose()\n    def cmd1(self):\n        print \"Inside MySecondController.cmd1()\"\n\n        if self.app.pargs.extra_arguments:\n            print \"Extra Argument 0: %s\" % self.app.pargs.extra_arguments[0]\n            print \"Extra Argument 1: %s\" % self.app.pargs.extra_arguments[1]\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        base_controller = 'base'\n        handlers = [\n            MyBaseController,\n            MySecondController,\n            ]\n\ndef main():\n    with MyApp() as app:\n        app.run()\n\nif __name__ == '__main__':\n    main()\n```\n\nAnd this would look something like:\n\n```\n$ python argtest.py second cmd1 extra1 extra2\nInside MySecondController.cmd1()\nExtra Argument 0: extra1\nExtra Argument 1: extra2\n```\n","source":"2.10/examples/arbitrary_extra_arguments.md","raw":"---\ntitle: Arbitrary Positional Arguments\ntype: examples\nversion: \"2.10\"\norder: 8\n---\n\nIt is common practice to accept additional positional arguments at command line, rather than option flags. For example:\n\n```\n$ myapp some-command some-argument --foo=bar\n```\n\nIn the above, `some-command` would be the function under whatever controller it is exposed from, and some-argument would be just an arbitrary argument. In most cases, the argument within the code is generic, but its uses vary. For example:\n\n```\n$ myapp create-user john.doe\n\n$ myapp create-group admins\n```\n\nIn the above, the sub-commands are create-user and create-group, and in this use case they are under the same controller. The argument however differs for each command, though it is passed to the app the same (the first positional argument, that is not a controller/command).\n\nThe following example outlines how you might handle arbitrary (or generic) positional arguments.\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\nclass MyBaseController(CementBaseController):\n    class Meta:\n        label = 'base'\n\nclass MySecondController(CementBaseController):\n    class Meta:\n        label = 'second'\n        stacked_type = 'nested'\n        stacked_on = 'base'\n        description = 'this is the second controller namespace'\n        arguments = [\n            (['-f', '--foo'],\n             dict(help='the notorious foo option', action='store')),\n            (['extra_arguments'],\n             dict(action='store', nargs='*')),\n        ]\n\n    @expose()\n    def cmd1(self):\n        print \"Inside MySecondController.cmd1()\"\n\n        if self.app.pargs.extra_arguments:\n            print \"Extra Argument 0: %s\" % self.app.pargs.extra_arguments[0]\n            print \"Extra Argument 1: %s\" % self.app.pargs.extra_arguments[1]\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        base_controller = 'base'\n        handlers = [\n            MyBaseController,\n            MySecondController,\n            ]\n\ndef main():\n    with MyApp() as app:\n        app.run()\n\nif __name__ == '__main__':\n    main()\n```\n\nAnd this would look something like:\n\n```\n$ python argtest.py second cmd1 extra1 extra2\nInside MySecondController.cmd1()\nExtra Argument 0: extra1\nExtra Argument 1: extra2\n```\n","date":"2017-10-30T02:25:38.000Z","updated":"2017-10-30T02:25:38.000Z","path":"2.10/examples/arbitrary_extra_arguments.html","_id":"cj9dk90dc0006iapwusaopz0b","comments":1,"layout":"page","content":"<p>It is common practice to accept additional positional arguments at command line, rather than option flags. For example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ myapp some-command some-argument --foo=bar</div></pre></td></tr></table></figure>\n<p>In the above, <code>some-command</code> would be the function under whatever controller it is exposed from, and some-argument would be just an arbitrary argument. In most cases, the argument within the code is generic, but its uses vary. For example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ myapp create-user john.doe</div><div class=\"line\"></div><div class=\"line\">$ myapp create-group admins</div></pre></td></tr></table></figure>\n<p>In the above, the sub-commands are create-user and create-group, and in this use case they are under the same controller. The argument however differs for each command, though it is passed to the app the same (the first positional argument, that is not a controller/command).</p>\n<p>The following example outlines how you might handle arbitrary (or generic) positional arguments.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MySecondController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'second'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        description = <span class=\"string\">'this is the second controller namespace'</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'-f'</span>, <span class=\"string\">'--foo'</span>],</div><div class=\"line\">             dict(help=<span class=\"string\">'the notorious foo option'</span>, action=<span class=\"string\">'store'</span>)),</div><div class=\"line\">            ([<span class=\"string\">'extra_arguments'</span>],</div><div class=\"line\">             dict(action=<span class=\"string\">'store'</span>, nargs=<span class=\"string\">'*'</span>)),</div><div class=\"line\">        ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cmd1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside MySecondController.cmd1()\"</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> self.app.pargs.extra_arguments:</div><div class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"Extra Argument 0: %s\"</span> % self.app.pargs.extra_arguments[<span class=\"number\">0</span>]</div><div class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"Extra Argument 1: %s\"</span> % self.app.pargs.extra_arguments[<span class=\"number\">1</span>]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        base_controller = <span class=\"string\">'base'</span></div><div class=\"line\">        handlers = [</div><div class=\"line\">            MyBaseController,</div><div class=\"line\">            MySecondController,</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">        app.run()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<p>And this would look something like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python argtest.py second cmd1 extra1 extra2</div><div class=\"line\">Inside MySecondController.cmd1()</div><div class=\"line\">Extra Argument 0: extra1</div><div class=\"line\">Extra Argument 1: extra2</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>It is common practice to accept additional positional arguments at command line, rather than option flags. For example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ myapp some-command some-argument --foo=bar</div></pre></td></tr></table></figure>\n<p>In the above, <code>some-command</code> would be the function under whatever controller it is exposed from, and some-argument would be just an arbitrary argument. In most cases, the argument within the code is generic, but its uses vary. For example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ myapp create-user john.doe</div><div class=\"line\"></div><div class=\"line\">$ myapp create-group admins</div></pre></td></tr></table></figure>\n<p>In the above, the sub-commands are create-user and create-group, and in this use case they are under the same controller. The argument however differs for each command, though it is passed to the app the same (the first positional argument, that is not a controller/command).</p>\n<p>The following example outlines how you might handle arbitrary (or generic) positional arguments.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyBaseController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MySecondController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'second'</span></div><div class=\"line\">        stacked_type = <span class=\"string\">'nested'</span></div><div class=\"line\">        stacked_on = <span class=\"string\">'base'</span></div><div class=\"line\">        description = <span class=\"string\">'this is the second controller namespace'</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'-f'</span>, <span class=\"string\">'--foo'</span>],</div><div class=\"line\">             dict(help=<span class=\"string\">'the notorious foo option'</span>, action=<span class=\"string\">'store'</span>)),</div><div class=\"line\">            ([<span class=\"string\">'extra_arguments'</span>],</div><div class=\"line\">             dict(action=<span class=\"string\">'store'</span>, nargs=<span class=\"string\">'*'</span>)),</div><div class=\"line\">        ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose()</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">cmd1</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"Inside MySecondController.cmd1()\"</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> self.app.pargs.extra_arguments:</div><div class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"Extra Argument 0: %s\"</span> % self.app.pargs.extra_arguments[<span class=\"number\">0</span>]</div><div class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"Extra Argument 1: %s\"</span> % self.app.pargs.extra_arguments[<span class=\"number\">1</span>]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        base_controller = <span class=\"string\">'base'</span></div><div class=\"line\">        handlers = [</div><div class=\"line\">            MyBaseController,</div><div class=\"line\">            MySecondController,</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></div><div class=\"line\">    <span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">        app.run()</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    main()</div></pre></td></tr></table></figure>\n<p>And this would look something like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python argtest.py second cmd1 extra1 extra2</div><div class=\"line\">Inside MySecondController.cmd1()</div><div class=\"line\">Extra Argument 0: extra1</div><div class=\"line\">Extra Argument 1: extra2</div></pre></td></tr></table></figure>\n"},{"title":"Auto Reload When Configuration Files Change","type":"examples","version":"2.10","order":9,"_content":"\nCement 2.5.2 added the experimental [Reload Config Extension]({{ version }}/api/ext/ext_reload_config.html#cement-ext-ext-reload-config), allowing applications built on Cement to automatically reload `app.config` any time configuration files and/or plugin configuration files are modified. Note that the `ext_reload_config` extension requires `pyinotify` and is only supported on Linux.\n\nAdditionally, the extension adds the `pre_reload_config` and `post_reload_config` hooks allowing applications to respond to the event and perform actions when config changes are detected.\n\nThe following demonstrates how this can be accomplished:\n\n```python\nfrom time import sleep\nfrom cement.core.exc import CaughtSignal\nfrom cement.core import hook\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\ndef print_foo(app):\n    print(\"Foo => %s\" % app.config.get('myapp', 'foo'))\n\n\nclass Base(CementBaseController):\n    class Meta:\n        label = 'base'\n\n    @expose(hide=True)\n    def default(self):\n        print('Inside Base.default()')\n\n        # simulate a long running process\n        while True:\n            sleep(30)\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        extensions = ['reload_config']\n        hooks = [('post_reload_config', print_foo)]\n        handlers = [Base]\n\n\nwith MyApp() as app:\n    try:\n        app.run()\n    except CaughtSignal as e:\n        # maybe do something... but catch it regardless so app.close() is\n        # called when exiting `with` cleanly.\n        print(e)\n```\n\nThe output looks something like:\n\n```\n$ python myapp.py --debug\n\nInside Base.default()\n\n2015-05-12 19:05:34,372 (DEBUG) cement.ext.ext_reload_config : config path modified: mask=IN_CLOSE_WRITE, path=/home/vagrant/.myapp.conf\n2015-05-12 19:05:34,373 (DEBUG) cement.core.config : config file '/home/vagrant/.myapp.conf' exists, loading settings...\n2015-05-12 19:05:34,373 (DEBUG) cement.core.hook : running hook 'post_reload_config' (<function print_foo at 0x7f6b4d401b70>) from __main__\nFoo => bar1\n\n2015-05-12 19:05:44,121 (DEBUG) cement.ext.ext_reload_config : config path modified: mask=IN_CLOSE_WRITE, path=/home/vagrant/.myapp.conf\n2015-05-12 19:05:44,122 (DEBUG) cement.core.config : config file '/home/vagrant/.myapp.conf' exists, loading settings...\n2015-05-12 19:05:44,122 (DEBUG) cement.core.hook : running hook 'post_reload_config' (<function print_foo at 0x7f6b4d401b70>) from __main__\nFoo => bar2\n```\n","source":"2.10/examples/reload_config.md","raw":"---\ntitle: Auto Reload When Configuration Files Change\ntype: examples\nversion: \"2.10\"\norder: 9\n---\n\nCement 2.5.2 added the experimental [Reload Config Extension]({{ version }}/api/ext/ext_reload_config.html#cement-ext-ext-reload-config), allowing applications built on Cement to automatically reload `app.config` any time configuration files and/or plugin configuration files are modified. Note that the `ext_reload_config` extension requires `pyinotify` and is only supported on Linux.\n\nAdditionally, the extension adds the `pre_reload_config` and `post_reload_config` hooks allowing applications to respond to the event and perform actions when config changes are detected.\n\nThe following demonstrates how this can be accomplished:\n\n```python\nfrom time import sleep\nfrom cement.core.exc import CaughtSignal\nfrom cement.core import hook\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\n\ndef print_foo(app):\n    print(\"Foo => %s\" % app.config.get('myapp', 'foo'))\n\n\nclass Base(CementBaseController):\n    class Meta:\n        label = 'base'\n\n    @expose(hide=True)\n    def default(self):\n        print('Inside Base.default()')\n\n        # simulate a long running process\n        while True:\n            sleep(30)\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        extensions = ['reload_config']\n        hooks = [('post_reload_config', print_foo)]\n        handlers = [Base]\n\n\nwith MyApp() as app:\n    try:\n        app.run()\n    except CaughtSignal as e:\n        # maybe do something... but catch it regardless so app.close() is\n        # called when exiting `with` cleanly.\n        print(e)\n```\n\nThe output looks something like:\n\n```\n$ python myapp.py --debug\n\nInside Base.default()\n\n2015-05-12 19:05:34,372 (DEBUG) cement.ext.ext_reload_config : config path modified: mask=IN_CLOSE_WRITE, path=/home/vagrant/.myapp.conf\n2015-05-12 19:05:34,373 (DEBUG) cement.core.config : config file '/home/vagrant/.myapp.conf' exists, loading settings...\n2015-05-12 19:05:34,373 (DEBUG) cement.core.hook : running hook 'post_reload_config' (<function print_foo at 0x7f6b4d401b70>) from __main__\nFoo => bar1\n\n2015-05-12 19:05:44,121 (DEBUG) cement.ext.ext_reload_config : config path modified: mask=IN_CLOSE_WRITE, path=/home/vagrant/.myapp.conf\n2015-05-12 19:05:44,122 (DEBUG) cement.core.config : config file '/home/vagrant/.myapp.conf' exists, loading settings...\n2015-05-12 19:05:44,122 (DEBUG) cement.core.hook : running hook 'post_reload_config' (<function print_foo at 0x7f6b4d401b70>) from __main__\nFoo => bar2\n```\n","date":"2017-10-30T02:29:21.000Z","updated":"2017-10-30T02:29:21.000Z","path":"2.10/examples/reload_config.html","_id":"cj9dkcqbw0007iapwq9lpawp5","comments":1,"layout":"page","content":"<p>Cement 2.5.2 added the experimental <a href=\"!--￼2--&gt;/api/ext/ext_reload_config.html#cement-ext-ext-reload-config\">Reload Config Extension</a>, allowing applications built on Cement to automatically reload <code>app.config</code> any time configuration files and/or plugin configuration files are modified. Note that the <code>ext_reload_config</code> extension requires <code>pyinotify</code> and is only supported on Linux.</p>\n<p>Additionally, the extension adds the <code>pre_reload_config</code> and <code>post_reload_config</code> hooks allowing applications to respond to the event and perform actions when config changes are detected.</p>\n<p>The following demonstrates how this can be accomplished:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.exc <span class=\"keyword\">import</span> CaughtSignal</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> hook</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_foo</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">\"Foo =&gt; %s\"</span> % app.config.get(<span class=\"string\">'myapp'</span>, <span class=\"string\">'foo'</span>))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'Inside Base.default()'</span>)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># simulate a long running process</span></div><div class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</div><div class=\"line\">            sleep(<span class=\"number\">30</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [<span class=\"string\">'reload_config'</span>]</div><div class=\"line\">        hooks = [(<span class=\"string\">'post_reload_config'</span>, print_foo)]</div><div class=\"line\">        handlers = [Base]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        app.run()</div><div class=\"line\">    <span class=\"keyword\">except</span> CaughtSignal <span class=\"keyword\">as</span> e:</div><div class=\"line\">        <span class=\"comment\"># maybe do something... but catch it regardless so app.close() is</span></div><div class=\"line\">        <span class=\"comment\"># called when exiting `with` cleanly.</span></div><div class=\"line\">        print(e)</div></pre></td></tr></table></figure>\n<p>The output looks something like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --debug</div><div class=\"line\"></div><div class=\"line\">Inside Base.default()</div><div class=\"line\"></div><div class=\"line\">2015-05-12 19:05:34,372 (DEBUG) cement.ext.ext_reload_config : config path modified: mask=IN_CLOSE_WRITE, path=/home/vagrant/.myapp.conf</div><div class=\"line\">2015-05-12 19:05:34,373 (DEBUG) cement.core.config : config file &apos;/home/vagrant/.myapp.conf&apos; exists, loading settings...</div><div class=\"line\">2015-05-12 19:05:34,373 (DEBUG) cement.core.hook : running hook &apos;post_reload_config&apos; (&lt;function print_foo at 0x7f6b4d401b70&gt;) from __main__</div><div class=\"line\">Foo =&gt; bar1</div><div class=\"line\"></div><div class=\"line\">2015-05-12 19:05:44,121 (DEBUG) cement.ext.ext_reload_config : config path modified: mask=IN_CLOSE_WRITE, path=/home/vagrant/.myapp.conf</div><div class=\"line\">2015-05-12 19:05:44,122 (DEBUG) cement.core.config : config file &apos;/home/vagrant/.myapp.conf&apos; exists, loading settings...</div><div class=\"line\">2015-05-12 19:05:44,122 (DEBUG) cement.core.hook : running hook &apos;post_reload_config&apos; (&lt;function print_foo at 0x7f6b4d401b70&gt;) from __main__</div><div class=\"line\">Foo =&gt; bar2</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>Cement 2.5.2 added the experimental <a href=\"!--￼2--&gt;/api/ext/ext_reload_config.html#cement-ext-ext-reload-config\">Reload Config Extension</a>, allowing applications built on Cement to automatically reload <code>app.config</code> any time configuration files and/or plugin configuration files are modified. Note that the <code>ext_reload_config</code> extension requires <code>pyinotify</code> and is only supported on Linux.</p>\n<p>Additionally, the extension adds the <code>pre_reload_config</code> and <code>post_reload_config</code> hooks allowing applications to respond to the event and perform actions when config changes are detected.</p>\n<p>The following demonstrates how this can be accomplished:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.exc <span class=\"keyword\">import</span> CaughtSignal</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core <span class=\"keyword\">import</span> hook</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_foo</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">\"Foo =&gt; %s\"</span> % app.config.get(<span class=\"string\">'myapp'</span>, <span class=\"string\">'foo'</span>))</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'Inside Base.default()'</span>)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># simulate a long running process</span></div><div class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</div><div class=\"line\">            sleep(<span class=\"number\">30</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [<span class=\"string\">'reload_config'</span>]</div><div class=\"line\">        hooks = [(<span class=\"string\">'post_reload_config'</span>, print_foo)]</div><div class=\"line\">        handlers = [Base]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"keyword\">try</span>:</div><div class=\"line\">        app.run()</div><div class=\"line\">    <span class=\"keyword\">except</span> CaughtSignal <span class=\"keyword\">as</span> e:</div><div class=\"line\">        <span class=\"comment\"># maybe do something... but catch it regardless so app.close() is</span></div><div class=\"line\">        <span class=\"comment\"># called when exiting `with` cleanly.</span></div><div class=\"line\">        print(e)</div></pre></td></tr></table></figure>\n<p>The output looks something like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py --debug</div><div class=\"line\"></div><div class=\"line\">Inside Base.default()</div><div class=\"line\"></div><div class=\"line\">2015-05-12 19:05:34,372 (DEBUG) cement.ext.ext_reload_config : config path modified: mask=IN_CLOSE_WRITE, path=/home/vagrant/.myapp.conf</div><div class=\"line\">2015-05-12 19:05:34,373 (DEBUG) cement.core.config : config file &apos;/home/vagrant/.myapp.conf&apos; exists, loading settings...</div><div class=\"line\">2015-05-12 19:05:34,373 (DEBUG) cement.core.hook : running hook &apos;post_reload_config&apos; (&lt;function print_foo at 0x7f6b4d401b70&gt;) from __main__</div><div class=\"line\">Foo =&gt; bar1</div><div class=\"line\"></div><div class=\"line\">2015-05-12 19:05:44,121 (DEBUG) cement.ext.ext_reload_config : config path modified: mask=IN_CLOSE_WRITE, path=/home/vagrant/.myapp.conf</div><div class=\"line\">2015-05-12 19:05:44,122 (DEBUG) cement.core.config : config file &apos;/home/vagrant/.myapp.conf&apos; exists, loading settings...</div><div class=\"line\">2015-05-12 19:05:44,122 (DEBUG) cement.core.hook : running hook &apos;post_reload_config&apos; (&lt;function print_foo at 0x7f6b4d401b70&gt;) from __main__</div><div class=\"line\">Foo =&gt; bar2</div></pre></td></tr></table></figure>\n"},{"title":"Tabularized Output","type":"examples","version":"2.10","order":10,"_content":"\nUsers familiar with MySQL, PGSQL, etc find comfort in table-based output patterns. For one it adds structure, and two generally makes things much more readable. The folloiwing is an example of a simple app using the Tabulate extension:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import expose, CementBaseController\n\n\nclass MyController(CementBaseController):\n    class Meta:\n        label = 'base'\n\n    @expose(hide=True)\n    def default(self):\n        headers=['NAME', 'AGE', 'ADDRESS']\n        data=[\n            [\"Krystin Bartoletti\", 47, \"PSC 7591, Box 425, APO AP 68379\"],\n            [\"Cris Hegan\", 54, \"322 Reubin Islands, Leylabury, NC 34388\"],\n            [\"George Champlin\", 25, \"Unit 6559, Box 124, DPO AA 25518\"],\n            ]\n        self.app.render(data, headers=headers)\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        extensions = ['tabulate']\n        output_handler = 'tabulate'\n        handlers = [MyController]\n\n\nwith MyApp() as app:\n    app.run()\n```\n\nThe output looks like:\n\n```\n$ python myapp.py\n\n| NAME               |   AGE | ADDRESS                                 |\n|--------------------+-------+-----------------------------------------|\n| Krystin Bartoletti |    47 | PSC 7591, Box 425, APO AP 68379         |\n| Cris Hegan         |    54 | 322 Reubin Islands, Leylabury, NC 34388 |\n| George Champlin    |    25 | Unit 6559, Box 124, DPO AA 25518        |\n```\n","source":"2.10/examples/tabularized_output.md","raw":"---\ntitle: Tabularized Output\ntype: examples\nversion: \"2.10\"\norder: 10\n---\n\nUsers familiar with MySQL, PGSQL, etc find comfort in table-based output patterns. For one it adds structure, and two generally makes things much more readable. The folloiwing is an example of a simple app using the Tabulate extension:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import expose, CementBaseController\n\n\nclass MyController(CementBaseController):\n    class Meta:\n        label = 'base'\n\n    @expose(hide=True)\n    def default(self):\n        headers=['NAME', 'AGE', 'ADDRESS']\n        data=[\n            [\"Krystin Bartoletti\", 47, \"PSC 7591, Box 425, APO AP 68379\"],\n            [\"Cris Hegan\", 54, \"322 Reubin Islands, Leylabury, NC 34388\"],\n            [\"George Champlin\", 25, \"Unit 6559, Box 124, DPO AA 25518\"],\n            ]\n        self.app.render(data, headers=headers)\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        extensions = ['tabulate']\n        output_handler = 'tabulate'\n        handlers = [MyController]\n\n\nwith MyApp() as app:\n    app.run()\n```\n\nThe output looks like:\n\n```\n$ python myapp.py\n\n| NAME               |   AGE | ADDRESS                                 |\n|--------------------+-------+-----------------------------------------|\n| Krystin Bartoletti |    47 | PSC 7591, Box 425, APO AP 68379         |\n| Cris Hegan         |    54 | 322 Reubin Islands, Leylabury, NC 34388 |\n| George Champlin    |    25 | Unit 6559, Box 124, DPO AA 25518        |\n```\n","date":"2017-10-30T02:30:28.000Z","updated":"2017-10-30T02:30:28.000Z","path":"2.10/examples/tabularized_output.html","_id":"cj9dkgubw0008iapw7b80y0yw","comments":1,"layout":"page","content":"<p>Users familiar with MySQL, PGSQL, etc find comfort in table-based output patterns. For one it adds structure, and two generally makes things much more readable. The folloiwing is an example of a simple app using the Tabulate extension:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> expose, CementBaseController</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        headers=[<span class=\"string\">'NAME'</span>, <span class=\"string\">'AGE'</span>, <span class=\"string\">'ADDRESS'</span>]</div><div class=\"line\">        data=[</div><div class=\"line\">            [<span class=\"string\">\"Krystin Bartoletti\"</span>, <span class=\"number\">47</span>, <span class=\"string\">\"PSC 7591, Box 425, APO AP 68379\"</span>],</div><div class=\"line\">            [<span class=\"string\">\"Cris Hegan\"</span>, <span class=\"number\">54</span>, <span class=\"string\">\"322 Reubin Islands, Leylabury, NC 34388\"</span>],</div><div class=\"line\">            [<span class=\"string\">\"George Champlin\"</span>, <span class=\"number\">25</span>, <span class=\"string\">\"Unit 6559, Box 124, DPO AA 25518\"</span>],</div><div class=\"line\">            ]</div><div class=\"line\">        self.app.render(data, headers=headers)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [<span class=\"string\">'tabulate'</span>]</div><div class=\"line\">        output_handler = <span class=\"string\">'tabulate'</span></div><div class=\"line\">        handlers = [MyController]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>The output looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\"></div><div class=\"line\">| NAME               |   AGE | ADDRESS                                 |</div><div class=\"line\">|--------------------+-------+-----------------------------------------|</div><div class=\"line\">| Krystin Bartoletti |    47 | PSC 7591, Box 425, APO AP 68379         |</div><div class=\"line\">| Cris Hegan         |    54 | 322 Reubin Islands, Leylabury, NC 34388 |</div><div class=\"line\">| George Champlin    |    25 | Unit 6559, Box 124, DPO AA 25518        |</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>Users familiar with MySQL, PGSQL, etc find comfort in table-based output patterns. For one it adds structure, and two generally makes things much more readable. The folloiwing is an example of a simple app using the Tabulate extension:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> expose, CementBaseController</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        headers=[<span class=\"string\">'NAME'</span>, <span class=\"string\">'AGE'</span>, <span class=\"string\">'ADDRESS'</span>]</div><div class=\"line\">        data=[</div><div class=\"line\">            [<span class=\"string\">\"Krystin Bartoletti\"</span>, <span class=\"number\">47</span>, <span class=\"string\">\"PSC 7591, Box 425, APO AP 68379\"</span>],</div><div class=\"line\">            [<span class=\"string\">\"Cris Hegan\"</span>, <span class=\"number\">54</span>, <span class=\"string\">\"322 Reubin Islands, Leylabury, NC 34388\"</span>],</div><div class=\"line\">            [<span class=\"string\">\"George Champlin\"</span>, <span class=\"number\">25</span>, <span class=\"string\">\"Unit 6559, Box 124, DPO AA 25518\"</span>],</div><div class=\"line\">            ]</div><div class=\"line\">        self.app.render(data, headers=headers)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [<span class=\"string\">'tabulate'</span>]</div><div class=\"line\">        output_handler = <span class=\"string\">'tabulate'</span></div><div class=\"line\">        handlers = [MyController]</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p>The output looks like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\"></div><div class=\"line\">| NAME               |   AGE | ADDRESS                                 |</div><div class=\"line\">|--------------------+-------+-----------------------------------------|</div><div class=\"line\">| Krystin Bartoletti |    47 | PSC 7591, Box 425, APO AP 68379         |</div><div class=\"line\">| Cris Hegan         |    54 | 322 Reubin Islands, Leylabury, NC 34388 |</div><div class=\"line\">| George Champlin    |    25 | Unit 6559, Box 124, DPO AA 25518        |</div></pre></td></tr></table></figure>\n"},{"title":"Reload App on SIGHUP","type":"examples","version":"2.10","order":11,"_content":"\nA common convention in the Linux world is to handle a SIGHUP signal, by reloading the current runtime within the same process ID (pid). The following example demonstrates how you might achieve that:\n\n```python\nimport signal\nfrom time import sleep\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\nfrom cement.core.exc import CaughtSignal\n\n\nclass MyController(CementBaseController):\n    class Meta:\n        label = 'base'\n\n    @expose(hide=True)\n    def default(self):\n        print('Inside MyController.default()')\n\n        ### inner loop where the application logic happens\n        while True:\n            print('Inside Inner Loop')\n            sleep(5)\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        base_controller = MyController\n\n\nwith MyApp() as app:\n    ### outer loop where signals are handles, and application reload\n    ### happens\n\n    keep_alive = True\n    while keep_alive is True:\n        try:\n            app.run()\n        except CaughtSignal as e:\n            app.log.warning(e.msg)\n            if e.signum in [signal.SIGHUP]:\n                app.log.warning('Reloading MyApp')\n                app.reload()\n                keep_alive = True\n            else:\n                app.exit_code = 1\n                keep_alive = False\n```\n\nRunning the application shows the inner loop in action:\n\n```\n$ python myapp.py\nInside MyController.default()\nInside Inner Loop\nInside Inner Loop\nInside Inner Loop\nInside Inner Loop\nInside Inner Loop\nInside Inner Loop\nInside Inner Loop\n```\n\n\nIf we grab the PID in another terminal, and send it a SIGHUP signal we can see it reload:\n\n```\n$ ps | grep [m]yapp\n1317    python myapp.py\n\n$ kill -HUP 1317\n```\n\nIn the original terminal (running our app) we see that the app reloads and the inner loop continues:\n\n```\nCaught signal 1\nWARNING: Reloading myapp\nInside MyController.default()\nInside Inner Loop\nInside Inner Loop\n```\n\nHowever, the PID remains the same:\n\n```\n$ ps | grep [m]yapp\n1317    python myapp.py\n```\n\nIf you’d like to see even more detail on what Cement is doing during the reload try adding `--debug`.\n","source":"2.10/examples/sighup_reload.md","raw":"---\ntitle: Reload App on SIGHUP\ntype: examples\nversion: \"2.10\"\norder: 11\n---\n\nA common convention in the Linux world is to handle a SIGHUP signal, by reloading the current runtime within the same process ID (pid). The following example demonstrates how you might achieve that:\n\n```python\nimport signal\nfrom time import sleep\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\nfrom cement.core.exc import CaughtSignal\n\n\nclass MyController(CementBaseController):\n    class Meta:\n        label = 'base'\n\n    @expose(hide=True)\n    def default(self):\n        print('Inside MyController.default()')\n\n        ### inner loop where the application logic happens\n        while True:\n            print('Inside Inner Loop')\n            sleep(5)\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        base_controller = MyController\n\n\nwith MyApp() as app:\n    ### outer loop where signals are handles, and application reload\n    ### happens\n\n    keep_alive = True\n    while keep_alive is True:\n        try:\n            app.run()\n        except CaughtSignal as e:\n            app.log.warning(e.msg)\n            if e.signum in [signal.SIGHUP]:\n                app.log.warning('Reloading MyApp')\n                app.reload()\n                keep_alive = True\n            else:\n                app.exit_code = 1\n                keep_alive = False\n```\n\nRunning the application shows the inner loop in action:\n\n```\n$ python myapp.py\nInside MyController.default()\nInside Inner Loop\nInside Inner Loop\nInside Inner Loop\nInside Inner Loop\nInside Inner Loop\nInside Inner Loop\nInside Inner Loop\n```\n\n\nIf we grab the PID in another terminal, and send it a SIGHUP signal we can see it reload:\n\n```\n$ ps | grep [m]yapp\n1317    python myapp.py\n\n$ kill -HUP 1317\n```\n\nIn the original terminal (running our app) we see that the app reloads and the inner loop continues:\n\n```\nCaught signal 1\nWARNING: Reloading myapp\nInside MyController.default()\nInside Inner Loop\nInside Inner Loop\n```\n\nHowever, the PID remains the same:\n\n```\n$ ps | grep [m]yapp\n1317    python myapp.py\n```\n\nIf you’d like to see even more detail on what Cement is doing during the reload try adding `--debug`.\n","date":"2017-10-30T02:35:22.000Z","updated":"2017-10-30T02:35:22.000Z","path":"2.10/examples/sighup_reload.html","_id":"cj9dkip5h0009iapwlxfru0od","comments":1,"layout":"page","content":"<p>A common convention in the Linux world is to handle a SIGHUP signal, by reloading the current runtime within the same process ID (pid). The following example demonstrates how you might achieve that:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> signal</div><div class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.exc <span class=\"keyword\">import</span> CaughtSignal</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'Inside MyController.default()'</span>)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">### inner loop where the application logic happens</span></div><div class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</div><div class=\"line\">            print(<span class=\"string\">'Inside Inner Loop'</span>)</div><div class=\"line\">            sleep(<span class=\"number\">5</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        base_controller = MyController</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\">### outer loop where signals are handles, and application reload</span></div><div class=\"line\">    <span class=\"comment\">### happens</span></div><div class=\"line\"></div><div class=\"line\">    keep_alive = <span class=\"keyword\">True</span></div><div class=\"line\">    <span class=\"keyword\">while</span> keep_alive <span class=\"keyword\">is</span> <span class=\"keyword\">True</span>:</div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            app.run()</div><div class=\"line\">        <span class=\"keyword\">except</span> CaughtSignal <span class=\"keyword\">as</span> e:</div><div class=\"line\">            app.log.warning(e.msg)</div><div class=\"line\">            <span class=\"keyword\">if</span> e.signum <span class=\"keyword\">in</span> [signal.SIGHUP]:</div><div class=\"line\">                app.log.warning(<span class=\"string\">'Reloading MyApp'</span>)</div><div class=\"line\">                app.reload()</div><div class=\"line\">                keep_alive = <span class=\"keyword\">True</span></div><div class=\"line\">            <span class=\"keyword\">else</span>:</div><div class=\"line\">                app.exit_code = <span class=\"number\">1</span></div><div class=\"line\">                keep_alive = <span class=\"keyword\">False</span></div></pre></td></tr></table></figure>\n<p>Running the application shows the inner loop in action:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">Inside MyController.default()</div><div class=\"line\">Inside Inner Loop</div><div class=\"line\">Inside Inner Loop</div><div class=\"line\">Inside Inner Loop</div><div class=\"line\">Inside Inner Loop</div><div class=\"line\">Inside Inner Loop</div><div class=\"line\">Inside Inner Loop</div><div class=\"line\">Inside Inner Loop</div></pre></td></tr></table></figure>\n<p>If we grab the PID in another terminal, and send it a SIGHUP signal we can see it reload:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ ps | grep [m]yapp</div><div class=\"line\">1317    python myapp.py</div><div class=\"line\"></div><div class=\"line\">$ kill -HUP 1317</div></pre></td></tr></table></figure>\n<p>In the original terminal (running our app) we see that the app reloads and the inner loop continues:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Caught signal 1</div><div class=\"line\">WARNING: Reloading myapp</div><div class=\"line\">Inside MyController.default()</div><div class=\"line\">Inside Inner Loop</div><div class=\"line\">Inside Inner Loop</div></pre></td></tr></table></figure>\n<p>However, the PID remains the same:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ ps | grep [m]yapp</div><div class=\"line\">1317    python myapp.py</div></pre></td></tr></table></figure>\n<p>If you’d like to see even more detail on what Cement is doing during the reload try adding <code>--debug</code>.</p>\n","excerpt":"","more":"<p>A common convention in the Linux world is to handle a SIGHUP signal, by reloading the current runtime within the same process ID (pid). The following example demonstrates how you might achieve that:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">import</span> signal</div><div class=\"line\"><span class=\"keyword\">from</span> time <span class=\"keyword\">import</span> sleep</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.exc <span class=\"keyword\">import</span> CaughtSignal</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'Inside MyController.default()'</span>)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">### inner loop where the application logic happens</span></div><div class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</div><div class=\"line\">            print(<span class=\"string\">'Inside Inner Loop'</span>)</div><div class=\"line\">            sleep(<span class=\"number\">5</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        base_controller = MyController</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    <span class=\"comment\">### outer loop where signals are handles, and application reload</span></div><div class=\"line\">    <span class=\"comment\">### happens</span></div><div class=\"line\"></div><div class=\"line\">    keep_alive = <span class=\"keyword\">True</span></div><div class=\"line\">    <span class=\"keyword\">while</span> keep_alive <span class=\"keyword\">is</span> <span class=\"keyword\">True</span>:</div><div class=\"line\">        <span class=\"keyword\">try</span>:</div><div class=\"line\">            app.run()</div><div class=\"line\">        <span class=\"keyword\">except</span> CaughtSignal <span class=\"keyword\">as</span> e:</div><div class=\"line\">            app.log.warning(e.msg)</div><div class=\"line\">            <span class=\"keyword\">if</span> e.signum <span class=\"keyword\">in</span> [signal.SIGHUP]:</div><div class=\"line\">                app.log.warning(<span class=\"string\">'Reloading MyApp'</span>)</div><div class=\"line\">                app.reload()</div><div class=\"line\">                keep_alive = <span class=\"keyword\">True</span></div><div class=\"line\">            <span class=\"keyword\">else</span>:</div><div class=\"line\">                app.exit_code = <span class=\"number\">1</span></div><div class=\"line\">                keep_alive = <span class=\"keyword\">False</span></div></pre></td></tr></table></figure>\n<p>Running the application shows the inner loop in action:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">Inside MyController.default()</div><div class=\"line\">Inside Inner Loop</div><div class=\"line\">Inside Inner Loop</div><div class=\"line\">Inside Inner Loop</div><div class=\"line\">Inside Inner Loop</div><div class=\"line\">Inside Inner Loop</div><div class=\"line\">Inside Inner Loop</div><div class=\"line\">Inside Inner Loop</div></pre></td></tr></table></figure>\n<p>If we grab the PID in another terminal, and send it a SIGHUP signal we can see it reload:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ ps | grep [m]yapp</div><div class=\"line\">1317    python myapp.py</div><div class=\"line\"></div><div class=\"line\">$ kill -HUP 1317</div></pre></td></tr></table></figure>\n<p>In the original terminal (running our app) we see that the app reloads and the inner loop continues:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Caught signal 1</div><div class=\"line\">WARNING: Reloading myapp</div><div class=\"line\">Inside MyController.default()</div><div class=\"line\">Inside Inner Loop</div><div class=\"line\">Inside Inner Loop</div></pre></td></tr></table></figure>\n<p>However, the PID remains the same:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ ps | grep [m]yapp</div><div class=\"line\">1317    python myapp.py</div></pre></td></tr></table></figure>\n<p>If you’d like to see even more detail on what Cement is doing during the reload try adding <code>--debug</code>.</p>\n"},{"title":"Managing Multiple Environments","type":"examples","version":"2.10","order":12,"_content":"\nMany applications and use-cases call for managing multiple environments and handling common settings between them. These environments might refer to infrastructure such as production, staging, or dev... or perhaps it might be to handle multiple accounts or regions within an account at a service provider.\n\nThe following example outlines one possible approach to managing multiple infrastructure accounts from an application Built on Cement:\n\n**myapp.py**\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\nfrom cement.utils.misc import init_defaults\n\n# set default settings for our different environments\ndefaults = init_defaults('myapp', 'env.production', 'env.staging', 'env.dev')\ndefaults['myapp']['default_env'] = 'production'\ndefaults['env.production']['foo'] = 'bar.production'\ndefaults['env.staging']['foo'] = 'bar.staging'\ndefaults['env.dev']['foo'] = 'bar.dev'\n\n# do this in a hook so that we can load the default from config\ndef set_default_env(app):\n    if app.pargs.env is None:\n        app.pargs.env = app.config.get('myapp', 'default_env')\n\nclass MyController(CementBaseController):\n    class Meta:\n        label = 'base'\n        arguments = [\n            (['-E', '--environment'],\n             dict(help='environment override',\n                  action='store',\n                  nargs='?',\n                  choices=['production', 'staging', 'dev'],\n                  dest='env')),\n            ]\n\n    @expose(hide=True)\n    def default(self):\n        print('Inside MyController.default()')\n\n        # shorten things up a bit for clarity\n        env_key = self.app.pargs.env\n        env = self.app.config.get_section_dict('env.%s' % env_key)\n\n        print('Current Environment: %s' % env_key)\n        print('Foo => %s' % env['foo'])\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        config_defaults = defaults\n        base_controller = MyController\n\nwith MyApp() as app:\n    app.hook.register('post_argument_parsing', set_default_env)\n    app.run()\n```\n\n**myapp.conf**\n\n```\n[myapp]\ndefault_env = production\n\n[env.production]\nfoo = bar.production\n\n[env.staging]\nfoo = bar.staging\n\n[env.dev]\nfoo = bar.dev\nThis looks like:\n```\n\nExample:\n\n```\n$ python myapp.py\nInside MyController.default()\nCurrent Environment: production\nFoo => bar.production\n\n$ python myapp.py -E staging\nInside MyController.default()\nCurrent Environment: staging\nFoo => bar.staging\n\n$ python myapp.py -E dev\nInside MyController.default()\nCurrent Environment: dev\nFoo => bar.dev\n```\n\nThe idea being that you can maintain a single set of operations, but modify what or where those operations happen by simply toggling the configuration section (that has the same configuration settings per environment).\n","source":"2.10/examples/managing_multiple_environments.md","raw":"---\ntitle: Managing Multiple Environments\ntype: examples\nversion: \"2.10\"\norder: 12\n---\n\nMany applications and use-cases call for managing multiple environments and handling common settings between them. These environments might refer to infrastructure such as production, staging, or dev... or perhaps it might be to handle multiple accounts or regions within an account at a service provider.\n\nThe following example outlines one possible approach to managing multiple infrastructure accounts from an application Built on Cement:\n\n**myapp.py**\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.core.controller import CementBaseController, expose\nfrom cement.utils.misc import init_defaults\n\n# set default settings for our different environments\ndefaults = init_defaults('myapp', 'env.production', 'env.staging', 'env.dev')\ndefaults['myapp']['default_env'] = 'production'\ndefaults['env.production']['foo'] = 'bar.production'\ndefaults['env.staging']['foo'] = 'bar.staging'\ndefaults['env.dev']['foo'] = 'bar.dev'\n\n# do this in a hook so that we can load the default from config\ndef set_default_env(app):\n    if app.pargs.env is None:\n        app.pargs.env = app.config.get('myapp', 'default_env')\n\nclass MyController(CementBaseController):\n    class Meta:\n        label = 'base'\n        arguments = [\n            (['-E', '--environment'],\n             dict(help='environment override',\n                  action='store',\n                  nargs='?',\n                  choices=['production', 'staging', 'dev'],\n                  dest='env')),\n            ]\n\n    @expose(hide=True)\n    def default(self):\n        print('Inside MyController.default()')\n\n        # shorten things up a bit for clarity\n        env_key = self.app.pargs.env\n        env = self.app.config.get_section_dict('env.%s' % env_key)\n\n        print('Current Environment: %s' % env_key)\n        print('Foo => %s' % env['foo'])\n\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        config_defaults = defaults\n        base_controller = MyController\n\nwith MyApp() as app:\n    app.hook.register('post_argument_parsing', set_default_env)\n    app.run()\n```\n\n**myapp.conf**\n\n```\n[myapp]\ndefault_env = production\n\n[env.production]\nfoo = bar.production\n\n[env.staging]\nfoo = bar.staging\n\n[env.dev]\nfoo = bar.dev\nThis looks like:\n```\n\nExample:\n\n```\n$ python myapp.py\nInside MyController.default()\nCurrent Environment: production\nFoo => bar.production\n\n$ python myapp.py -E staging\nInside MyController.default()\nCurrent Environment: staging\nFoo => bar.staging\n\n$ python myapp.py -E dev\nInside MyController.default()\nCurrent Environment: dev\nFoo => bar.dev\n```\n\nThe idea being that you can maintain a single set of operations, but modify what or where those operations happen by simply toggling the configuration section (that has the same configuration settings per environment).\n","date":"2017-10-30T02:37:41.000Z","updated":"2017-10-30T02:37:41.000Z","path":"2.10/examples/managing_multiple_environments.html","_id":"cj9dkoi0h000aiapwgdm914mp","comments":1,"layout":"page","content":"<p>Many applications and use-cases call for managing multiple environments and handling common settings between them. These environments might refer to infrastructure such as production, staging, or dev… or perhaps it might be to handle multiple accounts or regions within an account at a service provider.</p>\n<p>The following example outlines one possible approach to managing multiple infrastructure accounts from an application Built on Cement:</p>\n<p><strong>myapp.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># set default settings for our different environments</span></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>, <span class=\"string\">'env.production'</span>, <span class=\"string\">'env.staging'</span>, <span class=\"string\">'env.dev'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'myapp'</span>][<span class=\"string\">'default_env'</span>] = <span class=\"string\">'production'</span></div><div class=\"line\">defaults[<span class=\"string\">'env.production'</span>][<span class=\"string\">'foo'</span>] = <span class=\"string\">'bar.production'</span></div><div class=\"line\">defaults[<span class=\"string\">'env.staging'</span>][<span class=\"string\">'foo'</span>] = <span class=\"string\">'bar.staging'</span></div><div class=\"line\">defaults[<span class=\"string\">'env.dev'</span>][<span class=\"string\">'foo'</span>] = <span class=\"string\">'bar.dev'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># do this in a hook so that we can load the default from config</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_default_env</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> app.pargs.env <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">        app.pargs.env = app.config.get(<span class=\"string\">'myapp'</span>, <span class=\"string\">'default_env'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'-E'</span>, <span class=\"string\">'--environment'</span>],</div><div class=\"line\">             dict(help=<span class=\"string\">'environment override'</span>,</div><div class=\"line\">                  action=<span class=\"string\">'store'</span>,</div><div class=\"line\">                  nargs=<span class=\"string\">'?'</span>,</div><div class=\"line\">                  choices=[<span class=\"string\">'production'</span>, <span class=\"string\">'staging'</span>, <span class=\"string\">'dev'</span>],</div><div class=\"line\">                  dest=<span class=\"string\">'env'</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'Inside MyController.default()'</span>)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># shorten things up a bit for clarity</span></div><div class=\"line\">        env_key = self.app.pargs.env</div><div class=\"line\">        env = self.app.config.get_section_dict(<span class=\"string\">'env.%s'</span> % env_key)</div><div class=\"line\"></div><div class=\"line\">        print(<span class=\"string\">'Current Environment: %s'</span> % env_key)</div><div class=\"line\">        print(<span class=\"string\">'Foo =&gt; %s'</span> % env[<span class=\"string\">'foo'</span>])</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        config_defaults = defaults</div><div class=\"line\">        base_controller = MyController</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.hook.register(<span class=\"string\">'post_argument_parsing'</span>, set_default_env)</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p><strong>myapp.conf</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">default_env = production</div><div class=\"line\"></div><div class=\"line\">[env.production]</div><div class=\"line\">foo = bar.production</div><div class=\"line\"></div><div class=\"line\">[env.staging]</div><div class=\"line\">foo = bar.staging</div><div class=\"line\"></div><div class=\"line\">[env.dev]</div><div class=\"line\">foo = bar.dev</div><div class=\"line\">This looks like:</div></pre></td></tr></table></figure>\n<p>Example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">Inside MyController.default()</div><div class=\"line\">Current Environment: production</div><div class=\"line\">Foo =&gt; bar.production</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py -E staging</div><div class=\"line\">Inside MyController.default()</div><div class=\"line\">Current Environment: staging</div><div class=\"line\">Foo =&gt; bar.staging</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py -E dev</div><div class=\"line\">Inside MyController.default()</div><div class=\"line\">Current Environment: dev</div><div class=\"line\">Foo =&gt; bar.dev</div></pre></td></tr></table></figure>\n<p>The idea being that you can maintain a single set of operations, but modify what or where those operations happen by simply toggling the configuration section (that has the same configuration settings per environment).</p>\n","excerpt":"","more":"<p>Many applications and use-cases call for managing multiple environments and handling common settings between them. These environments might refer to infrastructure such as production, staging, or dev… or perhaps it might be to handle multiple accounts or regions within an account at a service provider.</p>\n<p>The following example outlines one possible approach to managing multiple infrastructure accounts from an application Built on Cement:</p>\n<p><strong>myapp.py</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.core.controller <span class=\"keyword\">import</span> CementBaseController, expose</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># set default settings for our different environments</span></div><div class=\"line\">defaults = init_defaults(<span class=\"string\">'myapp'</span>, <span class=\"string\">'env.production'</span>, <span class=\"string\">'env.staging'</span>, <span class=\"string\">'env.dev'</span>)</div><div class=\"line\">defaults[<span class=\"string\">'myapp'</span>][<span class=\"string\">'default_env'</span>] = <span class=\"string\">'production'</span></div><div class=\"line\">defaults[<span class=\"string\">'env.production'</span>][<span class=\"string\">'foo'</span>] = <span class=\"string\">'bar.production'</span></div><div class=\"line\">defaults[<span class=\"string\">'env.staging'</span>][<span class=\"string\">'foo'</span>] = <span class=\"string\">'bar.staging'</span></div><div class=\"line\">defaults[<span class=\"string\">'env.dev'</span>][<span class=\"string\">'foo'</span>] = <span class=\"string\">'bar.dev'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># do this in a hook so that we can load the default from config</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_default_env</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> app.pargs.env <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">        app.pargs.env = app.config.get(<span class=\"string\">'myapp'</span>, <span class=\"string\">'default_env'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyController</span><span class=\"params\">(CementBaseController)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'base'</span></div><div class=\"line\">        arguments = [</div><div class=\"line\">            ([<span class=\"string\">'-E'</span>, <span class=\"string\">'--environment'</span>],</div><div class=\"line\">             dict(help=<span class=\"string\">'environment override'</span>,</div><div class=\"line\">                  action=<span class=\"string\">'store'</span>,</div><div class=\"line\">                  nargs=<span class=\"string\">'?'</span>,</div><div class=\"line\">                  choices=[<span class=\"string\">'production'</span>, <span class=\"string\">'staging'</span>, <span class=\"string\">'dev'</span>],</div><div class=\"line\">                  dest=<span class=\"string\">'env'</span>)),</div><div class=\"line\">            ]</div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">    @expose(hide=True)</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">default</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\">        print(<span class=\"string\">'Inside MyController.default()'</span>)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\"># shorten things up a bit for clarity</span></div><div class=\"line\">        env_key = self.app.pargs.env</div><div class=\"line\">        env = self.app.config.get_section_dict(<span class=\"string\">'env.%s'</span> % env_key)</div><div class=\"line\"></div><div class=\"line\">        print(<span class=\"string\">'Current Environment: %s'</span> % env_key)</div><div class=\"line\">        print(<span class=\"string\">'Foo =&gt; %s'</span> % env[<span class=\"string\">'foo'</span>])</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        config_defaults = defaults</div><div class=\"line\">        base_controller = MyController</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">with</span> MyApp() <span class=\"keyword\">as</span> app:</div><div class=\"line\">    app.hook.register(<span class=\"string\">'post_argument_parsing'</span>, set_default_env)</div><div class=\"line\">    app.run()</div></pre></td></tr></table></figure>\n<p><strong>myapp.conf</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">[myapp]</div><div class=\"line\">default_env = production</div><div class=\"line\"></div><div class=\"line\">[env.production]</div><div class=\"line\">foo = bar.production</div><div class=\"line\"></div><div class=\"line\">[env.staging]</div><div class=\"line\">foo = bar.staging</div><div class=\"line\"></div><div class=\"line\">[env.dev]</div><div class=\"line\">foo = bar.dev</div><div class=\"line\">This looks like:</div></pre></td></tr></table></figure>\n<p>Example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">$ python myapp.py</div><div class=\"line\">Inside MyController.default()</div><div class=\"line\">Current Environment: production</div><div class=\"line\">Foo =&gt; bar.production</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py -E staging</div><div class=\"line\">Inside MyController.default()</div><div class=\"line\">Current Environment: staging</div><div class=\"line\">Foo =&gt; bar.staging</div><div class=\"line\"></div><div class=\"line\">$ python myapp.py -E dev</div><div class=\"line\">Inside MyController.default()</div><div class=\"line\">Current Environment: dev</div><div class=\"line\">Foo =&gt; bar.dev</div></pre></td></tr></table></figure>\n<p>The idea being that you can maintain a single set of operations, but modify what or where those operations happen by simply toggling the configuration section (that has the same configuration settings per environment).</p>\n"},{"type":"examples","version":"2.10","order":1,"_content":"\n# Examples\n\nSee the list on the left side panel for examples of common use-cases, and the more complex edge-cases that we've had requests for in the past.\n","source":"2.10/examples/index.md","raw":"---\n\ntype: examples\nversion: \"2.10\"\norder: 1\n---\n\n# Examples\n\nSee the list on the left side panel for examples of common use-cases, and the more complex edge-cases that we've had requests for in the past.\n","date":"2017-10-30T04:47:09.000Z","updated":"2017-10-30T04:47:09.000Z","path":"2.10/examples/index.html","_id":"cj9dkv1rz000biapw9c0xy3ot","title":"","comments":1,"layout":"page","content":"<h1 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h1><p>See the list on the left side panel for examples of common use-cases, and the more complex edge-cases that we’ve had requests for in the past.</p>\n","excerpt":"","more":"<h1 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h1><p>See the list on the left side panel for examples of common use-cases, and the more complex edge-cases that we’ve had requests for in the past.</p>\n"},{"title":"Release Information","type":"guide","version":"2.10","order":2,"_content":"\n## What's New!\n\n### Support for Multiple File Plugin Directories\n\nPrior to Cement 2.10, application plugins were only supported as single files such as `myplugin.py`.  Plugins can now be a single file, or full python  modules like `myplugin/__init__.py`.\n\nAn example plugin might look like:\n\n```\nmyplugin/\n    __init__.py\n    controllers.py\n    templates/\n        cmd1.mustache\n        cmd2.mustache\n        cmd3.mustache\n```\n\nThe only thing required in a plugin is that it supply a `load()` function either in a `myplugin.py` or `myplugin/__init__.py`.  The rest is up to the developer.\n\nSee [Application Plugins](/2.10/dev/application_plugins) for more information.\n\nRelated:\n\n- Issue 350\n\n\n### Cross Platform Filesystem Event Monitoring via Watchdog\n\nApplications can now monitor, and react to, filesystem events with a very easy wrapper around the `Watchdog <https://pypi.python.org/pypi/watchdog>`_ library.  The extension makes it possible to add a list of directories to monitor, and link them with the class to handle any events while automating the proper setup, and teardown of the backend observer.\n\nThe Watchdog Extension will make it possible in future releases to properly handle reloading a running application any time configuration files are modified (partially implemented by the `reload_config` extension that has limitations and does not support reloading the app).  Another common use case is the ability to reload a long running process any time source files are modified which will be useful for development when working on daemon-like apps so that the developer doesn't need to stop/start everytime changes are made.\n\nSee the [Watchdog Extension](/2.10/api/cement.ext.ext_watchdog) for more information.\n\nRelated:\n\n- Issue 326\n- Issue 394\n\n\n### Ability To Pass Meta Defaults From `CementApp.Meta` Down To Handlers\n\nCement handlers are often referenced by their label, and not passed as pre-instantiated objects which requires the framework to instantiate them dynamically with no keyword arguments.\n\nFor example:\n\n```python\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        extensions = ['json']\n```\n\nIn the above, Cement will load the `json` extension, which registers `JsonOutputHandler`.  When it comes time to recall that handler, it is looked up as `output.json` where `output` is the handler type (interface) and `json` is the handler label.  The class is then instantiated without any arguments or keyword arguments before use.  If a developer needed to override any meta options in `JsonOutputHandler.Meta` they would **previously** have had to sub-class it.  Consider the following example, where we sub-class `JsonOutputHandler` in order to override `JsonOutputHandler.Meta.json_module`:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.ext.ext_json import JsonOutputHandler\n\nclass MyJsonOutputHandler(JsonOutputHandler):\n    class Meta:\n        json_module = 'ujson'\n\ndef override_json_output_handler(app):\n    app.handler.register(MyJsonOutputHandler, force=True)\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        extensions = ['json']\n        hooks = [\n            ('post_setup', override_json_output_handler)\n        ]\n```\n\nIf there were anything else in the `JsonOutputHandler` that the developer needed to subclass, this would be fine.  However the purpose of the above is soley to override `JsonOutputHandler.Meta.json_module`, which is tedious.\n\nAs of Cement 2.10, the above can be accomplished more-easily by the following by way of `CementApp.Meta.meta_defaults` (similar to how `config_defaults` are handled:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.utils.misc import init_defaults\n\nMETA = init_defaults('output.json')\nMETA['output.json']['json_module'] = 'ujson'\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        extensions = ['json']\n        output_handler = 'json'\n        meta_defaults = META\n```\n\nWhen `JsonOutputHandler` is instantiated, the defaults from `META['output.json']` will be passed as `**kwargs` (overriding builtin meta options).\n\nRelated:\n\n- Issue 395\n\n\n### Additional Extensions\n\n- [Jinja2](/2.10/api/cement.ext.ext_jinja2) - Provides template based output handling using the Jinja2 templating language\n- [Redis](/2.10/api/cement.ext.ext_redis) - Provides caching support using  Redis backend\n- [Watchdog](/2.10/api/cement.ext.ext_watchdog) - Provides cross-platform filesystem event monitoring using the Watchdog library.\n- [Handlebars](/2.10/api/cement.ext.ext_handlebars) - Provides template based output handling using the Handlebars templating language\n\n\n## Upgrading\n\nThis section outlines any information and changes that might need to be made in order to update your application built on previous versions of Cement.\n\n### Upgrading from 2.8.x to 2.10.x\n\nCement 2.10 introduces a few incompatible changes from the previous 2.8 stable release, as noted in the ChangeLog.\n\nDeprecated:\n\n- `cement.core.interface.list()` - This function should no longer be used in favor of `CementApp.handler.list_types()`. It will continue to work throughout Cement 2.x, however is not compatible if `CementApp.Meta.use_backend_globals == False`.\n\nRelated:\n\n- Issue #366\n- Issue #376\n\n\n## Change History\n\n### 2.10.2 - Thu July 14, 2016\n\nBumping version due to issue with uploading to PyPi.\n\n\n### 2.10.0 - Thu July 14, 2016\n\n**Bugs**\n\n- `[test]` - `CementTestCase` does not delete temporary files/directories\n    - Issue 363\n- `[core]` - AttributeError: 'module' object has no attribute 'SIGHUP' on Windows\n    - Issue 346\n- `[core.foundation]` - `CementApp.extend()` breaks on `CementApp.reload()`\n    - Issue 352\n- `[core]` - Output handler override options dissappear\n    - Issue 366\n- `[ext]` - `JsonOutputHandler`, `YamlOutputHandler`, `MustacheOutputHandler` Do not pass keyword args down to backend render functions\n    - Issue 385\n- `[core.hook]` - `CementApp.Meta.hooks` ignored for hooks defined by extensions\n    - Issue 393\n\n**Features**\n\n- `[core.plugin]` - Support for plugin directories\n    - Issue 350\n- `[ext.handlebars]` - Handlebars templating support\n    - Issue 370\n- `[ext.jinja2]` - Jinja2 templating support\n    - Pull Request 371\n- `[compliance]` - Switch over to using Flake8 for PEP8 and style compliance\n    - Issue 373\n- `[ext.redis]` - Redis cache handler support\n    - Issue 375\n- `[core.config]` - Support for alternative config file extensions\n    - Issue 379\n- `[core.plugin]` - Support for Cython/Compiled Plugins\n    - Issue 380\n- `[ext.configobj]` - ConfigObj support for Python 3\n    - Issue 389\n- `[ext.watchdog]` - Watchdog extension for cross-platform filesystem event monitoring\n    - Issue 394\n- `[core.foundation]` - Ability to pass metadata keyword arguments to handlers via `CementApp.Meta.meta_defaults`.\n    - Issue 395\n\n**Refactoring**\n\n- `[core]` - Partially deprecated use of `imp` in favor of `importlib` on Python >= 3.1\n    - Issue 386\n- `[ext.argparse]` - ArgparseArgumentHandler should store unknown arguments\n    - Issue 390\n\n**Incompatible**\n\n- *None*\n\n**Deprecation**\n\n- `[ext.logging]` - Deprecated `LoggingLogHandler.warn()`\n    - Issue 365\n- `[core]` - Deprecated Explicit Python 3.2 Support\n    - Issue 372\n- `[core.interface]` - Deprecated ``cement.core.interface.list()``\n    - Issue 376\n","source":"2.10/release_info.md","raw":"---\ntitle: Release Information\ntype: guide\nversion: \"2.10\"\norder: 2\n---\n\n## What's New!\n\n### Support for Multiple File Plugin Directories\n\nPrior to Cement 2.10, application plugins were only supported as single files such as `myplugin.py`.  Plugins can now be a single file, or full python  modules like `myplugin/__init__.py`.\n\nAn example plugin might look like:\n\n```\nmyplugin/\n    __init__.py\n    controllers.py\n    templates/\n        cmd1.mustache\n        cmd2.mustache\n        cmd3.mustache\n```\n\nThe only thing required in a plugin is that it supply a `load()` function either in a `myplugin.py` or `myplugin/__init__.py`.  The rest is up to the developer.\n\nSee [Application Plugins](/2.10/dev/application_plugins) for more information.\n\nRelated:\n\n- Issue 350\n\n\n### Cross Platform Filesystem Event Monitoring via Watchdog\n\nApplications can now monitor, and react to, filesystem events with a very easy wrapper around the `Watchdog <https://pypi.python.org/pypi/watchdog>`_ library.  The extension makes it possible to add a list of directories to monitor, and link them with the class to handle any events while automating the proper setup, and teardown of the backend observer.\n\nThe Watchdog Extension will make it possible in future releases to properly handle reloading a running application any time configuration files are modified (partially implemented by the `reload_config` extension that has limitations and does not support reloading the app).  Another common use case is the ability to reload a long running process any time source files are modified which will be useful for development when working on daemon-like apps so that the developer doesn't need to stop/start everytime changes are made.\n\nSee the [Watchdog Extension](/2.10/api/cement.ext.ext_watchdog) for more information.\n\nRelated:\n\n- Issue 326\n- Issue 394\n\n\n### Ability To Pass Meta Defaults From `CementApp.Meta` Down To Handlers\n\nCement handlers are often referenced by their label, and not passed as pre-instantiated objects which requires the framework to instantiate them dynamically with no keyword arguments.\n\nFor example:\n\n```python\nfrom cement.core.foundation import CementApp\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        extensions = ['json']\n```\n\nIn the above, Cement will load the `json` extension, which registers `JsonOutputHandler`.  When it comes time to recall that handler, it is looked up as `output.json` where `output` is the handler type (interface) and `json` is the handler label.  The class is then instantiated without any arguments or keyword arguments before use.  If a developer needed to override any meta options in `JsonOutputHandler.Meta` they would **previously** have had to sub-class it.  Consider the following example, where we sub-class `JsonOutputHandler` in order to override `JsonOutputHandler.Meta.json_module`:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.ext.ext_json import JsonOutputHandler\n\nclass MyJsonOutputHandler(JsonOutputHandler):\n    class Meta:\n        json_module = 'ujson'\n\ndef override_json_output_handler(app):\n    app.handler.register(MyJsonOutputHandler, force=True)\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        extensions = ['json']\n        hooks = [\n            ('post_setup', override_json_output_handler)\n        ]\n```\n\nIf there were anything else in the `JsonOutputHandler` that the developer needed to subclass, this would be fine.  However the purpose of the above is soley to override `JsonOutputHandler.Meta.json_module`, which is tedious.\n\nAs of Cement 2.10, the above can be accomplished more-easily by the following by way of `CementApp.Meta.meta_defaults` (similar to how `config_defaults` are handled:\n\n```python\nfrom cement.core.foundation import CementApp\nfrom cement.utils.misc import init_defaults\n\nMETA = init_defaults('output.json')\nMETA['output.json']['json_module'] = 'ujson'\n\nclass MyApp(CementApp):\n    class Meta:\n        label = 'myapp'\n        extensions = ['json']\n        output_handler = 'json'\n        meta_defaults = META\n```\n\nWhen `JsonOutputHandler` is instantiated, the defaults from `META['output.json']` will be passed as `**kwargs` (overriding builtin meta options).\n\nRelated:\n\n- Issue 395\n\n\n### Additional Extensions\n\n- [Jinja2](/2.10/api/cement.ext.ext_jinja2) - Provides template based output handling using the Jinja2 templating language\n- [Redis](/2.10/api/cement.ext.ext_redis) - Provides caching support using  Redis backend\n- [Watchdog](/2.10/api/cement.ext.ext_watchdog) - Provides cross-platform filesystem event monitoring using the Watchdog library.\n- [Handlebars](/2.10/api/cement.ext.ext_handlebars) - Provides template based output handling using the Handlebars templating language\n\n\n## Upgrading\n\nThis section outlines any information and changes that might need to be made in order to update your application built on previous versions of Cement.\n\n### Upgrading from 2.8.x to 2.10.x\n\nCement 2.10 introduces a few incompatible changes from the previous 2.8 stable release, as noted in the ChangeLog.\n\nDeprecated:\n\n- `cement.core.interface.list()` - This function should no longer be used in favor of `CementApp.handler.list_types()`. It will continue to work throughout Cement 2.x, however is not compatible if `CementApp.Meta.use_backend_globals == False`.\n\nRelated:\n\n- Issue #366\n- Issue #376\n\n\n## Change History\n\n### 2.10.2 - Thu July 14, 2016\n\nBumping version due to issue with uploading to PyPi.\n\n\n### 2.10.0 - Thu July 14, 2016\n\n**Bugs**\n\n- `[test]` - `CementTestCase` does not delete temporary files/directories\n    - Issue 363\n- `[core]` - AttributeError: 'module' object has no attribute 'SIGHUP' on Windows\n    - Issue 346\n- `[core.foundation]` - `CementApp.extend()` breaks on `CementApp.reload()`\n    - Issue 352\n- `[core]` - Output handler override options dissappear\n    - Issue 366\n- `[ext]` - `JsonOutputHandler`, `YamlOutputHandler`, `MustacheOutputHandler` Do not pass keyword args down to backend render functions\n    - Issue 385\n- `[core.hook]` - `CementApp.Meta.hooks` ignored for hooks defined by extensions\n    - Issue 393\n\n**Features**\n\n- `[core.plugin]` - Support for plugin directories\n    - Issue 350\n- `[ext.handlebars]` - Handlebars templating support\n    - Issue 370\n- `[ext.jinja2]` - Jinja2 templating support\n    - Pull Request 371\n- `[compliance]` - Switch over to using Flake8 for PEP8 and style compliance\n    - Issue 373\n- `[ext.redis]` - Redis cache handler support\n    - Issue 375\n- `[core.config]` - Support for alternative config file extensions\n    - Issue 379\n- `[core.plugin]` - Support for Cython/Compiled Plugins\n    - Issue 380\n- `[ext.configobj]` - ConfigObj support for Python 3\n    - Issue 389\n- `[ext.watchdog]` - Watchdog extension for cross-platform filesystem event monitoring\n    - Issue 394\n- `[core.foundation]` - Ability to pass metadata keyword arguments to handlers via `CementApp.Meta.meta_defaults`.\n    - Issue 395\n\n**Refactoring**\n\n- `[core]` - Partially deprecated use of `imp` in favor of `importlib` on Python >= 3.1\n    - Issue 386\n- `[ext.argparse]` - ArgparseArgumentHandler should store unknown arguments\n    - Issue 390\n\n**Incompatible**\n\n- *None*\n\n**Deprecation**\n\n- `[ext.logging]` - Deprecated `LoggingLogHandler.warn()`\n    - Issue 365\n- `[core]` - Deprecated Explicit Python 3.2 Support\n    - Issue 372\n- `[core.interface]` - Deprecated ``cement.core.interface.list()``\n    - Issue 376\n","date":"2017-10-30T04:20:03.000Z","updated":"2017-10-30T04:20:03.000Z","path":"2.10/release_info.html","_id":"cj9dmmel5000ciapw5xhxg37q","comments":1,"layout":"page","content":"<h2 id=\"What’s-New\"><a href=\"#What’s-New\" class=\"headerlink\" title=\"What’s New!\"></a>What’s New!</h2><h3 id=\"Support-for-Multiple-File-Plugin-Directories\"><a href=\"#Support-for-Multiple-File-Plugin-Directories\" class=\"headerlink\" title=\"Support for Multiple File Plugin Directories\"></a>Support for Multiple File Plugin Directories</h3><p>Prior to Cement 2.10, application plugins were only supported as single files such as <code>myplugin.py</code>.  Plugins can now be a single file, or full python  modules like <code>myplugin/__init__.py</code>.</p>\n<p>An example plugin might look like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">myplugin/</div><div class=\"line\">    __init__.py</div><div class=\"line\">    controllers.py</div><div class=\"line\">    templates/</div><div class=\"line\">        cmd1.mustache</div><div class=\"line\">        cmd2.mustache</div><div class=\"line\">        cmd3.mustache</div></pre></td></tr></table></figure>\n<p>The only thing required in a plugin is that it supply a <code>load()</code> function either in a <code>myplugin.py</code> or <code>myplugin/__init__.py</code>.  The rest is up to the developer.</p>\n<p>See <a href=\"/2.10/dev/application_plugins\">Application Plugins</a> for more information.</p>\n<p>Related:</p>\n<ul>\n<li>Issue 350</li>\n</ul>\n<h3 id=\"Cross-Platform-Filesystem-Event-Monitoring-via-Watchdog\"><a href=\"#Cross-Platform-Filesystem-Event-Monitoring-via-Watchdog\" class=\"headerlink\" title=\"Cross Platform Filesystem Event Monitoring via Watchdog\"></a>Cross Platform Filesystem Event Monitoring via Watchdog</h3><p>Applications can now monitor, and react to, filesystem events with a very easy wrapper around the <code>Watchdog &lt;https://pypi.python.org/pypi/watchdog&gt;</code>_ library.  The extension makes it possible to add a list of directories to monitor, and link them with the class to handle any events while automating the proper setup, and teardown of the backend observer.</p>\n<p>The Watchdog Extension will make it possible in future releases to properly handle reloading a running application any time configuration files are modified (partially implemented by the <code>reload_config</code> extension that has limitations and does not support reloading the app).  Another common use case is the ability to reload a long running process any time source files are modified which will be useful for development when working on daemon-like apps so that the developer doesn’t need to stop/start everytime changes are made.</p>\n<p>See the <a href=\"/2.10/api/cement.ext.ext_watchdog\">Watchdog Extension</a> for more information.</p>\n<p>Related:</p>\n<ul>\n<li>Issue 326</li>\n<li>Issue 394</li>\n</ul>\n<h3 id=\"Ability-To-Pass-Meta-Defaults-From-CementApp-Meta-Down-To-Handlers\"><a href=\"#Ability-To-Pass-Meta-Defaults-From-CementApp-Meta-Down-To-Handlers\" class=\"headerlink\" title=\"Ability To Pass Meta Defaults From CementApp.Meta Down To Handlers\"></a>Ability To Pass Meta Defaults From <code>CementApp.Meta</code> Down To Handlers</h3><p>Cement handlers are often referenced by their label, and not passed as pre-instantiated objects which requires the framework to instantiate them dynamically with no keyword arguments.</p>\n<p>For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [<span class=\"string\">'json'</span>]</div></pre></td></tr></table></figure>\n<p>In the above, Cement will load the <code>json</code> extension, which registers <code>JsonOutputHandler</code>.  When it comes time to recall that handler, it is looked up as <code>output.json</code> where <code>output</code> is the handler type (interface) and <code>json</code> is the handler label.  The class is then instantiated without any arguments or keyword arguments before use.  If a developer needed to override any meta options in <code>JsonOutputHandler.Meta</code> they would <strong>previously</strong> have had to sub-class it.  Consider the following example, where we sub-class <code>JsonOutputHandler</code> in order to override <code>JsonOutputHandler.Meta.json_module</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.ext.ext_json <span class=\"keyword\">import</span> JsonOutputHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyJsonOutputHandler</span><span class=\"params\">(JsonOutputHandler)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        json_module = <span class=\"string\">'ujson'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">override_json_output_handler</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    app.handler.register(MyJsonOutputHandler, force=<span class=\"keyword\">True</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [<span class=\"string\">'json'</span>]</div><div class=\"line\">        hooks = [</div><div class=\"line\">            (<span class=\"string\">'post_setup'</span>, override_json_output_handler)</div><div class=\"line\">        ]</div></pre></td></tr></table></figure>\n<p>If there were anything else in the <code>JsonOutputHandler</code> that the developer needed to subclass, this would be fine.  However the purpose of the above is soley to override <code>JsonOutputHandler.Meta.json_module</code>, which is tedious.</p>\n<p>As of Cement 2.10, the above can be accomplished more-easily by the following by way of <code>CementApp.Meta.meta_defaults</code> (similar to how <code>config_defaults</code> are handled:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">META = init_defaults(<span class=\"string\">'output.json'</span>)</div><div class=\"line\">META[<span class=\"string\">'output.json'</span>][<span class=\"string\">'json_module'</span>] = <span class=\"string\">'ujson'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [<span class=\"string\">'json'</span>]</div><div class=\"line\">        output_handler = <span class=\"string\">'json'</span></div><div class=\"line\">        meta_defaults = META</div></pre></td></tr></table></figure>\n<p>When <code>JsonOutputHandler</code> is instantiated, the defaults from <code>META[&#39;output.json&#39;]</code> will be passed as <code>**kwargs</code> (overriding builtin meta options).</p>\n<p>Related:</p>\n<ul>\n<li>Issue 395</li>\n</ul>\n<h3 id=\"Additional-Extensions\"><a href=\"#Additional-Extensions\" class=\"headerlink\" title=\"Additional Extensions\"></a>Additional Extensions</h3><ul>\n<li><a href=\"/2.10/api/cement.ext.ext_jinja2\">Jinja2</a> - Provides template based output handling using the Jinja2 templating language</li>\n<li><a href=\"/2.10/api/cement.ext.ext_redis\">Redis</a> - Provides caching support using  Redis backend</li>\n<li><a href=\"/2.10/api/cement.ext.ext_watchdog\">Watchdog</a> - Provides cross-platform filesystem event monitoring using the Watchdog library.</li>\n<li><a href=\"/2.10/api/cement.ext.ext_handlebars\">Handlebars</a> - Provides template based output handling using the Handlebars templating language</li>\n</ul>\n<h2 id=\"Upgrading\"><a href=\"#Upgrading\" class=\"headerlink\" title=\"Upgrading\"></a>Upgrading</h2><p>This section outlines any information and changes that might need to be made in order to update your application built on previous versions of Cement.</p>\n<h3 id=\"Upgrading-from-2-8-x-to-2-10-x\"><a href=\"#Upgrading-from-2-8-x-to-2-10-x\" class=\"headerlink\" title=\"Upgrading from 2.8.x to 2.10.x\"></a>Upgrading from 2.8.x to 2.10.x</h3><p>Cement 2.10 introduces a few incompatible changes from the previous 2.8 stable release, as noted in the ChangeLog.</p>\n<p>Deprecated:</p>\n<ul>\n<li><code>cement.core.interface.list()</code> - This function should no longer be used in favor of <code>CementApp.handler.list_types()</code>. It will continue to work throughout Cement 2.x, however is not compatible if <code>CementApp.Meta.use_backend_globals == False</code>.</li>\n</ul>\n<p>Related:</p>\n<ul>\n<li>Issue #366</li>\n<li>Issue #376</li>\n</ul>\n<h2 id=\"Change-History\"><a href=\"#Change-History\" class=\"headerlink\" title=\"Change History\"></a>Change History</h2><h3 id=\"2-10-2-Thu-July-14-2016\"><a href=\"#2-10-2-Thu-July-14-2016\" class=\"headerlink\" title=\"2.10.2 - Thu July 14, 2016\"></a>2.10.2 - Thu July 14, 2016</h3><p>Bumping version due to issue with uploading to PyPi.</p>\n<h3 id=\"2-10-0-Thu-July-14-2016\"><a href=\"#2-10-0-Thu-July-14-2016\" class=\"headerlink\" title=\"2.10.0 - Thu July 14, 2016\"></a>2.10.0 - Thu July 14, 2016</h3><p><strong>Bugs</strong></p>\n<ul>\n<li><code>[test]</code> - <code>CementTestCase</code> does not delete temporary files/directories<ul>\n<li>Issue 363</li>\n</ul>\n</li>\n<li><code>[core]</code> - AttributeError: ‘module’ object has no attribute ‘SIGHUP’ on Windows<ul>\n<li>Issue 346</li>\n</ul>\n</li>\n<li><code>[core.foundation]</code> - <code>CementApp.extend()</code> breaks on <code>CementApp.reload()</code><ul>\n<li>Issue 352</li>\n</ul>\n</li>\n<li><code>[core]</code> - Output handler override options dissappear<ul>\n<li>Issue 366</li>\n</ul>\n</li>\n<li><code>[ext]</code> - <code>JsonOutputHandler</code>, <code>YamlOutputHandler</code>, <code>MustacheOutputHandler</code> Do not pass keyword args down to backend render functions<ul>\n<li>Issue 385</li>\n</ul>\n</li>\n<li><code>[core.hook]</code> - <code>CementApp.Meta.hooks</code> ignored for hooks defined by extensions<ul>\n<li>Issue 393</li>\n</ul>\n</li>\n</ul>\n<p><strong>Features</strong></p>\n<ul>\n<li><code>[core.plugin]</code> - Support for plugin directories<ul>\n<li>Issue 350</li>\n</ul>\n</li>\n<li><code>[ext.handlebars]</code> - Handlebars templating support<ul>\n<li>Issue 370</li>\n</ul>\n</li>\n<li><code>[ext.jinja2]</code> - Jinja2 templating support<ul>\n<li>Pull Request 371</li>\n</ul>\n</li>\n<li><code>[compliance]</code> - Switch over to using Flake8 for PEP8 and style compliance<ul>\n<li>Issue 373</li>\n</ul>\n</li>\n<li><code>[ext.redis]</code> - Redis cache handler support<ul>\n<li>Issue 375</li>\n</ul>\n</li>\n<li><code>[core.config]</code> - Support for alternative config file extensions<ul>\n<li>Issue 379</li>\n</ul>\n</li>\n<li><code>[core.plugin]</code> - Support for Cython/Compiled Plugins<ul>\n<li>Issue 380</li>\n</ul>\n</li>\n<li><code>[ext.configobj]</code> - ConfigObj support for Python 3<ul>\n<li>Issue 389</li>\n</ul>\n</li>\n<li><code>[ext.watchdog]</code> - Watchdog extension for cross-platform filesystem event monitoring<ul>\n<li>Issue 394</li>\n</ul>\n</li>\n<li><code>[core.foundation]</code> - Ability to pass metadata keyword arguments to handlers via <code>CementApp.Meta.meta_defaults</code>.<ul>\n<li>Issue 395</li>\n</ul>\n</li>\n</ul>\n<p><strong>Refactoring</strong></p>\n<ul>\n<li><code>[core]</code> - Partially deprecated use of <code>imp</code> in favor of <code>importlib</code> on Python &gt;= 3.1<ul>\n<li>Issue 386</li>\n</ul>\n</li>\n<li><code>[ext.argparse]</code> - ArgparseArgumentHandler should store unknown arguments<ul>\n<li>Issue 390</li>\n</ul>\n</li>\n</ul>\n<p><strong>Incompatible</strong></p>\n<ul>\n<li><em>None</em></li>\n</ul>\n<p><strong>Deprecation</strong></p>\n<ul>\n<li><code>[ext.logging]</code> - Deprecated <code>LoggingLogHandler.warn()</code><ul>\n<li>Issue 365</li>\n</ul>\n</li>\n<li><code>[core]</code> - Deprecated Explicit Python 3.2 Support<ul>\n<li>Issue 372</li>\n</ul>\n</li>\n<li><code>[core.interface]</code> - Deprecated <code>cement.core.interface.list()</code><ul>\n<li>Issue 376</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h2 id=\"What’s-New\"><a href=\"#What’s-New\" class=\"headerlink\" title=\"What’s New!\"></a>What’s New!</h2><h3 id=\"Support-for-Multiple-File-Plugin-Directories\"><a href=\"#Support-for-Multiple-File-Plugin-Directories\" class=\"headerlink\" title=\"Support for Multiple File Plugin Directories\"></a>Support for Multiple File Plugin Directories</h3><p>Prior to Cement 2.10, application plugins were only supported as single files such as <code>myplugin.py</code>.  Plugins can now be a single file, or full python  modules like <code>myplugin/__init__.py</code>.</p>\n<p>An example plugin might look like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">myplugin/</div><div class=\"line\">    __init__.py</div><div class=\"line\">    controllers.py</div><div class=\"line\">    templates/</div><div class=\"line\">        cmd1.mustache</div><div class=\"line\">        cmd2.mustache</div><div class=\"line\">        cmd3.mustache</div></pre></td></tr></table></figure>\n<p>The only thing required in a plugin is that it supply a <code>load()</code> function either in a <code>myplugin.py</code> or <code>myplugin/__init__.py</code>.  The rest is up to the developer.</p>\n<p>See <a href=\"/2.10/dev/application_plugins\">Application Plugins</a> for more information.</p>\n<p>Related:</p>\n<ul>\n<li>Issue 350</li>\n</ul>\n<h3 id=\"Cross-Platform-Filesystem-Event-Monitoring-via-Watchdog\"><a href=\"#Cross-Platform-Filesystem-Event-Monitoring-via-Watchdog\" class=\"headerlink\" title=\"Cross Platform Filesystem Event Monitoring via Watchdog\"></a>Cross Platform Filesystem Event Monitoring via Watchdog</h3><p>Applications can now monitor, and react to, filesystem events with a very easy wrapper around the <code>Watchdog &lt;https://pypi.python.org/pypi/watchdog&gt;</code>_ library.  The extension makes it possible to add a list of directories to monitor, and link them with the class to handle any events while automating the proper setup, and teardown of the backend observer.</p>\n<p>The Watchdog Extension will make it possible in future releases to properly handle reloading a running application any time configuration files are modified (partially implemented by the <code>reload_config</code> extension that has limitations and does not support reloading the app).  Another common use case is the ability to reload a long running process any time source files are modified which will be useful for development when working on daemon-like apps so that the developer doesn’t need to stop/start everytime changes are made.</p>\n<p>See the <a href=\"/2.10/api/cement.ext.ext_watchdog\">Watchdog Extension</a> for more information.</p>\n<p>Related:</p>\n<ul>\n<li>Issue 326</li>\n<li>Issue 394</li>\n</ul>\n<h3 id=\"Ability-To-Pass-Meta-Defaults-From-CementApp-Meta-Down-To-Handlers\"><a href=\"#Ability-To-Pass-Meta-Defaults-From-CementApp-Meta-Down-To-Handlers\" class=\"headerlink\" title=\"Ability To Pass Meta Defaults From CementApp.Meta Down To Handlers\"></a>Ability To Pass Meta Defaults From <code>CementApp.Meta</code> Down To Handlers</h3><p>Cement handlers are often referenced by their label, and not passed as pre-instantiated objects which requires the framework to instantiate them dynamically with no keyword arguments.</p>\n<p>For example:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [<span class=\"string\">'json'</span>]</div></pre></td></tr></table></figure>\n<p>In the above, Cement will load the <code>json</code> extension, which registers <code>JsonOutputHandler</code>.  When it comes time to recall that handler, it is looked up as <code>output.json</code> where <code>output</code> is the handler type (interface) and <code>json</code> is the handler label.  The class is then instantiated without any arguments or keyword arguments before use.  If a developer needed to override any meta options in <code>JsonOutputHandler.Meta</code> they would <strong>previously</strong> have had to sub-class it.  Consider the following example, where we sub-class <code>JsonOutputHandler</code> in order to override <code>JsonOutputHandler.Meta.json_module</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.ext.ext_json <span class=\"keyword\">import</span> JsonOutputHandler</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyJsonOutputHandler</span><span class=\"params\">(JsonOutputHandler)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        json_module = <span class=\"string\">'ujson'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">override_json_output_handler</span><span class=\"params\">(app)</span>:</span></div><div class=\"line\">    app.handler.register(MyJsonOutputHandler, force=<span class=\"keyword\">True</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [<span class=\"string\">'json'</span>]</div><div class=\"line\">        hooks = [</div><div class=\"line\">            (<span class=\"string\">'post_setup'</span>, override_json_output_handler)</div><div class=\"line\">        ]</div></pre></td></tr></table></figure>\n<p>If there were anything else in the <code>JsonOutputHandler</code> that the developer needed to subclass, this would be fine.  However the purpose of the above is soley to override <code>JsonOutputHandler.Meta.json_module</code>, which is tedious.</p>\n<p>As of Cement 2.10, the above can be accomplished more-easily by the following by way of <code>CementApp.Meta.meta_defaults</code> (similar to how <code>config_defaults</code> are handled:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">from</span> cement.core.foundation <span class=\"keyword\">import</span> CementApp</div><div class=\"line\"><span class=\"keyword\">from</span> cement.utils.misc <span class=\"keyword\">import</span> init_defaults</div><div class=\"line\"></div><div class=\"line\">META = init_defaults(<span class=\"string\">'output.json'</span>)</div><div class=\"line\">META[<span class=\"string\">'output.json'</span>][<span class=\"string\">'json_module'</span>] = <span class=\"string\">'ujson'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyApp</span><span class=\"params\">(CementApp)</span>:</span></div><div class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Meta</span>:</span></div><div class=\"line\">        label = <span class=\"string\">'myapp'</span></div><div class=\"line\">        extensions = [<span class=\"string\">'json'</span>]</div><div class=\"line\">        output_handler = <span class=\"string\">'json'</span></div><div class=\"line\">        meta_defaults = META</div></pre></td></tr></table></figure>\n<p>When <code>JsonOutputHandler</code> is instantiated, the defaults from <code>META[&#39;output.json&#39;]</code> will be passed as <code>**kwargs</code> (overriding builtin meta options).</p>\n<p>Related:</p>\n<ul>\n<li>Issue 395</li>\n</ul>\n<h3 id=\"Additional-Extensions\"><a href=\"#Additional-Extensions\" class=\"headerlink\" title=\"Additional Extensions\"></a>Additional Extensions</h3><ul>\n<li><a href=\"/2.10/api/cement.ext.ext_jinja2\">Jinja2</a> - Provides template based output handling using the Jinja2 templating language</li>\n<li><a href=\"/2.10/api/cement.ext.ext_redis\">Redis</a> - Provides caching support using  Redis backend</li>\n<li><a href=\"/2.10/api/cement.ext.ext_watchdog\">Watchdog</a> - Provides cross-platform filesystem event monitoring using the Watchdog library.</li>\n<li><a href=\"/2.10/api/cement.ext.ext_handlebars\">Handlebars</a> - Provides template based output handling using the Handlebars templating language</li>\n</ul>\n<h2 id=\"Upgrading\"><a href=\"#Upgrading\" class=\"headerlink\" title=\"Upgrading\"></a>Upgrading</h2><p>This section outlines any information and changes that might need to be made in order to update your application built on previous versions of Cement.</p>\n<h3 id=\"Upgrading-from-2-8-x-to-2-10-x\"><a href=\"#Upgrading-from-2-8-x-to-2-10-x\" class=\"headerlink\" title=\"Upgrading from 2.8.x to 2.10.x\"></a>Upgrading from 2.8.x to 2.10.x</h3><p>Cement 2.10 introduces a few incompatible changes from the previous 2.8 stable release, as noted in the ChangeLog.</p>\n<p>Deprecated:</p>\n<ul>\n<li><code>cement.core.interface.list()</code> - This function should no longer be used in favor of <code>CementApp.handler.list_types()</code>. It will continue to work throughout Cement 2.x, however is not compatible if <code>CementApp.Meta.use_backend_globals == False</code>.</li>\n</ul>\n<p>Related:</p>\n<ul>\n<li>Issue #366</li>\n<li>Issue #376</li>\n</ul>\n<h2 id=\"Change-History\"><a href=\"#Change-History\" class=\"headerlink\" title=\"Change History\"></a>Change History</h2><h3 id=\"2-10-2-Thu-July-14-2016\"><a href=\"#2-10-2-Thu-July-14-2016\" class=\"headerlink\" title=\"2.10.2 - Thu July 14, 2016\"></a>2.10.2 - Thu July 14, 2016</h3><p>Bumping version due to issue with uploading to PyPi.</p>\n<h3 id=\"2-10-0-Thu-July-14-2016\"><a href=\"#2-10-0-Thu-July-14-2016\" class=\"headerlink\" title=\"2.10.0 - Thu July 14, 2016\"></a>2.10.0 - Thu July 14, 2016</h3><p><strong>Bugs</strong></p>\n<ul>\n<li><code>[test]</code> - <code>CementTestCase</code> does not delete temporary files/directories<ul>\n<li>Issue 363</li>\n</ul>\n</li>\n<li><code>[core]</code> - AttributeError: ‘module’ object has no attribute ‘SIGHUP’ on Windows<ul>\n<li>Issue 346</li>\n</ul>\n</li>\n<li><code>[core.foundation]</code> - <code>CementApp.extend()</code> breaks on <code>CementApp.reload()</code><ul>\n<li>Issue 352</li>\n</ul>\n</li>\n<li><code>[core]</code> - Output handler override options dissappear<ul>\n<li>Issue 366</li>\n</ul>\n</li>\n<li><code>[ext]</code> - <code>JsonOutputHandler</code>, <code>YamlOutputHandler</code>, <code>MustacheOutputHandler</code> Do not pass keyword args down to backend render functions<ul>\n<li>Issue 385</li>\n</ul>\n</li>\n<li><code>[core.hook]</code> - <code>CementApp.Meta.hooks</code> ignored for hooks defined by extensions<ul>\n<li>Issue 393</li>\n</ul>\n</li>\n</ul>\n<p><strong>Features</strong></p>\n<ul>\n<li><code>[core.plugin]</code> - Support for plugin directories<ul>\n<li>Issue 350</li>\n</ul>\n</li>\n<li><code>[ext.handlebars]</code> - Handlebars templating support<ul>\n<li>Issue 370</li>\n</ul>\n</li>\n<li><code>[ext.jinja2]</code> - Jinja2 templating support<ul>\n<li>Pull Request 371</li>\n</ul>\n</li>\n<li><code>[compliance]</code> - Switch over to using Flake8 for PEP8 and style compliance<ul>\n<li>Issue 373</li>\n</ul>\n</li>\n<li><code>[ext.redis]</code> - Redis cache handler support<ul>\n<li>Issue 375</li>\n</ul>\n</li>\n<li><code>[core.config]</code> - Support for alternative config file extensions<ul>\n<li>Issue 379</li>\n</ul>\n</li>\n<li><code>[core.plugin]</code> - Support for Cython/Compiled Plugins<ul>\n<li>Issue 380</li>\n</ul>\n</li>\n<li><code>[ext.configobj]</code> - ConfigObj support for Python 3<ul>\n<li>Issue 389</li>\n</ul>\n</li>\n<li><code>[ext.watchdog]</code> - Watchdog extension for cross-platform filesystem event monitoring<ul>\n<li>Issue 394</li>\n</ul>\n</li>\n<li><code>[core.foundation]</code> - Ability to pass metadata keyword arguments to handlers via <code>CementApp.Meta.meta_defaults</code>.<ul>\n<li>Issue 395</li>\n</ul>\n</li>\n</ul>\n<p><strong>Refactoring</strong></p>\n<ul>\n<li><code>[core]</code> - Partially deprecated use of <code>imp</code> in favor of <code>importlib</code> on Python &gt;= 3.1<ul>\n<li>Issue 386</li>\n</ul>\n</li>\n<li><code>[ext.argparse]</code> - ArgparseArgumentHandler should store unknown arguments<ul>\n<li>Issue 390</li>\n</ul>\n</li>\n</ul>\n<p><strong>Incompatible</strong></p>\n<ul>\n<li><em>None</em></li>\n</ul>\n<p><strong>Deprecation</strong></p>\n<ul>\n<li><code>[ext.logging]</code> - Deprecated <code>LoggingLogHandler.warn()</code><ul>\n<li>Issue 365</li>\n</ul>\n</li>\n<li><code>[core]</code> - Deprecated Explicit Python 3.2 Support<ul>\n<li>Issue 372</li>\n</ul>\n</li>\n<li><code>[core.interface]</code> - Deprecated <code>cement.core.interface.list()</code><ul>\n<li>Issue 376</li>\n</ul>\n</li>\n</ul>\n"},{"type":"examples","version":"portland","order":1,"_content":"\n# Examples\n\nSee the list on the left side panel for examples of common use-cases, and the more complex edge-cases that we've had requests for in the past.\n","source":"portland/examples/index.md","raw":"---\ntype: examples\nversion: portland\norder: 1\n---\n\n# Examples\n\nSee the list on the left side panel for examples of common use-cases, and the more complex edge-cases that we've had requests for in the past.\n","date":"2017-11-18T23:08:01.061Z","updated":"2017-11-18T23:08:01.061Z","path":"portland/examples/index.html","_id":"cja5y1zsn0002arpw4okga34u","title":"","comments":1,"layout":"page","content":"<h1 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h1><p>See the list on the left side panel for examples of common use-cases, and the more complex edge-cases that we’ve had requests for in the past.</p>\n","excerpt":"","more":"<h1 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h1><p>See the list on the left side panel for examples of common use-cases, and the more complex edge-cases that we’ve had requests for in the past.</p>\n"},{"type":"api","title":"API Reference","version":"2.10","order":1,"_content":"\nThe Cement Framework Reference Documentation currently lives external to this site, and provides strictly API Reference direct from the library code.  All developer documentation is found here on this site.\n\n- Go To <a href=\"/{{ version }}/api/\" target=\"cement-api-reference\">Reference Documentation</a>.\n","source":"2.10/api-reference/index.md","raw":"---\ntype: api\ntitle: API Reference\nversion: \"2.10\"\norder: 1\n---\n\nThe Cement Framework Reference Documentation currently lives external to this site, and provides strictly API Reference direct from the library code.  All developer documentation is found here on this site.\n\n- Go To <a href=\"/{{ version }}/api/\" target=\"cement-api-reference\">Reference Documentation</a>.\n","date":"2017-11-18T23:23:06.269Z","updated":"2017-11-18T23:23:06.269Z","path":"2.10/api-reference/index.html","_id":"cja5yj9mi0005arpwk619bz3j","comments":1,"layout":"page","content":"<p>The Cement Framework Reference Documentation currently lives external to this site, and provides strictly API Reference direct from the library code.  All developer documentation is found here on this site.</p>\n<ul>\n<li>Go To <a href=\"/2.10/api/\" target=\"cement-api-reference\">Reference Documentation</a>.</li>\n</ul>\n","excerpt":"","more":"<p>The Cement Framework Reference Documentation currently lives external to this site, and provides strictly API Reference direct from the library code.  All developer documentation is found here on this site.</p>\n<ul>\n<li>Go To <a href=\"/2.10/api/\" target=\"cement-api-reference\">Reference Documentation</a>.</li>\n</ul>\n"}],"Post":[{"title":"Cement Portland Development","date":"2017-06-13T15:00:00.000Z","_content":"\nFIX ME\n","source":"_posts/portland-development.md","raw":"---\ntitle: Cement Portland Development\ndate: 2017-06-13 10:00:00\n---\n\nFIX ME\n","slug":"portland-development","published":1,"updated":"2017-06-14T04:46:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj5dg8qre0003h6pw4txl6vtm","content":"<p>FIX ME</p>\n","excerpt":"","more":"<p>FIX ME</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}